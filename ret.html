<html><head>  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">  <link href="http://www.tomharding.me/css/lanyon.css"  rel="stylesheet" crossorigin="anonymous"></head><body><div class="container-fluid">
  <div class="row">
    <div class="col-sm-3 bg-light border-right align-self-start" style="padding:0; position: fixed; display: block;">
    <a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">Tom Harding~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Dependable Types &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Dependable Types 4: Terms Are Types Are Terms &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Dependable Types 3: Reductio Sine Absurdum &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Dependable Types 2: Correctness by Construction &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Dependable Types 1: Full-ST&#x3BB;C Development &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 19: Semigroupoid and Category &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 18: Bifunctor and Profunctor &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 15: Monad &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 17: Comonad &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 4: Semigroup &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 16: Extend &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 14: ChainRec &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 13: Chain &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 12: Traversable &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 9: Applicative &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 11: Foldable &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Pairs as Functors &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Functions as Functors &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 10: Alt, Plus, and Alternative &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 8: Apply &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 6: Functor &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 3.5: Ord &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 7: Contravariant &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 5: Monoid &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 3: Setoid &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 1: Daggy &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Fantas, Eel, and Specification 2: Type Signatures &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Reductio and Abstract &apos;em &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Yippee Ki-Yay, All the Functors! &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Snail Shells &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      The Orrery &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Curry On Wayward Son &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Monoid Est Ton Oid &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Peano&apos;s Forte &#xB7; Tom Harding
    
  ~</a><a href="#[object Object]" class="list-group-item list-group-item-action bg-light col-2 text-truncate" style="font-size: 0.75rem;">
    
      Hello, The Internet &#xB7; Tom Harding
    
  ~</a>
    </div>
    <div class="col-sm-9 offset-3">
      <a name="[object Object]"></a>null<hr/><a name="[object Object]"></a>null<hr/><a name="[object Object]"></a>null<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Dependable Types 4: Terms Are Types Are Terms</h1>
  <span class="post-date">03 May 2018</span>
  <p>Hello again! Sorry for the wait; it has been a very busy few months, but we&#x2019;re
back for the <strong>final part</strong> of <a href="/dependable-types">the series</a>: <strong>evaluation</strong>!
Once we have our program written, how do we <em>use</em> it? How do we give it input
and, from that, compute output? Today, we&#x2019;re going to try perhaps a more
unusual approach: converting our <code class="language-plaintext highlighter-rouge">Expression</code> to an actual <strong>Idris function</strong>.
To do <em>that</em>, we&#x2019;re going to need some real dependently-typed <strong>magic</strong>.</p>

<hr>

<p>The first thing we&#x2019;re going to have to do is convert our <code class="language-plaintext highlighter-rouge">ProgramType</code> into an
actual Idris <code class="language-plaintext highlighter-rouge">Type</code>. This is a beautifully <strong>simple-looking</strong> function that is
almost <strong>unthinkable</strong> in most other languages:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ProgramTypeToType</span> <span class="o">:</span> <span class="kt">ProgramType</span> <span class="o">-&gt;</span> <span class="kt">Type</span>

<span class="kt">ProgramTypeToType</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
   <span class="o">=</span> <span class="kt">ProgramTypeToType</span> <span class="n">x</span>
  <span class="o">-&gt;</span> <span class="kt">ProgramTypeToType</span> <span class="n">y</span>

<span class="kt">ProgramTypeToType</span> <span class="kt">PInt</span> <span class="o">=</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>Give me a <code class="language-plaintext highlighter-rouge">ProgramType</code>, and I&#x2019;ll give you a <code class="language-plaintext highlighter-rouge">Type</code>. Neat, right? Now we know
we can convert a type, we can convert our entire <strong>context</strong> to a <strong>vector</strong> of
its types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ContextTypes</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">context</span> <span class="o">:</span> <span class="kt">Context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Vect</span> <span class="p">(</span><span class="n">length</span> <span class="n">context</span><span class="p">)</span> <span class="kt">Type</span>

<span class="kt">ContextTypes</span> <span class="kt">[]</span>
  <span class="o">=</span> <span class="kt">[]</span>

<span class="kt">ContextTypes</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span>
   <span class="o">=</span> <span class="kt">ProgramTypeToType</span> <span class="n">x</span>
  <span class="o">::</span> <span class="kt">ContextTypes</span> <span class="n">xs</span>
</code></pre></div></div>

<p>Yet another function with that <strong>dependently-typed magic</strong> we&#x2019;re slowly
starting to take for granted. Given a context, this produces a vector whose
length matches that context, and whose elements are <code class="language-plaintext highlighter-rouge">Type</code>s. Let that sink in&#x2026;</p>

<p>When we actually run the program, all the types in our context will also have
<strong>values</strong>&#x2026; but how do we store a list of potentially <strong>different types</strong>?
Enter the <code class="language-plaintext highlighter-rouge">HVect</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">HVect</span> <span class="o">:</span> <span class="kt">Vect</span> <span class="n">k</span> <span class="kt">Type</span> <span class="o">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">Nil</span> <span class="o">:</span> <span class="kt">HVect</span> <span class="kt">[]</span>
  <span class="p">(</span><span class="o">::</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">HVect</span> <span class="n">ts</span> <span class="o">-&gt;</span> <span class="kt">HVect</span> <span class="p">(</span><span class="n">t</span> <span class="o">::</span> <span class="n">ts</span><span class="p">)</span>
</code></pre></div></div>

<p>If this is a bit <em>confusing</em>, don&#x2019;t dwell on it: the important thing is that
<code class="language-plaintext highlighter-rouge">HVect</code> is indexed by <strong>a vector</strong> of the types of its inhabitants. This means
that a list like <code class="language-plaintext highlighter-rouge">[3, 2.0, &quot;hello&quot;]</code> has type <code class="language-plaintext highlighter-rouge">HVect [Integer, Double, String]</code>
and all will be well. It&#x2019;s super neat.</p>

<p>What this means is that we can store the <strong>values</strong> of our context in&#x2026; (<em>drum
roll, please</em>):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HVect</span> <span class="p">(</span><span class="kt">ContextTypes</span> <span class="n">context</span><span class="p">)</span>
</code></pre></div></div>

<p>This <em>blew</em> my poor little mind. We use <code class="language-plaintext highlighter-rouge">ContextTypes</code> to figure out the <em>type</em>
of our <code class="language-plaintext highlighter-rouge">context</code>, and then use <code class="language-plaintext highlighter-rouge">HVect</code> to store values of those types. At this
point, we&#x2019;re basically back to <code class="language-plaintext highlighter-rouge">List</code>, and we can go about our business as
before. In fact, we can even reuse our <code class="language-plaintext highlighter-rouge">Elem</code> references:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span>
   <span class="o">:</span> <span class="kt">Elem</span> <span class="n">programType</span> <span class="n">context</span>
  <span class="o">-&gt;</span> <span class="kt">HVect</span> <span class="p">(</span><span class="kt">ContextTypes</span> <span class="n">context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">ProgramTypeToType</span> <span class="n">programType</span>

<span class="n">get</span> <span class="kt">Here</span> <span class="p">(</span><span class="n">head</span> <span class="o">::</span> <span class="kr">_</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">head</span>

<span class="n">get</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="p">(</span><span class="kr">_</span> <span class="o">::</span> <span class="n">tail</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">get</span> <span class="n">later</span> <span class="n">tail</span>
</code></pre></div></div>

<p>By now, this should feel pretty familiar: if the value is <code class="language-plaintext highlighter-rouge">Here</code>, we get the
head, and if the value is <code class="language-plaintext highlighter-rouge">There</code>, we continue to walk the list. Because the
<code class="language-plaintext highlighter-rouge">Elem</code> points to an element of <code class="language-plaintext highlighter-rouge">context</code>, and our <code class="language-plaintext highlighter-rouge">HVect</code> is the same length as
<code class="language-plaintext highlighter-rouge">context</code>, we can be certain that this isn&#x2019;t going to cause us runtime issues,
and there isn&#x2019;t a <code class="language-plaintext highlighter-rouge">Maybe</code> in sight. <strong>Magnifique</strong>.</p>

<p>Finally, we get to the <strong>big reveal</strong>. The thing to which we&#x2019;ve been building
since the beginning. This function evaluates our little DSL into an <strong>actual
Idris value</strong>. We&#x2019;ve turned data into program, and all the types are
<strong>dependent</strong> on the shape of that data.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eval</span>
   <span class="o">:</span> <span class="p">{</span><span class="n">context</span> <span class="o">:</span> <span class="kt">Context</span><span class="p">}</span>
  <span class="o">-&gt;</span> <span class="kt">HVect</span> <span class="p">(</span><span class="kt">ContextTypes</span> <span class="n">context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">context</span> <span class="n">programType</span>
  <span class="o">-&gt;</span> <span class="kt">ProgramTypeToType</span> <span class="n">programType</span>

<span class="c1">-- Reference =&gt; Idris value</span>
<span class="n">eval</span> <span class="n">context</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">reference</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">get</span> <span class="n">reference</span> <span class="n">context</span>

<span class="c1">-- Abstraction =&gt; Idris function</span>
<span class="n">eval</span> <span class="n">context</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">parameter</span> <span class="n">body</span><span class="p">)</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">eval</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">context</span><span class="p">)</span> <span class="n">body</span>

<span class="c1">-- Application =&gt; Idris application</span>
<span class="n">eval</span> <span class="n">context</span> <span class="p">(</span><span class="kt">Application</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">eval</span> <span class="n">context</span> <span class="n">f</span> <span class="p">(</span><span class="n">eval</span> <span class="n">context</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>&#x2026; It&#x2019;s&#x2026; underwhelming, right? We went to all this trouble, and we end up
with a <strong>tiny</strong> evaluation function. Why? Well, because it really isn&#x2019;t doing
anything very special: we <em>know</em> our expression is valid, and we <em>know</em> the
expected types of all its values when we convert to Idris, so we have <strong>total
type safety</strong>. Nothing <em>could</em> go wrong because we&#x2019;ve checked it all at compile
time. In some cases, we literally <strong>proved</strong> it.</p>

<p>If you take away the type signature, this is pretty much as in-depth as <code class="language-plaintext highlighter-rouge">eval</code>
would be in any <strong>untyped</strong> language. When we see a variable, get it. When we
see a function, make a function. When we see an application, apply the value to
the function. In the end, all our hard work has paid off <strong>beautifully</strong>, and
everything starts to look a bit&#x2026; <strong>JavaScripty</strong>.</p>

<hr>

<p>Of course, we&#x2019;re professional software engineers, so let&#x2019;s write some
<strong>tests</strong>!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Apply2</span>
  <span class="o">:</span> <span class="kt">Expression</span> <span class="n">context</span>
      <span class="p">(</span><span class="kt">PFunction</span>
        <span class="p">(</span><span class="kt">PFunction</span> <span class="n">a</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">PFunction</span> <span class="n">a</span> <span class="n">a</span><span class="p">))</span>

<span class="kt">Apply2</span> <span class="p">{</span><span class="n">a</span><span class="p">}</span>
  <span class="o">=</span> <span class="kt">Abstraction</span>
      <span class="p">(</span><span class="kt">PFunction</span> <span class="n">a</span> <span class="n">a</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">a</span>
        <span class="p">(</span><span class="kt">Application</span>
          <span class="p">(</span><span class="kt">Variable</span> <span class="p">(</span><span class="kt">There</span> <span class="kt">Here</span><span class="p">))</span>
          <span class="p">(</span><span class="kt">Variable</span> <span class="kt">Here</span><span class="p">)))</span>
</code></pre></div></div>

<p>Naturally, with explicit constructor names, everything looks a little bit ugly,
but we can think of <code class="language-plaintext highlighter-rouge">Apply2</code> as <code class="language-plaintext highlighter-rouge">\f x -&gt; f x</code>, or, if you&#x2019;re more comfortable
with the Lambda notation, <code class="language-plaintext highlighter-rouge">&#x3BB;f.&#x3BB;x.fx</code>.</p>

<p>Now, if everything&#x2019;s working, applying <code class="language-plaintext highlighter-rouge">\x -&gt; x + 1</code> and <code class="language-plaintext highlighter-rouge">5</code> to this should
yield <code class="language-plaintext highlighter-rouge">6</code>, correct? Well, let&#x2019;s <em>prove</em> it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Eg0</span>
  <span class="o">:</span> <span class="n">eval</span> <span class="p">{</span><span class="n">context</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">}</span> <span class="kt">[]</span>
         <span class="p">(</span><span class="kt">Apply2</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="kt">PInt</span><span class="p">})</span>
         <span class="p">(</span><span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">5</span>
  <span class="o">=</span> <span class="mi">6</span>

<span class="kt">Eg0</span>
  <span class="o">=</span> <span class="kt">Refl</span>
</code></pre></div></div>

<p>There it is: another <code class="language-plaintext highlighter-rouge">Refl</code>. If you don&#x2019;t believe that this could work, clone
<a href="https://github.com/i-am-tom/LICK">the GitHub repository</a> and try changing the
result to <code class="language-plaintext highlighter-rouge">7</code>. Just as before, it&#x2019;s <strong>a type error</strong>. Failed unit tests are a
type error. I can&#x2019;t express how <em>exciting</em> I find this.</p>

<p>For a victory lap, let&#x2019;s try a slightly more <em>interesting</em> test. Here, we&#x2019;re
going to specify that this expression exists within a <strong>non-empty</strong> context of
two values, <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">\x -&gt; x + 1</code>. That being the case, we <em>should</em> be able to
reference those values that we&#x2019;ve passed in as context, and produce a result of
<code class="language-plaintext highlighter-rouge">4</code>. Are we feeling lucky?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Eg1</span> <span class="o">:</span> <span class="n">eval</span>
  <span class="p">{</span><span class="n">context</span> <span class="o">=</span> <span class="p">[</span><span class="kt">PInt</span><span class="p">,</span> <span class="kt">PFunction</span> <span class="kt">PInt</span> <span class="kt">PInt</span><span class="p">]}</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
  <span class="p">(</span><span class="kt">Application</span>
    <span class="p">(</span><span class="kt">Variable</span> <span class="p">(</span><span class="kt">There</span> <span class="kt">Here</span><span class="p">))</span>
    <span class="p">(</span><span class="kt">Variable</span> <span class="kt">Here</span><span class="p">))</span>

  <span class="o">=</span> <span class="mi">4</span>

<span class="kt">Eg1</span>
  <span class="o">=</span> <span class="kt">Refl</span>
</code></pre></div></div>

<p>We certainly should: everything <strong>just works</strong>. We have turned our <strong>data</strong>
into a <strong>program</strong>, and then used it to produce <strong>typed</strong> input and output <strong>at
runtime</strong>.</p>

<hr>

<p>Idris is, inarguably, an <strong>amazing</strong> language. When you first start thinking
about problems in terms of <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">reduce</code>, and <code class="language-plaintext highlighter-rouge">filter</code>, or when you finally
understand how <code class="language-plaintext highlighter-rouge">Monad</code> works, these things <strong>change the way you code</strong>. I
highly - <em>highly</em> - recommend that you buy Edwin Brady&#x2019;s book, <a href="https://www.manning.com/books/type-driven-development-with-idris">Type-Driven
Development with
Idris</a>, and
see what all the fuss is about. I can guarantee that you won&#x2019;t be disappointed.</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Dependable Types 3: Reductio Sine Absurdum</h1>
  <span class="post-date">19 Feb 2018</span>
  <p>Welcome back! This time, we&#x2019;re going to write that <code class="language-plaintext highlighter-rouge">evaluate</code> function we
mentioned in <a href="/2018/01/27/dependable-types-2/">the last article</a>&#x2026;  Strictly,
this function will be better named <code class="language-plaintext highlighter-rouge">reduce</code>, as it will perform an operation
called <strong>beta reduction</strong> (or <strong>&#x3B2;-reduction</strong>, if you&#x2019;re so inclined). What
this means is that, any time we see an <code class="language-plaintext highlighter-rouge">Abstraction</code> on the <strong>left</strong>-hand side
of an <code class="language-plaintext highlighter-rouge">Application</code>, we can <strong>simplify</strong> by taking the abstraction&#x2019;s body, and
<strong>replacing</strong> any mention of its parameter with the <strong>argument</strong>.</p>

<p>For example:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;x.x)y</code></p>
</blockquote>

<p>We can <strong>reduce</strong> this down to <code class="language-plaintext highlighter-rouge">y</code> simply by <strong>substituting</strong> <code class="language-plaintext highlighter-rouge">y</code> for all
occurrences of <code class="language-plaintext highlighter-rouge">x</code> <em>inside</em> the <code class="language-plaintext highlighter-rouge">x</code> abstraction. <strong>Woo!</strong></p>

<p>As a more <em>complicated</em> example:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;x.(&#x3BB;y.(&#x3BB;z.z)y)x)a</code></p>
</blockquote>

<p>Here, we have a few <strong>nested</strong> functions, so we handle them one at a time.
First, we substitute <code class="language-plaintext highlighter-rouge">a</code> in place of <code class="language-plaintext highlighter-rouge">x</code>:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;y.(&#x3BB;z.z)y)a</code></p>
</blockquote>

<p>Now, we&#x2019;ve <strong>eliminated</strong> the abstraction for <code class="language-plaintext highlighter-rouge">x</code> (and so the <strong>context</strong> no
longer has an <code class="language-plaintext highlighter-rouge">x</code>), but we see that <code class="language-plaintext highlighter-rouge">a</code> is now applied to the <code class="language-plaintext highlighter-rouge">y</code> abstraction.
Let&#x2019;s do the same thing for <code class="language-plaintext highlighter-rouge">y</code> as we did for <code class="language-plaintext highlighter-rouge">x</code>:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;z.z)a</code></p>
</blockquote>

<p>This is exactly the same as the <em>body</em> of the <code class="language-plaintext highlighter-rouge">y</code> abstraction, but all the
mentions of <code class="language-plaintext highlighter-rouge">y</code> have been replaced by <code class="language-plaintext highlighter-rouge">a</code>, and so <code class="language-plaintext highlighter-rouge">y</code> has been totally
<strong>eliminated</strong>! Finally, we substitute <code class="language-plaintext highlighter-rouge">a</code> in place of <code class="language-plaintext highlighter-rouge">z</code>:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">a</code></p>
</blockquote>

<p><strong>Boom</strong>. This, reader mine, is what we&#x2019;re going to do today. Before we go any
further, think about why this might be a bit <strong>trickier</strong> with De Bruijn
indices. <strong>Buckle up</strong>, friends: we&#x2019;re gonna need to write some <strong>proofs</strong>.</p>

<hr>

<p>Before we get to code, let&#x2019;s think about the <strong>type signature</strong>. If we get
everything right, the <strong>context</strong> of the reduced expression won&#x2019;t change, and
nor will the <strong>type</strong>. As our <code class="language-plaintext highlighter-rouge">Expression</code> type is indexed by both of these
things, this helps us to refine the set of <strong>possible implementations</strong>, and
hence produce fewer <strong>bugs</strong>!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reduce</span>
   <span class="o">:</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">ptype</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">ptype</span>
</code></pre></div></div>

<blockquote>
  <p><em>As usual, to make this code fit on a mobile screen, a lot of the variables
have been abbreviated. If you&#x2019;d prefer to read a more verbose form, <a href="https://github.com/i-am-tom/LICK/blob/master/src/LICK/Reduction.idr">the code
for this
post</a> is
a good place to start!</em></p>
</blockquote>

<p>Apart from an <code class="language-plaintext highlighter-rouge">Application</code> in an <code class="language-plaintext highlighter-rouge">Abstraction</code>, there&#x2019;s not anything we can do
to <strong>reduce</strong> our expression. So, with that one exception, all this is going to
look pretty uninteresting, and just like any other recursive function you might
imagine for this type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reduce</span>
   <span class="o">:</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">ptype</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">ptype</span>

<span class="n">reduce</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">param</span> <span class="n">body</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Abstraction</span> <span class="n">param</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">body</span><span class="p">)</span>

<span class="n">reduce</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Variable</span> <span class="n">ref</span>

<span class="n">reduce</span> <span class="p">(</span><span class="kt">Application</span> <span class="n">fn</span> <span class="n">arg</span><span class="p">)</span>
  <span class="n">with</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reduce</span> <span class="n">arg</span><span class="p">)</span>
    <span class="o">|</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">param</span> <span class="n">body</span><span class="p">,</span> <span class="n">arg&apos;</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">substitute</span> <span class="kt">Here</span> <span class="n">body</span> <span class="n">arg&apos;</span>
    <span class="o">|</span> <span class="p">(</span><span class="n">fn&apos;</span><span class="p">,</span> <span class="n">arg&apos;</span><span class="p">)</span>
        <span class="o">=</span> <span class="kt">Application</span> <span class="n">fn&apos;</span> <span class="n">arg&apos;</span>
</code></pre></div></div>

<p>We can see that, when we encounter the magical situation we&#x2019;re looking for, we
do some kind of <strong>substitution</strong> of <code class="language-plaintext highlighter-rouge">arg&apos;</code> in place of <code class="language-plaintext highlighter-rouge">Here</code> inside the
<code class="language-plaintext highlighter-rouge">body</code>. There&#x2019;s a catch, though: we&#x2019;re using <code class="language-plaintext highlighter-rouge">Here</code> and <code class="language-plaintext highlighter-rouge">There</code> as <strong>De Bruijn
indices</strong>.</p>

<p>Take the following:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;x.&#x3BB;y.(&#x3BB;z.x)x)</code></p>
</blockquote>

<p>When we use <em>this</em> format, we can <strong>identify</strong> all the references to <code class="language-plaintext highlighter-rouge">x</code> simply
because they&#x2019;re written as <code class="language-plaintext highlighter-rouge">x</code>. However, let&#x2019;s look at the <em>same</em> expression
when written with De Bruijn indices:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">&#x3BB;&#x3BB;(&#x3BB;3)2</code></p>
</blockquote>

<p>The variable <em>three lambdas ago</em> and the variable <em>two lambdas ago</em> are
actually the <strong>same</strong> variable! De Bruijn indices change depending on the
<strong>level</strong> of abstraction-<strong>nesting</strong>, which means that we&#x2019;ll also have to keep
track of that!</p>

<hr>

<p>Once again, let&#x2019;s think about the <strong>type</strong> for <code class="language-plaintext highlighter-rouge">substitute</code> before we write any
code. The <code class="language-plaintext highlighter-rouge">body</code> is in a different <strong>context</strong> to the <code class="language-plaintext highlighter-rouge">arg&apos;</code>: it has an extra
variable that isn&#x2019;t present in the <code class="language-plaintext highlighter-rouge">arg&apos;</code>. However, once we finish
substitution, we will have <strong>eliminated</strong> that variable entirely, so it is also
missing from the result!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitute</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">ref</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">atype</span> <span class="n">ctx</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span>
       <span class="n">ctx</span>
       <span class="n">ptype</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span>
       <span class="p">(</span><span class="n">dropElem</span> <span class="n">ctx</span> <span class="n">ref</span><span class="p">)</span>
       <span class="n">atype</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span>
       <span class="p">(</span><span class="n">dropElem</span> <span class="n">ctx</span> <span class="n">ref</span><span class="p">)</span>
       <span class="n">ptype</span>
</code></pre></div></div>

<p>Let&#x2019;s start with the simplest case: <code class="language-plaintext highlighter-rouge">Application</code>. In this instance, we recurse
down through <strong>both sides</strong>, and we&#x2019;re done. We&#x2019;ll find that <code class="language-plaintext highlighter-rouge">Application</code> is
very much the <strong>simple case</strong> in this process, as it is the only one of the
three constructors that doesn&#x2019;t touch the <strong>context</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitute</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Application</span> <span class="n">fn</span> <span class="n">x</span><span class="p">)</span> <span class="n">arg</span>
  <span class="o">=</span> <span class="kt">Application</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">ref</span> <span class="n">fn</span> <span class="n">arg</span><span class="p">)</span>
                <span class="p">(</span><span class="n">substitute</span> <span class="n">ref</span> <span class="n">x</span>  <span class="n">arg</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, let&#x2019;s have a little look at the case of <code class="language-plaintext highlighter-rouge">Abstraction</code>. We probably want to
increment the index we&#x2019;re looking for, so we&#x2019;ll stick a <code class="language-plaintext highlighter-rouge">There</code> on it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitute</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">param</span> <span class="n">body</span><span class="p">)</span> <span class="n">arg</span>
  <span class="o">=</span> <span class="kt">Abstraction</span>
      <span class="n">param</span>
      <span class="p">(</span><span class="n">substitute</span> <span class="p">(</span><span class="kt">There</span> <span class="n">ref</span><span class="p">)</span> <span class="n">body</span> <span class="n">arg</span><span class="p">)</span>
</code></pre></div></div>

<p>&#x2026; Not quite.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Type mismatch between
  Expression
    (dropElem ctx ref)
    atype

    (Type of arg)
and
  Expression
    (dropElem (param :: ctx) (There ref))
    atype

    (Expected type)
</code></pre></div></div>

<p>This type error rightly tells us that <code class="language-plaintext highlighter-rouge">arg</code> is the problem here, and
specifically that it is in the <strong>wrong context</strong>: inside the <code class="language-plaintext highlighter-rouge">Abstraction</code>,
there is an <strong>extra</strong> parameter in our context to worry about, so we need to
update the <code class="language-plaintext highlighter-rouge">arg</code> context accordingly. Luckily, we know that the <code class="language-plaintext highlighter-rouge">arg</code> works in
the <code class="language-plaintext highlighter-rouge">ctx</code> context, so <code class="language-plaintext highlighter-rouge">param</code> doesn&#x2019;t get a mention inside. All we need to do
is <strong>increment</strong> the references.</p>

<p><em>&#x2026; Ish</em>. If a variable is introduced <em>within</em> that <code class="language-plaintext highlighter-rouge">body</code>, we should <strong>not</strong>
bump the reference - we only care about those that come from <strong>outside</strong> the
<code class="language-plaintext highlighter-rouge">body</code>, which we call the <strong>free</strong> variables of the <code class="language-plaintext highlighter-rouge">body</code> expression.
Symmetrically, those that come from <strong>inside</strong> the <code class="language-plaintext highlighter-rouge">body</code> will be referred to
as <strong>bound</strong> variables.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expandContext</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">bound</span> <span class="o">:</span> <span class="kt">Context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="p">(</span><span class="n">bound</span> <span class="o">++</span>      <span class="n">free</span><span class="p">)</span> <span class="n">t</span>
  <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="p">(</span><span class="n">bound</span> <span class="o">++</span> <span class="n">a</span> <span class="o">::</span> <span class="n">free</span><span class="p">)</span> <span class="n">t</span>
</code></pre></div></div>

<p>This type describes what we want: <em>expand the <strong>context</strong> by one more <strong>bound</strong>
variable</em>. Consequently, we&#x2019;ll need to <strong>increment</strong> all <code class="language-plaintext highlighter-rouge">free</code> references, but
none of the <code class="language-plaintext highlighter-rouge">bound</code> references. <em>Sorry if these last few paragraphs take a few
readthroughs&#x2026;</em></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expandContext</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Application</span> <span class="n">fn</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Application</span> <span class="p">(</span><span class="n">expandContext</span> <span class="n">ctx</span> <span class="n">fn</span><span class="p">)</span>
                <span class="p">(</span><span class="n">expandContext</span> <span class="n">ctx</span> <span class="n">x</span><span class="p">)</span>

<span class="n">expandContext</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">param</span> <span class="n">body</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Abstraction</span>
      <span class="n">param</span>
      <span class="p">(</span><span class="n">expandContext</span> <span class="p">(</span><span class="n">param</span> <span class="o">::</span> <span class="n">ctx</span><span class="p">)</span> <span class="n">body</span><span class="p">)</span>

<span class="n">expandContext</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Variable</span> <span class="p">(</span><span class="n">expandElemContext</span> <span class="n">ctx</span> <span class="n">ref</span><span class="p">)</span>
</code></pre></div></div>

<p>As before, <code class="language-plaintext highlighter-rouge">Application</code> is nice and easy. <code class="language-plaintext highlighter-rouge">Abstraction</code> is a bit ugly, but as
expected: we add this new <code class="language-plaintext highlighter-rouge">param</code> to the <strong>bound</strong> list, and recurse. The fun
happens in the <code class="language-plaintext highlighter-rouge">Variable</code> case: we want to update the <code class="language-plaintext highlighter-rouge">ref</code> when it&#x2019;s a
reference to a <strong>free</strong> variable. Let&#x2019;s have a look at that function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expandElemContext</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">bound</span> <span class="o">:</span> <span class="kt">Context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Elem</span> <span class="n">t</span> <span class="p">(</span><span class="n">bound</span> <span class="o">++</span>      <span class="n">free</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Elem</span> <span class="n">t</span> <span class="p">(</span><span class="n">bound</span> <span class="o">++</span> <span class="n">a</span> <span class="o">::</span> <span class="n">free</span><span class="p">)</span>

<span class="n">expandElemContext</span> <span class="kt">[]</span> <span class="n">ref</span>
  <span class="o">=</span> <span class="kt">There</span> <span class="n">ref</span>

<span class="n">expandElemContext</span> <span class="p">(</span><span class="kr">_</span> <span class="o">::</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">Here</span>
  <span class="o">=</span> <span class="kt">Here</span>

<span class="n">expandElemContext</span> <span class="p">(</span><span class="kr">_</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">There</span> <span class="p">(</span><span class="n">expandElemContext</span> <span class="n">xs</span> <span class="n">later</span><span class="p">)</span>
</code></pre></div></div>

<p>When we have an <strong>empty context</strong>, all references must be <strong>free</strong>. If we have
a <code class="language-plaintext highlighter-rouge">Here</code> reference to a <strong>non-empty</strong> context, we know it must be <strong>bound</strong>! In
any other case, we can just drop the most recent bound variable, and a layer of
the reference, and <strong>recurse</strong>! This function isn&#x2019;t too scary, really: we
<strong>ignore</strong> a reference <strong>within</strong> the context, and increment a reference
<strong>beyond</strong>. <em>Don&#x2019;t panic!</em></p>

<p>Now we have all that out the way, we can rewrite our <code class="language-plaintext highlighter-rouge">substitute</code> statement:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitute</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Abstraction</span> <span class="n">param</span> <span class="n">body</span><span class="p">)</span> <span class="n">arg</span>
  <span class="o">=</span> <span class="kt">Abstraction</span>
      <span class="n">param</span>
      <span class="p">(</span> <span class="n">substitute</span>
          <span class="p">(</span><span class="kt">There</span> <span class="n">ref</span><span class="p">)</span>
          <span class="n">body</span>
          <span class="p">(</span><span class="n">expandContext</span> <span class="kt">[]</span> <span class="n">arg</span><span class="p">)</span>
      <span class="p">)</span>
</code></pre></div></div>

<p><strong>Magnifique</strong>.</p>

<hr>

<p>The only case we haven&#x2019;t considered for <code class="language-plaintext highlighter-rouge">substitute</code> yet is <code class="language-plaintext highlighter-rouge">Variable</code>. I&#x2019;ve
deliberately left this one until last because, well, it&#x2019;s quite <strong>scary</strong>. To
people unfamiliar with Idris, this is going to look&#x2026;  well, <strong>unfamiliar</strong>.
Nevertheless, let&#x2019;s <strong>crack on</strong>!</p>

<p>When we encounter a <code class="language-plaintext highlighter-rouge">Variable</code> within an expression, one of <strong>two things</strong> may
be true:</p>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">Variable</code>&#x2019;s reference is <em>not</em> the one we&#x2019;re looking to eliminate, so we
just <strong>update</strong> it if necessary.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">Variable</code>&#x2019;s reference <em>is</em> the one we&#x2019;re looking for, and we want to
<strong>replace</strong> this <code class="language-plaintext highlighter-rouge">Variable</code> with the given <code class="language-plaintext highlighter-rouge">arg</code>.</p>
  </li>
</ul>

<p>Now, if the variable <em>is</em> the one we&#x2019;re looking for, we&#x2019;re going to have to
<strong>prove</strong> a couple things to Idris. First of all, <code class="language-plaintext highlighter-rouge">atype</code> and <code class="language-plaintext highlighter-rouge">ptype</code> are going
to have to be <strong>equivalent</strong>. If we can&#x2019;t prove this, Idris won&#x2019;t let us unify
<code class="language-plaintext highlighter-rouge">atype</code> and <code class="language-plaintext highlighter-rouge">ptype</code>, as they <em>could</em> be different. Secondly, we have to prove
that the context references are indeed the same! The order isn&#x2019;t especially
important, but <strong>both</strong> are required to satisfy the compiler.</p>

<p>Enough stalling for time; let&#x2019;s see the <strong>beast</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitute</span> <span class="p">{</span><span class="n">atype</span><span class="p">}</span> <span class="p">{</span><span class="n">ptype</span><span class="p">}</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref&apos;</span><span class="p">)</span> <span class="n">arg</span>
    <span class="n">with</span> <span class="p">(</span><span class="n">decEq</span> <span class="n">ptype</span> <span class="n">atype</span><span class="p">)</span>
  <span class="n">substitute</span> <span class="p">{</span><span class="n">atype</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">}</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref&apos;</span><span class="p">)</span> <span class="n">arg</span>
    <span class="o">|</span> <span class="p">(</span><span class="kt">Yes</span> <span class="kt">Refl</span><span class="p">)</span>
          <span class="n">with</span> <span class="p">(</span><span class="n">decEq</span> <span class="n">ref&apos;</span> <span class="n">ref</span><span class="p">)</span>
        <span class="n">substitute</span> <span class="n">ref&apos;</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref&apos;</span><span class="p">)</span> <span class="n">arg</span>
          <span class="o">|</span> <span class="p">(</span><span class="kt">Yes</span> <span class="kt">Refl</span><span class="p">)</span>
          <span class="o">|</span> <span class="p">(</span><span class="kt">Yes</span> <span class="kt">Refl</span><span class="p">)</span>
          <span class="o">=</span> <span class="n">arg</span>
        <span class="n">substitute</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref&apos;</span><span class="p">)</span> <span class="n">arg</span>
          <span class="o">|</span> <span class="p">(</span><span class="kt">Yes</span> <span class="kt">Refl</span><span class="p">)</span>
          <span class="o">|</span> <span class="p">(</span><span class="kt">No</span> <span class="n">contra</span><span class="p">)</span>
          <span class="o">=</span> <span class="kt">Variable</span> <span class="p">(</span><span class="n">independentRefs</span> <span class="n">ref&apos;</span> <span class="n">ref</span> <span class="n">contra</span><span class="p">)</span>
  <span class="n">substitute</span> <span class="n">ref</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">ref&apos;</span><span class="p">)</span> <span class="n">arg</span>
    <span class="o">|</span> <span class="p">(</span><span class="kt">No</span> <span class="n">contra</span><span class="p">)</span>
    <span class="o">=</span> <span class="kt">Variable</span> <span class="p">(</span><span class="n">independentValues</span> <span class="n">ref&apos;</span> <span class="n">ref</span> <span class="n">contra</span><span class="p">)</span>
</code></pre></div></div>

<p><em>Warned you, right?</em> There are a couple things going on here. Firstly, we&#x2019;re
<strong>pulling terms out of the type</strong>. This is another bit of &#x201C;dependently-typed
magic&#x201D;: we can <strong>reflect</strong> things down from the type-level, such as <code class="language-plaintext highlighter-rouge">atype</code> and
<code class="language-plaintext highlighter-rouge">ptype</code> (the <code class="language-plaintext highlighter-rouge">ProgramType</code> indices for the expression and the substitution),
and then use them <strong>within our function</strong>! <em>Types are terms are types are
terms.</em> It really is <strong>magical</strong>.</p>

<p>Now we have access to those values, we can use <code class="language-plaintext highlighter-rouge">decEq</code> (<strong>decidable equality</strong>)
to compare them. The result of doing so is either <code class="language-plaintext highlighter-rouge">Yes prf</code> or <code class="language-plaintext highlighter-rouge">No contra</code>,
where <code class="language-plaintext highlighter-rouge">prf</code> and <code class="language-plaintext highlighter-rouge">contra</code> are <strong>proofs</strong> of one way or the other. We&#x2019;ll see more
of these in a moment.</p>

<blockquote>
  <p><em>I&#x2019;m omitting the accompanying <a href="https://github.com/i-am-tom/LICK/blob/master/src/LICK/ProgramType.idr#L21-L62"><code class="language-plaintext highlighter-rouge">DecEq ProgramType</code>
implementation</a>
because it&#x2019;s quite <strong>mechanical</strong>, and doesn&#x2019;t contain anything we&#x2019;re not about
to see. However, if you&#x2019;re enjoying this, I&#x2019;d encourage you to go take a
look!</em></p>
</blockquote>

<p>If we successfully prove <strong>both</strong>, the result is simply <code class="language-plaintext highlighter-rouge">arg</code>: we know that
we&#x2019;re safe to make the substitution, so we replace the <code class="language-plaintext highlighter-rouge">Variable</code> with the
<code class="language-plaintext highlighter-rouge">arg</code> we&#x2019;ve been carrying. <strong>Job done</strong>! If that <em>isn&#x2019;t</em>, the case, however, we
have a <em>little</em> more work to do. Specifically, we need to <strong>update</strong> the
<code class="language-plaintext highlighter-rouge">Variable</code> index to account for the now-eliminated parameter. To avoid a
<code class="language-plaintext highlighter-rouge">Maybe</code>, let&#x2019;s have a go at <strong>proving</strong> that our reference can be adjusted
safely. You&#x2019;ll notice that the above code had two proofs: <code class="language-plaintext highlighter-rouge">independentRefs</code> and
<code class="language-plaintext highlighter-rouge">independentValues</code> are the holes that we&#x2019;re going to have to fill.</p>

<blockquote>
  <p><em>Don&#x2019;t think there was any magic in the selection of proofs. Most of this
code was written with a <strong>lot</strong> of help from Idris&#x2019; editor plugin. Most of
the time with proofs, the <strong>obvious proof search</strong> will do most (if not all)
the work for you!</em></p>
</blockquote>

<hr>

<p>Firstly, let&#x2019;s look at the <strong>type</strong> of <code class="language-plaintext highlighter-rouge">independentRefs</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentRefs</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">l</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="p">(</span><span class="n">dropElem</span> <span class="n">xs</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>Here, we have to prove that, if the <code class="language-plaintext highlighter-rouge">l</code> and <code class="language-plaintext highlighter-rouge">r</code> values are <strong>not</strong> equal, <code class="language-plaintext highlighter-rouge">x</code>
will exist in the list <strong>without</strong> the element to which <code class="language-plaintext highlighter-rouge">r</code> refers. In other,
simpler words: if <code class="language-plaintext highlighter-rouge">l</code> and <code class="language-plaintext highlighter-rouge">r</code> are both references to a value of some type, and
they&#x2019;re not the same, that type must be in there at least twice, and we can
remove one <em>and</em> provide a reference to another!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentRefs</span> <span class="kt">Here</span> <span class="kt">Here</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="n">absurd</span> <span class="p">(</span><span class="n">prf</span> <span class="kt">Refl</span><span class="p">)</span>
</code></pre></div></div>

<p>We first deal with the case in which the two references <em>are</em> the same.
However, we already have a proof that this can&#x2019;t be the case, so this is&#x2026;
<code class="language-plaintext highlighter-rouge">absurd</code>! The proof is <code class="language-plaintext highlighter-rouge">Refl</code> (we can think of this as &#x201C;obvious&#x201D; for now),
given the proof that <code class="language-plaintext highlighter-rouge">Not (l = r)</code>.</p>

<blockquote>
  <p>I won&#x2019;t go into too much detail, but <code class="language-plaintext highlighter-rouge">absurd</code> is a function from <code class="language-plaintext highlighter-rouge">Void</code> to
<strong>anything</strong>. In other words, <em>there&#x2019;s no way this can happen!</em></p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentRefs</span> <span class="kt">Here</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="kt">Here</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">l</code> points to the <strong>first</strong> element, and <code class="language-plaintext highlighter-rouge">r</code> to any <strong>other</strong>, then we know
that dropping <code class="language-plaintext highlighter-rouge">r</code> will make no difference - the element will be in <strong>first</strong>
place!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentRefs</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="kt">Here</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="n">later</span>
</code></pre></div></div>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">r</code> points to the <strong>first</strong>, and <code class="language-plaintext highlighter-rouge">l</code> to something <strong>later</strong>, the
element is simply one place <strong>closer</strong> to the start than before.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentRefs</span> <span class="p">(</span><span class="kt">There</span> <span class="n">this</span><span class="p">)</span> <span class="p">(</span><span class="kt">There</span> <span class="n">that</span><span class="p">)</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="kt">There</span> <span class="p">(</span><span class="n">independentRefs</span> <span class="n">this</span> <span class="n">that</span> <span class="p">(</span><span class="n">prf</span> <span class="o">.</span> <span class="n">cong</span><span class="p">))</span>
</code></pre></div></div>

<p>Here&#x2019;s our recursive step. If <em>both</em> references are later on, we recurse.
Notice the <code class="language-plaintext highlighter-rouge">cong</code> function here:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cong</span> <span class="o">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p><em>&#x201C;If <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are the same, applying <code class="language-plaintext highlighter-rouge">f</code> to both will give the same
answer&#x201D;</em>. The <code class="language-plaintext highlighter-rouge">f</code> here is <code class="language-plaintext highlighter-rouge">There</code>: if we can remove a <code class="language-plaintext highlighter-rouge">There</code> from each and
still prove that they&#x2019;re the same, we&#x2019;re good! Now, what about that
<code class="language-plaintext highlighter-rouge">independentValues</code> function? Well, it&#x2019;s almost <strong>identical</strong> to the above. The
only reason it has to exist is that, this time, we want to prove that, if the
referenced <strong>values</strong> are different, removing one won&#x2019;t remove the other:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentValues</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">l</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">y</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Not</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="p">(</span><span class="n">dropElem</span> <span class="n">xs</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>This one is even simpler, as we don&#x2019;t have to carry the <code class="language-plaintext highlighter-rouge">cong</code> proof: we only
care about the proof at the point that it <strong>fails</strong>. <em>Voila</em>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">independentValues</span> <span class="kt">Here</span> <span class="kt">Here</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="n">absurd</span> <span class="p">(</span><span class="n">prf</span> <span class="kt">Refl</span><span class="p">)</span>

<span class="n">independentValues</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="kt">Here</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="n">later</span>

<span class="n">independentValues</span> <span class="kt">Here</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="kt">Here</span>

<span class="n">independentValues</span> <span class="p">(</span><span class="kt">There</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">There</span> <span class="n">later</span><span class="p">)</span> <span class="n">prf</span>
  <span class="o">=</span> <span class="kt">There</span> <span class="p">(</span><span class="n">independentValues</span> <span class="n">x</span> <span class="n">later</span> <span class="n">prf</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, we have <strong>everything</strong> we need. We&#x2019;ve made it, friends: the above is
<strong>almost everything</strong> from <a href="https://github.com/i-am-tom/LICK/blob/master/src/LICK/Reduction.idr">this article&#x2019;s
code</a>.
Still, while we&#x2019;re here, why don&#x2019;t we try one last <strong>party trick</strong>?</p>

<hr>

<p>Earlier, we had this expression:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">(&#x3BB;x.(&#x3BB;y.(&#x3BB;z.z)y)x)a</code></p>
</blockquote>

<p>If we convert this to our format, we get something rather more <strong>ugly</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Test</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">context</span><span class="p">)</span> <span class="n">x</span>
<span class="kt">Test</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="c1">-- x is just a type!</span>
  <span class="o">=</span> <span class="kt">Application</span>
      <span class="p">(</span> <span class="kt">Abstraction</span>
          <span class="n">x</span>
          <span class="p">(</span> <span class="kt">Application</span>
              <span class="p">(</span> <span class="kt">Abstraction</span>
                  <span class="n">x</span>
                  <span class="p">(</span> <span class="kt">Application</span>
                      <span class="p">(</span> <span class="kt">Abstraction</span>
                          <span class="n">x</span>
                          <span class="p">(</span> <span class="kt">Variable</span> <span class="kt">Here</span>
                          <span class="p">)</span>
                      <span class="p">)</span>
                      <span class="p">(</span> <span class="kt">Variable</span> <span class="kt">Here</span>
                      <span class="p">)</span>
                  <span class="p">)</span>
              <span class="p">)</span>
              <span class="p">(</span> <span class="kt">Variable</span> <span class="kt">Here</span>
              <span class="p">)</span>
          <span class="p">)</span>
      <span class="p">)</span>
      <span class="p">(</span> <span class="kt">Variable</span> <span class="kt">Here</span>
      <span class="p">)</span>
</code></pre></div></div>

<p>Here, we&#x2019;re saying that <code class="language-plaintext highlighter-rouge">Test</code> is an <strong>expression</strong> in <em>any</em> context with an
<code class="language-plaintext highlighter-rouge">x</code> at the head, and it has a <strong>return type</strong> of <code class="language-plaintext highlighter-rouge">x</code>. Given that we already
<em>know</em> the result of reducing this expression is just <code class="language-plaintext highlighter-rouge">Variable Here</code>, why
don&#x2019;t we write a test?</p>

<p><strong>Dependent types to the rescue</strong> once more. Thanks to the magic of Idris,
where terms are types and types are terms, we can write our tests at the
<strong>type-level</strong>, and have them checked whenever we <strong>compile</strong>! On top of that,
the compiler will recognise them as dead code <em>after</em> type-checking, so they
won&#x2019;t appear in the output binary! Here&#x2019;s how we&#x2019;d write the <strong>type</strong> of our
test:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allClear</span>
  <span class="o">:</span> <span class="n">reduce</span> <span class="p">(</span><span class="kt">Test</span> <span class="p">{</span><span class="n">context</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">}</span> <span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="kt">PInt</span><span class="p">})</span>
  <span class="o">=</span> <span class="kt">Variable</span> <span class="kt">Here</span>
</code></pre></div></div>

<p>We&#x2019;re giving the compiler a couple hints here: to avoid polymorphism confusion,
we <strong>specialise</strong> our <code class="language-plaintext highlighter-rouge">context</code> and <code class="language-plaintext highlighter-rouge">x</code> values to make it easier for the
type-checker. In actual fact, this is <em>required</em> for the next step. What this
<strong>type</strong> says is that reducing our expression is <strong>equivalent</strong> to the reduced
form we expect. What do we write for our body, though?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allClear</span>
  <span class="o">=</span> <span class="kt">Refl</span>
</code></pre></div></div>

<p>The most <strong>beautiful</strong> line in this whole post. The type-checker will do the
reduction, arrive at the result of <code class="language-plaintext highlighter-rouge">Variable Here</code>, and then the proof of this
test becomes <strong>obvious</strong>. Now, whenever we <strong>change</strong> our code, this reduction
will be carried out, and the result will be checked. If the result does not
match the intended output, <strong>compilation</strong> will <strong>fail</strong>.</p>

<p><strong>Failing tests are now type errors</strong>. How <em>awesome</em> is that?</p>

<hr>

<p>Ok, this has been the longest post I&#x2019;ve written by quite a way, but there was a
lot to cover! I hope this has given you some sort of idea about how we write
<strong>proofs</strong> for the type system, and how they allow us to expand <strong>contexts</strong>,
update variable <strong>references</strong>, and all sorts of things we haven&#x2019;t covered
here!</p>

<p>Next time, we&#x2019;ll be looking at some serious dependently-typed <strong>magic</strong>. We&#x2019;ll
be turning our <code class="language-plaintext highlighter-rouge">Expression</code> values into <strong>actual Idris functions</strong> that we can
call with arguments and receive results, all while remaining totally
<strong>type-safe</strong>.  Until then, feel free to <a href="https://twitter.com/am_i_tom">contact me on
Twitter</a> with any suggestions, questions,
criticisms, and so on. I&#x2019;d love to hear from you, and see what you&#x2019;ve been
concocting!</p>

<p>Until next time, take care &#x2665;</p>

<p><em>As always, a huge thanks to <a href="https://twitter.com/goodacre_liam">Liam</a> for
teaching me everything I know about Idris. Thanks also to
<a href="https://twitter.com/gabeijohnson">Gabe</a> for proofreading this article (among
many)!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Dependable Types 2: Correctness by Construction</h1>
  <span class="post-date">27 Jan 2018</span>
  <p>Part two already, is it? Well, I suppose it&#x2019;s about time to write some code!
<a href="/2018/01/09/dependable-types/">Last time</a>, we covered the constructions of the
<strong>lambda calculus</strong>, as well as <strong>De Bruijn indices</strong>. Today, we&#x2019;re going to
cover basically the same thing, but encoding everything we learnt in <strong>Idris</strong>!
If you&#x2019;re not familiar with Idris or dependently-typed programming, things are
going to start getting&#x2026; <em>weird</em>.</p>

<hr>

<p>As you may remember, the ultimate goal is to represent the simply-typed lambda
calculus. With that in mind, we should probably define some <strong>simple types</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">ProgramType</span>
  <span class="o">=</span> <span class="kt">PFunction</span> <span class="kt">ProgramType</span> <span class="kt">ProgramType</span>
  <span class="o">|</span> <span class="kt">PInt</span>
</code></pre></div></div>

<p>So, for now, we only have two types: <strong>functions</strong> (from one type to another),
and <strong>integers</strong>. <em>If you want to add more simple types, it&#x2019;s as easy as you
think!</em></p>

<p>Now that&#x2019;s sorted, let&#x2019;s have a go at building <strong>expressions</strong> with an
<strong>abstract data type</strong>.</p>

<h2 id="first-try-adts">First try: ADTs</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Expression</span>
  <span class="o">=</span> <span class="kt">Variable</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Abstraction</span> <span class="kt">ProgramType</span> <span class="kt">Expression</span>
  <span class="o">|</span> <span class="kt">Application</span> <span class="kt">Expression</span> <span class="kt">Expression</span>
</code></pre></div></div>

<p>Just as the last article did, we&#x2019;re saying there are essentially only three
types of expressions:</p>

<ul>
  <li>
    <p><strong>Variables</strong>, which we can reference by <strong>De Bruijn index</strong> (if
zero-indexed, this is essentially <em>how many variables have been introduced
<strong>since</strong> the one I care about?)</em></p>
  </li>
  <li>
    <p><strong>Abstractions</strong>, which introduce a <strong>new</strong> variable with a given type that
can be referenced within the given body.</p>
  </li>
  <li>
    <p><strong>Applications</strong>, which take the value on the right, and apply it to the
function on the left.</p>
  </li>
</ul>

<p>This is a <strong>perfectly sensible</strong> way to represent the calculus, and feel free
to write it an interpreter - we&#x2019;ll certainly be writing one later in the
series! I&#x2019;d imagine you&#x2019;ll have a type signature like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">interpret</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Expression</span>
</code></pre></div></div>

<p>So, that&#x2019;s&#x2026; <em>fine</em>&#x2026; but that <code class="language-plaintext highlighter-rouge">Maybe</code> is kind of ugly, right? Why does it
need to be there? If you&#x2019;ve had some experience with Haskell-like languages
before, you&#x2019;ve probably already had a suspicion or two:</p>

<ul>
  <li>
    <p>How do we know the index in every <code class="language-plaintext highlighter-rouge">Variable</code> is valid? What if it&#x2019;s higher
than the <strong>outermost</strong> variable&#x2019;s index? What if it&#x2019;s <em>negative</em>?!</p>
  </li>
  <li>
    <p>How do we <em>know</em> the left expression in <code class="language-plaintext highlighter-rouge">Application</code> is a <strong>function</strong>? How
do we know that its input <strong>type</strong> matches the right expression&#x2019;s type?</p>
  </li>
</ul>

<p>The more you stare at it, the more holes you can see, and that <code class="language-plaintext highlighter-rouge">Maybe</code> looks
more and more inevitable. Today, friends, we&#x2019;ll ask whether we could do&#x2026;
<em>better</em>.</p>

<h2 id="second-try-generalised-adts">Second try: <em>Generalised</em> ADTs.</h2>

<p>Here&#x2019;s where we officially break from Elm and PureScript. <em>Still not from
Haskell, providing you have the <code class="language-plaintext highlighter-rouge">GADTs</code> and <code class="language-plaintext highlighter-rouge">DataKinds</code> extensions enabled</em>.
Within Idris, we can have greater control of our data type using a clever
notion called <strong>GADTs</strong>. We don&#x2019;t have enough time in this post to explain them
in depth, so let&#x2019;s just say that they give us more control over the
<strong>construction</strong> of our type&#x2019;s values. If that means nothing to you, don&#x2019;t
worry! Here&#x2019;s an example of the above ADT rewritten as a <em>GADT</em>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Expression</span> <span class="o">:</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">Variable</span>
     <span class="o">:</span> <span class="kt">Int</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span>

  <span class="kt">Abstraction</span>
     <span class="o">:</span> <span class="kt">ProgramType</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span>

  <span class="kt">Application</span>
     <span class="o">:</span> <span class="kt">Expression</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span>
</code></pre></div></div>

<p>Great. So far, we&#x2019;ve just got a more long-winded way of doing the same thing.
<strong>What&#x2019;s the big deal</strong>? Well, let&#x2019;s have a go at solving that <strong>type
mismatch</strong> issue: Let&#x2019;s <strong>index</strong> our type by a <strong>ProgramType</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Expression</span> <span class="o">:</span> <span class="kt">ProgramType</span> <span class="o">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">Abstraction</span>
     <span class="o">:</span> <span class="p">(</span><span class="n">paramType</span> <span class="o">:</span> <span class="kt">ProgramType</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">bodyType</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="n">paramType</span> <span class="n">bodyType</span><span class="p">)</span>

  <span class="kt">Application</span>
     <span class="o">:</span> <span class="kt">Expression</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="n">input</span> <span class="n">output</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">input</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">output</span>

  <span class="kt">Variable</span> <span class="o">:</span> <span class="o">...</span> <span class="c1">-- More on this later...</span>
</code></pre></div></div>

<p>Here&#x2019;s where things get <strong>truly magical</strong>. In the first line, we say that
<code class="language-plaintext highlighter-rouge">Expression</code> is a type constructor that takes a <code class="language-plaintext highlighter-rouge">ProgramType</code> (just like
<code class="language-plaintext highlighter-rouge">Array</code> is a type constructor that takes a <code class="language-plaintext highlighter-rouge">Type</code> - <code class="language-plaintext highlighter-rouge">Array Int</code>, <code class="language-plaintext highlighter-rouge">Array
String</code>, and so on). This means, whenever we mention an <code class="language-plaintext highlighter-rouge">Expression</code>, we also
mention its <strong>type</strong> - now, we can be sure that <code class="language-plaintext highlighter-rouge">Application</code>&#x2019;s components have
the right types!</p>

<p>This is going to look <em>really</em> weird to Haskell-like language users.
<code class="language-plaintext highlighter-rouge">ProgramType</code> is the data type we defined earlier, and now we&#x2019;re using it
<strong>inside a type</strong>! This is what makes Idris, and <em>dependent types</em>, special: we use <strong>the same
language</strong> to talk about <strong>types</strong> and <strong>values</strong>. We&#x2019;ll see later that we can
even <strong>pull things out of a type</strong> to use as values&#x2026; <em>and vice versa</em>.</p>

<p>We can pat ourselves on the back: we have solved the type mismatch issue.
However, you&#x2019;ll notice I&#x2019;ve tiptoed around <code class="language-plaintext highlighter-rouge">Variable</code>. Our issue was that we
would need to bounds check the <code class="language-plaintext highlighter-rouge">Int</code>; how are we going to fix that?</p>

<h2 id="a-small-digression-elem">A small digression: <code class="language-plaintext highlighter-rouge">Elem</code></h2>

<p>Idris has a lovely little type called <code class="language-plaintext highlighter-rouge">Elem</code> that is written like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Elem</span> <span class="o">:</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">Here</span>  <span class="o">:</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kt">There</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="kt">Elem</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<p>Let&#x2019;s break it down. <code class="language-plaintext highlighter-rouge">Elem</code> is a type indexed by two things: a <strong>value</strong> of
some type <code class="language-plaintext highlighter-rouge">a</code>, and a <strong>list of values</strong> of type <code class="language-plaintext highlighter-rouge">a</code>. <code class="language-plaintext highlighter-rouge">Here</code> says, <em>the first
thing in the list is the value</em> (<code class="language-plaintext highlighter-rouge">::</code> is how we write <code class="language-plaintext highlighter-rouge">cons</code> in Idris: <code class="language-plaintext highlighter-rouge">x ::
xs</code> is a list where <code class="language-plaintext highlighter-rouge">x</code> is the item at the front, and <code class="language-plaintext highlighter-rouge">xs</code> is the rest of the
items). <code class="language-plaintext highlighter-rouge">There</code> says, <em>it isn&#x2019;t the first thing, but it <strong>is</strong> in the list</em>.
Here are a few examples:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">valid</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">valid</span> <span class="o">=</span> <span class="kt">Here</span>

<span class="n">alsoValid</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="s">&quot;az&quot;</span> <span class="p">[</span><span class="s">&quot;oo&quot;</span><span class="p">,</span> <span class="s">&quot;ar&quot;</span><span class="p">,</span> <span class="s">&quot;az&quot;</span><span class="p">]</span>
<span class="n">alsoValid</span> <span class="o">=</span> <span class="kt">There</span> <span class="p">(</span><span class="kt">There</span> <span class="kt">Here</span><span class="p">)</span>

<span class="n">invalid</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">-- Type error!</span>

<span class="n">alsoInvalid</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">alsoInvalid</span> <span class="o">=</span> <span class="kt">Here</span> <span class="c1">-- Should be There Here!</span>
</code></pre></div></div>

<p>What we have is a <strong>type-level</strong> way of proving that something exists within a
list. All well and good, but how does this <em>help</em> us?</p>

<h2 id="third-time-lucky-doubly-indexed-gadts">Third time lucky: doubly-indexed GADTs</h2>

<p>Here&#x2019;s where we solve all our problems. Firstly, let&#x2019;s talk about
<strong>variables</strong>. Every time we use <code class="language-plaintext highlighter-rouge">Abstraction</code>, we introduce a new variable
with a given type into the &#x201C;context&#x201D; of our expression. How do you suppose we
can keep track of the <strong>list of variables</strong> and their types, though?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Context</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kt">Context</span> <span class="o">=</span> <span class="kt">List</span> <span class="kt">ProgramType</span>
</code></pre></div></div>

<p>&#x2026; Well, that was straightforward. Really sorry if that was a little
underwhelming. Because we&#x2019;re just describing <strong>expressions</strong>, we don&#x2019;t need to
store values at all - just knowing the types of the variables that are in
context (think of this as &#x201C;scope&#x201D;) is enough to know whether our expression is
valid!</p>

<blockquote>
  <p><em>As a little aside, this is one of the things I found a bit <strong>weird</strong> about
Idris: because types and values use the same language, we can declare <strong>type
aliases</strong> just as we declare values. We even give them <strong>type signatures</strong>!</em></p>
</blockquote>

<p>Here comes the big reveal. This is the bit that <strong>blew my mind</strong> (which, I can
tell you, was very distressing and inconvenient for poor
<a href="https://www.github.com/LiamGoodacre">Liam</a>, who had just written it). As well
as indexing our expressions by their <strong>type</strong>, we can also index them by the
<strong>context</strong> they exist in:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Expression</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">:</span> <span class="kt">Context</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ptype</span> <span class="o">:</span> <span class="kt">ProgramType</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>

  <span class="kt">Abstraction</span>
     <span class="o">:</span> <span class="p">(</span><span class="n">param</span> <span class="o">:</span> <span class="kt">ProgramType</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">body</span>  <span class="o">:</span> <span class="kt">Expression</span> <span class="p">(</span><span class="n">param</span> <span class="o">::</span> <span class="n">ctx</span><span class="p">)</span> <span class="n">ptype</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="n">param</span> <span class="n">ptype</span><span class="p">)</span>

  <span class="kt">Application</span>
     <span class="o">:</span> <span class="p">(</span><span class="n">func</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="n">i</span> <span class="n">o</span><span class="p">))</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">arg</span>  <span class="o">:</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">i</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">o</span>

  <span class="kt">Variable</span> <span class="c1">-- One more minute...</span>
</code></pre></div></div>

<blockquote>
  <p><em>For the benefit of mobile users, these names have been abbreviated to stop
line wrapping. If you would prefer a more verbose format, <a href="https://github.com/i-am-tom/LICK/blob/master/src/LICK/Expr.idr">the code for this
post</a> uses
long-hand names.</em></p>
</blockquote>

<p><strong>Wow</strong>! This is where we start to see the power of Idris. We now start by
saying that <code class="language-plaintext highlighter-rouge">Expression</code> is a type indexed by a <code class="language-plaintext highlighter-rouge">Context</code> and a <code class="language-plaintext highlighter-rouge">ProgramType</code>,
<em>but</em> we also give that <code class="language-plaintext highlighter-rouge">Context</code> a name - <code class="language-plaintext highlighter-rouge">ctx</code> - so we can use it later!</p>

<p>An <code class="language-plaintext highlighter-rouge">Abstraction</code> is made up of some <code class="language-plaintext highlighter-rouge">ProgramType</code> to represent the type of the
input, and an <code class="language-plaintext highlighter-rouge">Expression</code> of some type to represent the output. What&#x2019;s <em>new</em>
here, however, is that <code class="language-plaintext highlighter-rouge">body</code>&#x2019;s context must be the same as the output, but
with a new variable introduced which <strong>matches</strong> the given <strong>parameter type</strong>!
We are saying, <em>&#x201C;within an <code class="language-plaintext highlighter-rouge">Abstraction</code> body, there is one more variable
available: the parameter&#x201D;</em>. Because the output type <em>doesn&#x2019;t</em> contain that
extra variable, we are completely encapsulating it within the body expression.
We are saying that <em>in the type</em>. I can&#x2019;t tell you how <strong>excited</strong> this makes
me.</p>

<p><code class="language-plaintext highlighter-rouge">Application</code> is actually&#x2026; pretty much the same as it was before. All our
<code class="language-plaintext highlighter-rouge">Context</code> is saying here is that they must exist within the <em>same</em> context,
which is&#x2026; well, what you&#x2019;d expect. The point here is that we&#x2019;re still
<em>carrying</em> the context in the type so we can use it for <code class="language-plaintext highlighter-rouge">Abstraction</code> and
<code class="language-plaintext highlighter-rouge">Variable</code>! Speaking of <code class="language-plaintext highlighter-rouge">Variable</code>&#x2026; where <em>is</em> it?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Variable</span>
   <span class="o">:</span> <span class="p">(</span><span class="n">ref</span> <span class="o">:</span> <span class="kt">Elem</span> <span class="n">ptype</span> <span class="n">ctx</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Expression</span> <span class="n">ctx</span> <span class="n">ptype</span>
</code></pre></div></div>

<p>This, for me, is the most <strong>beautiful</strong> part of all. Now, instead of taking a
<em>number</em> to represent a De Bruijn index, we take an <code class="language-plaintext highlighter-rouge">Elem</code>. We can see that
this maps quite happily:</p>

<table>
  <thead>
    <tr>
      <th>De Bruijn</th>
      <th><code class="language-plaintext highlighter-rouge">Elem</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">Here</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">There Here</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">There (There Here)</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">There (There (There Here))</code></td>
    </tr>
  </tbody>
</table>

<p>&#x2026; Well, you get the picture. The <em>point</em> is that, in order to construct a
<code class="language-plaintext highlighter-rouge">Variable</code> expression, we have to <em>prove</em> that the variable is <strong>in the
context</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">good</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="kt">PInt</span> <span class="kt">PInt</span><span class="p">)</span>
<span class="n">good</span> <span class="o">=</span> <span class="kt">Abstraction</span> <span class="kt">PInt</span> <span class="p">(</span><span class="kt">Variable</span> <span class="kt">Here</span><span class="p">)</span>
</code></pre></div></div>

<p>This is the <strong>identity</strong> function for <code class="language-plaintext highlighter-rouge">PInt</code>: create a function abstraction
with a <code class="language-plaintext highlighter-rouge">PInt</code>-type parameter, and then return the last-introduced variable!
What if we tried to write this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bad</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">PFunction</span> <span class="kt">PInt</span> <span class="kt">PInt</span><span class="p">)</span>
<span class="n">bad</span> <span class="o">=</span> <span class="kt">Abstraction</span> <span class="kt">PInt</span> <span class="p">(</span><span class="kt">Variable</span> <span class="p">(</span><span class="kt">There</span> <span class="kt">Here</span><span class="p">))</span>
</code></pre></div></div>

<p>Now, we&#x2019;re saying, <em>&#x201C;Get me the last-but-one-introduced variable&#x201D;</em>, but our
context is <strong>empty</strong> - this variable <strong>doesn&#x2019;t exist</strong>! Just when we think all
hope is lost, up pops a compiler error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>When checking right hand side of second with expected type
        Expression [] (PFunction PInt PInt)

When checking argument later to constructor Data.List.There:
        Type mismatch between
                Elem x (x :: xs) (Type of Here)
        and
                Elem PInt [] (Expected type)

        Specifically:
                Type mismatch between
                        PInt :: xs
                and
                        []
</code></pre></div></div>

<p>This is an <strong>actual compiler error</strong> telling us exactly that: the context was
empty, but we&#x2019;ve tried to use a proof that <code class="language-plaintext highlighter-rouge">PInt</code> is in there! Because Idris
<em>wants</em> to see <code class="language-plaintext highlighter-rouge">Elem PInt (x :: xs)</code>, but actually sees <code class="language-plaintext highlighter-rouge">Elem PInt []</code>, it
knows that there has been a problem. We are now in a situation where we
<strong>cannot</strong> write <strong>invalid expressions</strong> if we want our code to compile.
Because we&#x2019;ve indexed our type by both the <strong>program type</strong> and <strong>context</strong> of
the expression, and used a <strong>GADT</strong> to constrain them, we know that they will
always be what we expect! We can now write what we&#x2019;ve always wanted to write:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eval</span> <span class="o">:</span> <span class="kt">Expression</span> <span class="o">-&gt;</span> <span class="kt">Expression</span>
</code></pre></div></div>

<p><em>&#x2026; but we&#x2019;ll save that for next time!</em></p>

<hr>

<p>This has been&#x2026; a <strong>lot of information</strong>. A lot of information <strong>very
quickly</strong>, but hopefully not <em>too</em> quickly. In any case, I&#x2019;m sorry if this one
takes <strong>a couple readthroughs</strong>. Idris is a very different beast to Elm,
PureScript, and even Haskell: the ways that you can interact between types and
values are strange and unfamiliar, but we&#x2019;re starting to see <em>why</em> this
newfound power is helpful. With the aid of indexed types and GADTs, we can
produce types that simply <strong>don&#x2019;t</strong> allow for <strong>invalid values</strong>. We have, with
these features, made <strong>illegal states unrepresentable</strong>.  This is also what we
call <strong>correctness by construction</strong>: <em>if I can build a value of type
<code class="language-plaintext highlighter-rouge">Expression</code>, it must <strong>be valid</strong></em>.</p>

<p>If I&#x2019;ve rushed through anything, or something seems suspicious, don&#x2019;t hesitate
to <a href="https://www.twitter.com/am_i_tom">send me a tweet</a> or leave an issue on
<a href="https://www.github.com/i-am-tom/i-am-tom.github.io">this website&#x2019;s
repository</a>! As always,
there is <a href="https://www.github.com/i-am-tom/LICK">code for this article</a>, all of
which can be found within <code class="language-plaintext highlighter-rouge">Expr.idr</code> and <code class="language-plaintext highlighter-rouge">ProgramType.idr</code>, and I encourage you
to play around with it!</p>

<p>Otherwise, have fun, and I&#x2019;ll see you next time!</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Dependable Types 1: Full-ST&#x3BB;C Development</h1>
  <span class="post-date">09 Jan 2018</span>
  <p><strong>Hello again!</strong> Been a while, right? Sorry for being AWOL the best part of six
months; I got my <em>dream job</em> writing <strong>Haskell</strong> and <strong>PureScript</strong> with some
brilliant minds over at <a href="https://www.habito.com">Habito</a>, and I&#x2019;ve had a lot to
learn! Anyway, one such mind is <a href="https://www.github.com/LiamGoodacre">Liam</a>,
(who&#x2019;ll be a familiar face to anyone getting stuck in with PureScript), and we
have been spending our lunch times on various little projects. So, I thought
it&#x2019;d be cool to share one of these projects with you!</p>

<blockquote>
  <p><em><strong>Spoiler</strong>: the project we&#x2019;ll be going through is up on GitHub, and you can
<a href="https://github.com/i-am-tom/LICK">download the code for this series</a> if you
want to play about with it. Head over to <a href="https://www.idris-lang.org/">the Idris
site</a> if you need any help getting set up.</em></p>
</blockquote>

<p>This &#x201C;series&#x201D; is probably going to end up as four-or-five posts, easing into
GADTs, dependent types, and beyond, so <strong>buckle up</strong>! Before we get into that,
though, let&#x2019;s make sure we&#x2019;re all on the <strong>same page</strong>, and have a quick
refresher on the lambda calculus. <em>If you&#x2019;re already familiar with the lambda
calculus (untyped and simply-typed), this post isn&#x2019;t going to be super
interesting for you, but I&#x2019;ll hopefully see you later on!</em></p>

<h2 id="the-untyped-lambda-calculus">The Untyped Lambda Calculus</h2>

<p>The lambda calculus is a <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete
language</a> made up of only
<strong>3</strong> constructs: <strong>variables</strong>, <strong>abstractions</strong>, and <strong>applications</strong>. First,
a cheat sheet:</p>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>&#x3BB;</th>
      <th>Haskell</th>
      <th>JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Variable</td>
      <td><code class="language-plaintext highlighter-rouge">x</code></td>
      <td><code class="language-plaintext highlighter-rouge">x</code></td>
      <td><code class="language-plaintext highlighter-rouge">x</code></td>
    </tr>
    <tr>
      <td>Abstraction</td>
      <td><code class="language-plaintext highlighter-rouge">&#x3BB;x. M</code></td>
      <td><code class="language-plaintext highlighter-rouge">\x -&gt; M</code></td>
      <td><code class="language-plaintext highlighter-rouge">x =&gt; M</code></td>
    </tr>
    <tr>
      <td>Application</td>
      <td><code class="language-plaintext highlighter-rouge">M N</code></td>
      <td><code class="language-plaintext highlighter-rouge">M N</code></td>
      <td><code class="language-plaintext highlighter-rouge">M(N)</code></td>
    </tr>
  </tbody>
</table>

<p>That&#x2019;s it! I&#x2019;ve included the examples in Haskell and JavaScript syntax, too, so
hopefully one of those is familiar to you. Let&#x2019;s go through these in a little
more detail:</p>

<ul>
  <li>
    <p><strong>Application</strong>. Given some expression <code class="language-plaintext highlighter-rouge">M</code> that evaluates to a function, and
some expression <code class="language-plaintext highlighter-rouge">N</code> that evaluates to a value, apply <code class="language-plaintext highlighter-rouge">N</code> to <code class="language-plaintext highlighter-rouge">M</code> to get some
result.</p>
  </li>
  <li>
    <p><strong>Abstraction</strong>. We can define a function that takes an argument, <code class="language-plaintext highlighter-rouge">x</code>, and
returns the result of running <code class="language-plaintext highlighter-rouge">M</code>. <code class="language-plaintext highlighter-rouge">M</code> can be an expression that refers to
<code class="language-plaintext highlighter-rouge">x</code>, just as functions in any other language can use the value we provide.</p>
  </li>
  <li>
    <p><strong>Variable</strong>. This is how we refer to variables introduced in abstractions.
We can&#x2019;t talk about variables that haven&#x2019;t been introduced (think of these as
<strong>undefined variables</strong> in other languages), so every variable must refer to
an argument supplied in an abstraction.</p>
  </li>
</ul>

<p>Hopefully, that made some sense. Just in case, though, let&#x2019;s run through a few
examples of some functions written using our calculus.</p>

<h3 id="id"><code class="language-plaintext highlighter-rouge">id</code></h3>

<table>
  <tbody>
    <tr>
      <td>&#x3BB;</td>
      <td><code class="language-plaintext highlighter-rouge">&#x3BB;x.x</code></td>
    </tr>
    <tr>
      <td>Haskell</td>
      <td><code class="language-plaintext highlighter-rouge">\x -&gt; x</code></td>
    </tr>
    <tr>
      <td>JavaScript</td>
      <td><code class="language-plaintext highlighter-rouge">x =&gt; x</code></td>
    </tr>
  </tbody>
</table>

<p>Probably the simplest program we could write, <code class="language-plaintext highlighter-rouge">id</code> just takes the argument we
give it and hands it back to us. We have an abstraction, <code class="language-plaintext highlighter-rouge">&#x3BB;x.__</code>, with a
variable reference, <code class="language-plaintext highlighter-rouge">x</code>, inside.</p>

<h3 id="const"><code class="language-plaintext highlighter-rouge">const</code></h3>

<table>
  <tbody>
    <tr>
      <td>&#x3BB;</td>
      <td><code class="language-plaintext highlighter-rouge">&#x3BB;x.(&#x3BB;y.x)</code> or just <code class="language-plaintext highlighter-rouge">&#x3BB;x.&#x3BB;y.x</code></td>
    </tr>
    <tr>
      <td>Haskell</td>
      <td><code class="language-plaintext highlighter-rouge">\x -&gt; \y -&gt; x</code></td>
    </tr>
    <tr>
      <td>JavaScript</td>
      <td><code class="language-plaintext highlighter-rouge">x =&gt; y =&gt; x</code></td>
    </tr>
  </tbody>
</table>

<p>Here, we take two arguments, and just return the first one (effectively
ignoring the second). Nothing too complicated, and still looks a lot like the
languages we&#x2019;re familiar with. Notice that, when we want multiple arguments, we
<strong>nest abstractions</strong> and get the arguments once at a time.</p>

<h3 id="flip"><code class="language-plaintext highlighter-rouge">flip</code></h3>

<table>
  <tbody>
    <tr>
      <td>&#x3BB;</td>
      <td><code class="language-plaintext highlighter-rouge">&#x3BB;f.&#x3BB;y.&#x3BB;x.fxy</code></td>
    </tr>
    <tr>
      <td>Haskell</td>
      <td><code class="language-plaintext highlighter-rouge">\f -&gt; \y -&gt; \x -&gt; f x y</code></td>
    </tr>
    <tr>
      <td>JavaScript</td>
      <td><code class="language-plaintext highlighter-rouge">f =&gt; y =&gt; x =&gt; f (x) (y)</code></td>
    </tr>
  </tbody>
</table>

<p>This time, we take a function and two arguments, but apply the arguments in the
opposite order. More <strong>nesting</strong>, but still hopefully not doing anything too
unfamiliar!</p>

<hr>

<p>Hopefully, this gives us some idea about how this language works, and how we&#x2019;d
use these three constructs together to build up programs. There&#x2019;s one last
thing I wanted to talk about in this post, though: <strong>De Bruijn Indices</strong>.</p>

<p>Our syntax is great and all, but there is room for error. We could give two
abstraction parameters the <strong>same name</strong>, which would add confusion, especially
when we come to <strong>substitution</strong> in later posts. Ideally, we want a way to
refer to abstraction parameters <strong>unambiguously</strong>, and that&#x2019;s where our man
<a href="https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn">Nicolaas</a> comes in.
In every abstraction, a new variable is introduced. De Bruijn indices count the
number of nested abstractions between a variable&#x2019;s <strong>introduction</strong> and its
<strong>use</strong>.</p>

<p>Let&#x2019;s start with <code class="language-plaintext highlighter-rouge">id</code>, which is <code class="language-plaintext highlighter-rouge">&#x3BB;x.x</code>. This variable is used immediately
inside the abstraction that introduces it, so we can rewrite this as <code class="language-plaintext highlighter-rouge">&#x3BB;1</code>. We
read this as, <em>&#x201C;Return the variable introduced in the latest abstraction&#x201D;</em>.</p>

<p>What about <code class="language-plaintext highlighter-rouge">const</code>? Well, with <code class="language-plaintext highlighter-rouge">&#x3BB;x.&#x3BB;y.x</code>, <code class="language-plaintext highlighter-rouge">x</code> is again the variable in use, but
this time, there is a new variable introduced between the <code class="language-plaintext highlighter-rouge">x</code> and its original
mention. Because of this, we use <code class="language-plaintext highlighter-rouge">2</code> to mean, <em>&#x201C;The variable from the
last-but-one abstraction&#x201D;</em>, and hence rewrite <code class="language-plaintext highlighter-rouge">const</code> as <code class="language-plaintext highlighter-rouge">&#x3BB;&#x3BB;2</code>.</p>

<p>As a last example, we can rewrite <code class="language-plaintext highlighter-rouge">flip</code> as <code class="language-plaintext highlighter-rouge">&#x3BB;&#x3BB;&#x3BB;312</code>. This is because we apply
the <strong>last-but-two variable</strong>, <code class="language-plaintext highlighter-rouge">f</code>, to the <strong>last variable</strong>, <code class="language-plaintext highlighter-rouge">x</code>, and then
apply the result to the <strong>last-but-one</strong> variable, <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p><em>Confusing</em>, right? Don&#x2019;t worry: I promise <strong>there&#x2019;s a point</strong> to this. When we
come to building the <strong>data type</strong> for lambda calculus expressions, using a
form of De Bruijn indices will make it much easier for us to <strong>guarantee
correctness</strong>.  It&#x2019;s all <em>very</em> exciting. If you want a little exercise to try
out, see if you can encode the following with De Bruijn indices:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">&#x3BB;f.&#x3BB;g.&#x3BB;x.&#x3BB;y.f(gx)(gy)</code></p>
</blockquote>

<p>It&#x2019;s a bit of a tricky one, but hopefully manageable. If you&#x2019;re curious, this
function is called <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Function.html#v:on"><code class="language-plaintext highlighter-rouge">on</code> in Haskell&#x2019;s
<code class="language-plaintext highlighter-rouge">Data.Function</code></a>,
and is useful for all sorts of things!</p>

<hr>

<h2 id="all-together-now">All Together Now</h2>

<p>This has been a bit of a whirlwind tour of lambda calculus, so I hope I haven&#x2019;t
frightened anyone off. To be honest with you, it feels rather odd to be writing
again! Anyway, there are <strong>plenty</strong> of resources for learning more if you&#x2019;re
interested, but I&#x2019;ll shine a special spotlight on Steven Syrek&#x2019;s <a href="https://www.youtube.com/watch?v=c_ReqkiyCXo">Lambda
Calculus for People Who Can&#x2019;t Be Bothered to Learn
It</a>, which will take you from
first principles right up to <a href="https://github.com/sjsyrek/presentations/blob/master/lambda-calculus/lambda.js">the purest evil you&#x2019;ve ever seen in
JavaScript</a>.</p>

<p>One last note: the Idris project we&#x2019;ll be going through is an implementation of
the <strong>simply-typed lambda calculus</strong>. What&#x2019;s the difference between that and
what we&#x2019;ve already seen? Simply that the variables, applications, and
abstractions <strong>all have types</strong> (like <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Int -&gt; Int</code> - that sort of
thing). In practice, this is the same thing as any other programming language
with a simple type system, and we&#x2019;ll track these through our program to make
sure that non-functions don&#x2019;t end up being used as functions, or to avoid
<strong>invalid parameter</strong> usage.</p>

<p>Anyway, that&#x2019;s all for now! It&#x2019;s been lovely to talk to you again, and I hope
I&#x2019;ll be seeing you some time next week. Until then, take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 19: Semigroupoid and Category</h1>
  <span class="post-date">10 Jul 2017</span>
  <p><strong>It&#x2019;s not goodbye</strong>, Fantasists. We&#x2019;ll have other projects, new memories, more chance encounters. Let&#x2019;s end on a high: talking about the humble <code class="language-plaintext highlighter-rouge">Category</code>, and how we&#x2019;ve been learning this since the beginning. While it may not be the most <em>immediately useful</em> structure, it&#x2019;s a <strong>gem for the curious</strong>.</p>

<p>Before we go any further, let&#x2019;s get the <strong>methods</strong> and <strong>laws</strong> on the table. A <code class="language-plaintext highlighter-rouge">Semigroupoid</code> has one method, called <code class="language-plaintext highlighter-rouge">compose</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compose</span> <span class="o">::</span> <span class="kt">Semigroupoid</span> <span class="n">c</span>
        <span class="o">=&gt;</span> <span class="n">c</span> <span class="n">i</span> <span class="n">j</span>
        <span class="o">~&gt;</span> <span class="n">c</span> <span class="n">j</span> <span class="n">k</span>
        <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">i</span> <span class="n">k</span>
</code></pre></div></div>

<p>There&#x2019;s also one <strong>law</strong>, which is going to look <em>boringly</em> familiar:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Associativity..</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="o">===</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">compose</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">Category</code> is a <code class="language-plaintext highlighter-rouge">Semigroupoid</code> with <strong>one new method</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="o">::</span> <span class="kt">Category</span> <span class="n">c</span> <span class="o">=&gt;</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div></div>

<p>Now, if you&#x2019;ve been following the series, there are no prizes for guessing the two laws that come with this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Left and right identity!</span>
<span class="nx">a</span> <span class="o">===</span> <span class="nx">C</span><span class="p">.</span><span class="nx">id</span><span class="p">().</span><span class="nx">compose</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">id</span><span class="p">())</span>
</code></pre></div></div>

<p>Yep, it&#x2019;s another <code class="language-plaintext highlighter-rouge">Monoid</code>-looking structure. Let&#x2019;s all <strong>pretend to be surprised</strong>.</p>

<hr>

<p><em>Now</em>, there&#x2019;s a reason to get excited about these things. You may not <strong>directly</strong> interact with them every day, but they&#x2019;re <em>everywhere</em> underneath the surface:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">compose</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>
</code></pre></div></div>

<p>Yep. Under function <strong>composition</strong>, our functions form a <code class="language-plaintext highlighter-rouge">Category</code>! Do notice that <code class="language-plaintext highlighter-rouge">Function#compose</code> is defined the exact same way as <code class="language-plaintext highlighter-rouge">Function#map</code>, too. Of course, this might be a bit easier to introduce to your codebase than <code class="language-plaintext highlighter-rouge">Function#map</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Much more colleague-friendly?</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span>
  <span class="nx">readInput</span>
  <span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">clean</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">capitalise</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">etCetera</span><span class="p">)</span>
</code></pre></div></div>

<p>We can think of <code class="language-plaintext highlighter-rouge">s a b</code> (for some <code class="language-plaintext highlighter-rouge">Semigroupoid s</code>) as &#x201C;a relationship from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>&#x201D; (the set of which, in <strong>fancy talk</strong>, are called <strong>morphisms</strong>), and <code class="language-plaintext highlighter-rouge">Category</code> types as having &#x201C;an identity relationship&#x201D;. When we did <a href="/2017/06/05/fantas-eel-and-specification-15/">the deep dive with <code class="language-plaintext highlighter-rouge">Monad</code></a>, we actually looked at another <code class="language-plaintext highlighter-rouge">Category</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- We need a TypeRep for M to do `id`.</span>
<span class="c1">//- Note that, for a `Chain` type, we could</span>
<span class="c1">//- only make a `Semigroupoid`, not a</span>
<span class="c1">//- `Category`!</span>
<span class="kd">const</span> <span class="nx">MCompose</span> <span class="o">=</span> <span class="nx">M</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//+ type MCompose m a b = a -&gt; m b</span>
  <span class="kd">const</span> <span class="nx">MCompose_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">MCompose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="c1">//+ compose :: Chain m</span>
  <span class="c1">//+         =&gt; MCompose m a b</span>
  <span class="c1">//+         ~&gt; MCompose m b c</span>
  <span class="c1">//+         -&gt; MCompose m a c</span>
  <span class="nx">MCompose_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">compose</span> <span class="o">=</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="c1">//+ id :: Monad m =&gt; () -&gt; MCompose m a a</span>
  <span class="nx">MCompose_</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">MCompose_</span><span class="p">(</span><span class="nx">M</span><span class="p">.</span><span class="k">of</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">MCompose_</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that we originally wrote a <code class="language-plaintext highlighter-rouge">Monoid</code> for operations <code class="language-plaintext highlighter-rouge">a -&gt; m a</code>. With a <code class="language-plaintext highlighter-rouge">Category</code>, we can talk about operations <code class="language-plaintext highlighter-rouge">a -&gt; m b</code>, and we have much more <strong>freedom</strong>. Symmetrically, <a href="/2017/06/19/fantas-eel-and-specification-17/">our <code class="language-plaintext highlighter-rouge">Comonad</code> friends</a> give us an almost identical <code class="language-plaintext highlighter-rouge">Category</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Extend for Semigroupoid, Comonad for</span>
<span class="c1">//- Category!</span>
<span class="c1">//+ type WCompose w a b = w a -&gt; b</span>
<span class="kd">const</span> <span class="nx">WCompose</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">WCompose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">//+ compose :: Extend w</span>
<span class="c1">//+         =&gt; (w a -&gt; b)</span>
<span class="c1">//+         ~&gt; (w b -&gt; c)</span>
<span class="c1">//+         -&gt; (w a -&gt; c)</span>
<span class="nx">WCompose</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">compose</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">extend</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

<span class="c1">//+ id :: Comonad w =&gt; () -&gt; WCompose w a a</span>
<span class="nx">WCompose</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="nx">WCompose</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">extract</span><span class="p">())</span>
</code></pre></div></div>

<p>Why limit ourselves? We have <strong>composition</strong>! Let&#x2019;s turn <a href="/2017/04/17/fantas-eel-and-specification-9/">the <code class="language-plaintext highlighter-rouge">Applicative</code></a>&#x2019;s composition into a <code class="language-plaintext highlighter-rouge">Category</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ Apply for Semigroupoid, Applicative for</span>
<span class="c1">//+ Category!</span>

<span class="kd">const</span> <span class="nx">ApCompose</span> <span class="o">=</span> <span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">C</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//+ type ApCompose f c a b = f (c a b)</span>
  <span class="kd">const</span> <span class="nx">ApCompose_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">ApCompose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="c1">//+ compose :: Apply f</span>
  <span class="c1">//+         =&gt; Semigroupoid s</span>
  <span class="c1">//+         =&gt; f s a b</span>
  <span class="c1">//+         ~&gt; f s b c</span>
  <span class="c1">//+         -&gt; f s a c</span>
  <span class="nx">ApCompose_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">compose</span> <span class="o">=</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
        <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">y</span><span class="p">)))</span>
    <span class="p">}</span>

  <span class="c1">//+ id :: Applicative f</span>
  <span class="c1">//+    =&gt; Category s</span>
  <span class="c1">//+    =&gt; () -&gt; f s a a</span>
  <span class="nx">ApCompose_</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">id</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The really <strong>neat</strong> thing here is that, instead of limiting ourselves to the <code class="language-plaintext highlighter-rouge">Category</code> of <em>functions</em> within <code class="language-plaintext highlighter-rouge">Applicative</code> context, we&#x2019;ve generalised <code class="language-plaintext highlighter-rouge">Function</code> to <code class="language-plaintext highlighter-rouge">Category</code>! It&#x2019;s all getting a bit <strong>abstract</strong> and <strong>scary</strong>, right? <strong>Don&#x2019;t panic</strong>.</p>

<hr>

<p>With the <strong>helpful exception</strong> of <code class="language-plaintext highlighter-rouge">Function</code>, these examples may all seem a bit impractical. <em>Granted</em>, you might find that <code class="language-plaintext highlighter-rouge">MCompose#compose</code> gives you a nice, declarative way to chain together <strong>monadic actions</strong>, or something to that effect, but this largely seems a bit too&#x2026; well, <strong>abstract</strong>!</p>

<p>While this <em>may</em> not be the one you use every day, the <code class="language-plaintext highlighter-rouge">Semigroupoid</code> and <code class="language-plaintext highlighter-rouge">Category</code> structures form a <em>very</em> important idea. We hinted at this earlier: <em><code class="language-plaintext highlighter-rouge">Category</code> is like a <code class="language-plaintext highlighter-rouge">Monoid</code> with <strong>more freedom</strong></em>. Well, if everything we&#x2019;ve seen ended up looking like <code class="language-plaintext highlighter-rouge">Semigroup</code> or <code class="language-plaintext highlighter-rouge">Monoid</code>&#x2026; effectively, the <strong>base concept</strong> been <code class="language-plaintext highlighter-rouge">Category</code> all along!</p>

<blockquote>
  <p>I had originally wanted to show <code class="language-plaintext highlighter-rouge">Monoid</code> in terms of <code class="language-plaintext highlighter-rouge">Category</code>. Let&#x2019;s just say the <strong>page of required declarations</strong> compiled with the <strong>help of three other people</strong> made me think that, if <em>I</em> couldn&#x2019;t understand it, I probably shouldn&#x2019;t put it here!</p>
</blockquote>

<p>It&#x2019;s not <em>crucial</em> that we understand why. <a href="https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/">Discussion around categories</a> leads me to <strong>all sorts</strong> of headaches, and to no avail. What is important is that I make a <strong>small confession</strong>&#x2026;</p>

<p><em>This <strong>entire</strong> series has been about a branch of maths called <strong>Category Theory</strong>: the theory of <strong>categories</strong></em>.</p>

<p><strong>Blam</strong>! Here in programmer land, using our shiny new structures to write <strong>fault-tolerant database systems</strong> and  <strong>reactive event streams</strong>, we thought we were safe from maths&#x2026; but <strong>no</strong>! The whole <strong>purpose</strong> of Fantasy Land is to utilise concepts from category theory that help us to write <strong>safer code</strong>. &#x201C;Was <code class="language-plaintext highlighter-rouge">Functor</code> maths?&#x201D; <em>I&#x2019;m afraid so</em>. &#x201C;Surely our <code class="language-plaintext highlighter-rouge">Semigroup</code> was innocent, though?&#x201D; <em>I wish I could tell you so</em>. &#x201C;Not <code class="language-plaintext highlighter-rouge">Alt</code> though, right? &#x2026; Right?&#x201D; <em>All category theory. Please stop asking.</em></p>

<p>Perhaps you&#x2019;ll never need to think about <code class="language-plaintext highlighter-rouge">Category</code> again, and that&#x2019;s <strong>fine</strong>. Function composition is more than valuable enough to justify its existence. <em>However</em>, sooner or later, if you continue down this <strong>rabbit hole</strong>, you&#x2019;ll start asking <strong>why</strong> and <strong>how</strong>, and I&#x2019;m sure you&#x2019;ll find your way back here&#x2026;</p>

<p>Simply, there&#x2019;s really not much (immediately practical) to say about <code class="language-plaintext highlighter-rouge">Category</code> and <code class="language-plaintext highlighter-rouge">Semigroupoid</code> at this level of generality, but it&#x2019;s a neat little concept, and I thought it was nice to put a name to the pattern we&#x2019;ve been seeing <strong>all the time</strong>! Next time you define a weird type of <strong>relationship</strong> (perhaps one involving <code class="language-plaintext highlighter-rouge">Monad</code>?), give a thought to the humble <code class="language-plaintext highlighter-rouge">Category</code> we&#x2019;ve just seen, and see whether you can simplify your code with a more specific <code class="language-plaintext highlighter-rouge">compose</code> implementation.</p>

<hr>

<p>The keen-eyed among you will have noticed that this is <strong>the last Fantasy Land structure</strong>, and that we&#x2019;ve really come to <strong>the end of the series</strong>. Well&#x2026; <strong>don&#x2019;t panic</strong>! I have <strong>one more</strong> article to publish before we call this whole thing a day. Call it the <em>encore</em> that no one wanted.</p>

<p>On that note, next time, we&#x2019;ll be talking about <strong>bringing concepts together</strong> to build some cool little projects, and where you can go next! Otherwise, <strong>thank you <em>so much</em></strong> for reading through <strong>at least</strong> 19 pages of my mindless rambling, and I hope that it has been useful in some small way.</p>

<p>Now, <strong>write beautiful JavaScript</strong>.</p>

<p>&#x2665; &#x2665; &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 18: Bifunctor and Profunctor</h1>
  <span class="post-date">26 Jun 2017</span>
  <p><strong>The worst is behind us</strong>. We&#x2019;ve <a href="/2017/06/05/fantas-eel-and-specification-15/">mastered the <code class="language-plaintext highlighter-rouge">Monad</code></a>, <a href="/2017/06/19/fantas-eel-and-specification-17/">conquered the <code class="language-plaintext highlighter-rouge">Comonad</code></a>, and <a href="/2017/03/13/fantas-eel-and-specification-4/">surmounted the <code class="language-plaintext highlighter-rouge">Semigroup</code></a>. Consider these last two posts to be a <strong>cool-down</strong>, because <strong>the end is in sight</strong>. Today, to enjoy our first week of rest, we&#x2019;re going to revise <strong>functors</strong>.
A number of times, we&#x2019;ve seen types with <strong>two</strong> inner types: <code class="language-plaintext highlighter-rouge">Either</code>, <code class="language-plaintext highlighter-rouge">Pair</code>, <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">Function</code>, and so on. However, in all cases, we&#x2019;ve <strong>only</strong> been able to <code class="language-plaintext highlighter-rouge">map</code> over the <strong>right-hand</strong> side. Well, Fantasists, the reason has something to do with a concept called <strong>kinds</strong> that we won&#x2019;t go into. Instead, let&#x2019;s look at <strong>solutions</strong>.</p>

<p>We&#x2019;ll take a type like <code class="language-plaintext highlighter-rouge">Either</code> or <code class="language-plaintext highlighter-rouge">Pair</code>. These types have <strong>two</strong> inner types (<em>left</em> and <em>right</em>!) that we could <code class="language-plaintext highlighter-rouge">map</code> over. The <code class="language-plaintext highlighter-rouge">Bifunctor</code> class allows us to deal with both:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bimap</span> <span class="o">::</span> <span class="kt">Bifunctor</span> <span class="n">f</span>
      <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span>
      <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span>
      <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">d</span>
</code></pre></div></div>

<p>It&#x2019;s pretty much <strong>exactly like <code class="language-plaintext highlighter-rouge">Functor</code></strong>, except we are mapping <strong>two at a time</strong>! What does this look like in <em>actual</em> code?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Either</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bimap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">Left</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
      <span class="na">Right</span><span class="p">:</span> <span class="nx">g</span>
    <span class="p">})</span>
  <span class="p">}</span>

<span class="nx">Pair</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bimap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">),</span>
                <span class="nx">g</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">))</span>
  <span class="p">}</span>

<span class="nx">Task</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bimap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">rej</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">e</span><span class="p">)),</span>
                <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">e</span><span class="p">))))</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Hopefully, no huge surprises. We apply the <strong>left function</strong> to any mention of the <strong>left value</strong>, and the same for the right. Even the laws are just <strong>doubled-up</strong> versions of the <code class="language-plaintext highlighter-rouge">Functor</code> laws:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For some functor U:</span>

<span class="c1">// Identity</span>
<span class="nx">U</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">U</span>

<span class="c1">// Composition</span>
<span class="nx">U</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="o">===</span>
  <span class="nx">U</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>

<span class="c1">// For some bifunctor C:</span>

<span class="c1">// Identity</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">bimap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">C</span>

<span class="c1">// Composition</span>
<span class="nx">C</span><span class="p">.</span><span class="nx">bimap</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">).</span><span class="nx">bimap</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">===</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">bimap</span><span class="p">(</span><span class="nx">l</span> <span class="o">=&gt;</span> <span class="nx">h</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">l</span><span class="p">)),</span>
          <span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">i</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">r</span><span class="p">)))</span>
</code></pre></div></div>

<p>A lot of brackets, but look closely: the laws are the same, but we have <strong>two independent &#x201C;channels&#x201D;</strong> on the go!</p>

<blockquote>
  <p><em>Fun fact: if you have a <code class="language-plaintext highlighter-rouge">Bifunctor</code> instance for some type <code class="language-plaintext highlighter-rouge">T</code>, you can automatically derive a fully-lawful <code class="language-plaintext highlighter-rouge">Functor</code> instance for <code class="language-plaintext highlighter-rouge">T a</code> with <code class="language-plaintext highlighter-rouge">f =&gt; bimap(x =&gt; x, f)</code>. <strong>Hooray, Free upgrades</strong>!</em></p>
</blockquote>

<p>So, is this useful? <strong>Yes</strong>! Let&#x2019;s look at a neat little example using <code class="language-plaintext highlighter-rouge">Either</code> for a second:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Where everything changes...</span>
<span class="kd">const</span> <span class="nx">login</span> <span class="o">=</span> <span class="nx">user</span> <span class="o">=&gt;</span>
  <span class="nx">isValid</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
                <span class="p">:</span> <span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Boo</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">//- Function map === &quot;piping&quot;.</span>
<span class="c1">//+ failureStream :: String</span>
<span class="c1">//+               -&gt; HTML</span>
<span class="kd">const</span> <span class="nx">failureStream</span> <span class="o">=</span>
  <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">&lt;em&gt;</span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">&lt;/em&gt;</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">//+ successStream :: User</span>
<span class="c1">//+               -&gt; HTML</span>
<span class="kd">const</span> <span class="nx">successStream</span> <span class="o">=</span>
  <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">Hey, </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">&lt;h1&gt;</span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">&lt;/h1&gt;</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">//- We can now pass in our two</span>
<span class="c1">//- possible application flows</span>
<span class="c1">//- using `bimap`!</span>
<span class="nx">login</span><span class="p">(</span><span class="nx">user</span><span class="p">).</span><span class="nx">bimap</span><span class="p">(</span>
  <span class="nx">failureStream</span><span class="p">,</span>
  <span class="nx">successStream</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that this would also work with <code class="language-plaintext highlighter-rouge">Task</code>! We&#x2019;re in a situation where we want to transform a potential success <em>or</em> failure, and <code class="language-plaintext highlighter-rouge">bimap</code> lets us supply both at once. <em>Cool</em>, right? <strong>Straightforward</strong>, too!</p>

<hr>

<p>Now, <code class="language-plaintext highlighter-rouge">Function</code> is a <em>slightly</em> different story. Effectively, we can <code class="language-plaintext highlighter-rouge">contramap</code> over its <strong>left-hand type</strong> (the <strong>input</strong>) and <code class="language-plaintext highlighter-rouge">map</code> over its <strong>right-hand type</strong> (the <strong>output</strong>). It turns out there&#x2019;s a fancy name for this sort of thing, too: <code class="language-plaintext highlighter-rouge">Profunctor</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">promap</span> <span class="o">::</span> <span class="kt">Profunctor</span> <span class="n">p</span>
       <span class="o">=&gt;</span> <span class="n">p</span> <span class="n">b</span> <span class="n">c</span>
       <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span>
       <span class="o">-&gt;</span> <span class="n">p</span> <span class="n">a</span> <span class="n">d</span>
</code></pre></div></div>

<p>You can think of it as adding a <strong>before</strong> and <strong>after</strong> step to some process. Naturally, the laws look like a <strong>mooshmash</strong> of <code class="language-plaintext highlighter-rouge">Contravariant</code> and <code class="language-plaintext highlighter-rouge">Functor</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For some profunctor p:</span>

<span class="c1">// Identity...</span>
<span class="nx">P</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span><span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="o">===</span> <span class="nx">P</span>

<span class="c1">// Composition...</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">promap</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="o">===</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span><span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">a</span><span class="p">)),</span>
           <span class="nx">b</span> <span class="o">=&gt;</span> <span class="nx">h</span><span class="p">(</span><span class="nx">i</span><span class="p">(</span><span class="nx">b</span><span class="p">)))</span>
</code></pre></div></div>

<blockquote>
  <p><em>Guess what? You can build a functor <code class="language-plaintext highlighter-rouge">P a</code> out of any profunctor <code class="language-plaintext highlighter-rouge">P</code>: <code class="language-plaintext highlighter-rouge">f =&gt; promap(x =&gt; x, f)</code> is all it takes. So many <strong>free upgrades</strong>!</em></p>
</blockquote>

<p>The <strong>left-hand</strong> side looks like <code class="language-plaintext highlighter-rouge">Contravariant</code>, and the <strong>right-hand</strong> side like <code class="language-plaintext highlighter-rouge">Functor</code>. Of course, we&#x2019;ve seen a <code class="language-plaintext highlighter-rouge">Profunctor</code> already: <strong><code class="language-plaintext highlighter-rouge">Function</code></strong>! However, to give a slightly more <strong>exciting</strong> example, let&#x2019;s look at one of my <strong>favourites</strong>: <code class="language-plaintext highlighter-rouge">Costar</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Fancy wrapping around a specific type</span>
<span class="c1">//- of function: an &quot;f a&quot; to a &quot;b&quot;</span>
<span class="c1">//+ Costar f a b = f a -&gt; b</span>
<span class="kd">const</span> <span class="nx">Costar</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Costar</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">run</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">//- Contramap with the &quot;before&quot; function,</span>
<span class="c1">//- fold, then apply the &quot;after&quot; function.</span>
<span class="c1">//+ promap :: Functor f</span>
<span class="c1">//+        =&gt; Costar f b c</span>
<span class="c1">//+        -&gt; (b -&gt; a, c -&gt; d)</span>
<span class="c1">//+        -&gt; Costar f a d</span>
<span class="nx">Costar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">promap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Costar</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))))</span>
<span class="p">}</span>

<span class="c1">//- Takes a list of ints to the sum</span>
<span class="c1">//+ sum :: Costar Array Int Int</span>
<span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">Costar</span><span class="p">(</span><span class="nx">xs</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">//- Make every element 1, then sum them!</span>
<span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span>

<span class="c1">//- Is the result over 5?</span>
<span class="kd">const</span> <span class="nx">isOk</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">//- Why not both? Is the length over 5?</span>
<span class="kd">const</span> <span class="nx">longEnough</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">promap</span><span class="p">(</span>
  <span class="nx">_</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">// Returns false!</span>
<span class="nx">longEnough</span><span class="p">.</span><span class="nx">run</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Costar</code> allows us to take the idea of <code class="language-plaintext highlighter-rouge">reduce</code> and wrap it in a <code class="language-plaintext highlighter-rouge">Profunctor</code>. We can use <code class="language-plaintext highlighter-rouge">promap</code> to <strong>prepare</strong> different inputs for the reduction <em>and</em> <strong>manipulate</strong> the result. You may have heard of this idea before: <strong>map/reduce</strong>. No matter how <strong>complex</strong> the process, there&#x2019;s a good chance that you can express it in a <code class="language-plaintext highlighter-rouge">Profunctor</code>!</p>

<hr>

<p>These are, of course, <em>very</em> quick overviews of <code class="language-plaintext highlighter-rouge">Bifunctor</code> and <code class="language-plaintext highlighter-rouge">Profunctor</code>. That said, if you&#x2019;re comfortable now with <code class="language-plaintext highlighter-rouge">Functor</code> and you remember the post on <code class="language-plaintext highlighter-rouge">Contravariant</code>, there&#x2019;s <strong>nothing new</strong> to learn! We&#x2019;re really just building on ideas we&#x2019;ve already had. <code class="language-plaintext highlighter-rouge">Bifunctor</code> might seem a little <em>underwhelming</em> now that we&#x2019;ve seen the <strong>power</strong> of <code class="language-plaintext highlighter-rouge">Monad</code> and <code class="language-plaintext highlighter-rouge">Comonad</code>, but it&#x2019;s <em>twice</em> as powerful as <code class="language-plaintext highlighter-rouge">Functor</code>: we can define a flow for <strong>success</strong> and <strong>error</strong>, for <strong>left</strong> and <strong>right</strong>, for&#x2026; well, any <strong>two things</strong>!</p>

<p>As for <code class="language-plaintext highlighter-rouge">Profunctor</code>, it&#x2019;s a pretty massive topic once you start digging. <code class="language-plaintext highlighter-rouge">Costar</code> is the opposite of <code class="language-plaintext highlighter-rouge">Star</code>, which is an <code class="language-plaintext highlighter-rouge">a -&gt; f b</code> function; why not think about how to implement that? Would you need any <strong>special conditions</strong> to make it a <code class="language-plaintext highlighter-rouge">Profunctor</code>?</p>

<p>Take <a href="https://gist.github.com/richdouglasevans/891564c2d13363b46e49187f28a28ae8">the article&#x2019;s gist</a>, and <code class="language-plaintext highlighter-rouge">bimap</code> and <code class="language-plaintext highlighter-rouge">promap</code> until the cows come home, Fantasists, for there is only <strong>one</strong> article left: <code class="language-plaintext highlighter-rouge">Semigroupoid</code> and <code class="language-plaintext highlighter-rouge">Category</code>. Expect <strong>high drama</strong>, <strong>hard maths</strong>, and <strong>herds of monoids</strong>. Well, maybe not the second thing&#x2026;</p>

<p>Until then!</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 15: Monad</h1>
  <span class="post-date">05 Jun 2017</span>
  <p><strong>Today is the day</strong>, Fantasists. We all knew it was coming, but we <em>hoped</em> it wouldn&#x2019;t be so soon. Sure enough, though, <strong>here we are</strong>. We&#x2019;ve battled through <strong>weeks</strong> of structures, and reached the dreaded <code class="language-plaintext highlighter-rouge">Monad</code>. Say your goodbyes to your loved ones, and <strong>let&#x2019;s go</strong>.</p>

<p><em>Ahem.</em></p>

<p><strong>A <code class="language-plaintext highlighter-rouge">Monad</code> is a type that is both a <code class="language-plaintext highlighter-rouge">Chain</code> and an <code class="language-plaintext highlighter-rouge">Applicative</code></strong>. That&#x2019;s&#x2026; well, it, really. We&#x2019;re done here. Next time, we&#x2019;ll be looking at the <strong>new-wave wizardry</strong> of <code class="language-plaintext highlighter-rouge">Extend</code>. Until then, take care!</p>

<p>&#x2665;</p>

<hr>

<p>&#x2026; Right, so maybe we could say a <em>little</em> more, but only if we <em>want</em> to! Honestly, though, the above is enough to get going. We&#x2019;ve seen a few examples of <code class="language-plaintext highlighter-rouge">Semigroup</code>-and-<code class="language-plaintext highlighter-rouge">Monoid</code>-feeling relationships, but let&#x2019;s focus on two in particular:</p>

<p>In <a href="/2017/04/10/fantas-eel-and-specification-8/">the <code class="language-plaintext highlighter-rouge">Apply</code> post</a>, we said that <code class="language-plaintext highlighter-rouge">ap</code> felt a bit <code class="language-plaintext highlighter-rouge">Semigroup</code>-ish. Then, in <a href="/2017/04/17/fantas-eel-and-specification-9/">the <code class="language-plaintext highlighter-rouge">Applicative</code> post</a>, we saw that adding <code class="language-plaintext highlighter-rouge">of</code> gave us something <code class="language-plaintext highlighter-rouge">Monoid</code>-ish.</p>

<p>Later, <a href="/2017/05/15/fantas-eel-and-specification-13/">we looked at <code class="language-plaintext highlighter-rouge">Chain</code></a>, where <code class="language-plaintext highlighter-rouge">chain</code> gave us something like a <code class="language-plaintext highlighter-rouge">Semigroup</code>. <em>So</em>, you&#x2019;re asking, <em>where&#x2019;s the <code class="language-plaintext highlighter-rouge">Monoid</code>?</em> Well, with a <code class="language-plaintext highlighter-rouge">Monad</code>, <code class="language-plaintext highlighter-rouge">of</code> doubles up as the <code class="language-plaintext highlighter-rouge">empty</code> to <strong><code class="language-plaintext highlighter-rouge">Chain</code></strong>&#x2019;s <code class="language-plaintext highlighter-rouge">Semigroup</code>, too!</p>

<p>We&#x2019;re going to go through a pretty <strong>mathematical</strong> definition of <code class="language-plaintext highlighter-rouge">Monad</code> first, so don&#x2019;t be discouraged if it doesn&#x2019;t make sense on the <strong>first few reads</strong>. This is really just <em>background knowledge</em> for the curious; <strong>skip ahead</strong> if you just want to see a <strong>practical</strong> example!</p>

<hr>

<blockquote>
  <p>To skip ahead, <strong>start scrolling</strong>!</p>
</blockquote>

<p>Let&#x2019;s do some <strong>mind-blowing</strong>; it&#x2019;s the <code class="language-plaintext highlighter-rouge">Monad</code> post after all, right? Let&#x2019;s first define two composition functions, <code class="language-plaintext highlighter-rouge">compose</code> and <code class="language-plaintext highlighter-rouge">mcompose</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Regular `compose` - old news!</span>
<span class="c1">//+ compose ::      (b -&gt; c)</span>
<span class="c1">//+         -&gt; (a -&gt; b)</span>
<span class="c1">//+         -&gt;  a   -&gt;    c</span>
<span class="kd">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">g</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">//- `chain`-sequencing `compose`, fancily</span>
<span class="c1">//- known as Kleisli composition - it&apos;s the</span>
<span class="c1">//- K in Ramda&apos;s &quot;composeK&quot;!</span>
<span class="c1">//+ mcompose :: Chain m</span>
<span class="c1">//+          =&gt;        (b -&gt; m c)</span>
<span class="c1">//+          -&gt; (a -&gt; m b)</span>
<span class="c1">//+          -&gt;  a     -&gt;    m c</span>
<span class="kd">const</span> <span class="nx">mcompose</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">g</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div></div>

<p><em>I&#x2019;ve tried to line up the types so it&#x2019;s a bit clearer to see <strong>left-to-right</strong> how this works&#x2026; I hope that it helped in some way!</em></p>

<p><code class="language-plaintext highlighter-rouge">compose</code> says, &#x201C;<em>Do <code class="language-plaintext highlighter-rouge">g</code>, then <code class="language-plaintext highlighter-rouge">f</code></em>&#x201D;. <code class="language-plaintext highlighter-rouge">mcompose</code> says <strong>the same thing</strong>, but does it with some kind of <strong>context</strong> (<em><a href="/2017/03/27/fantas-eel-and-specification-6/">little language extension bubble</a>, remember?</em>). That <code class="language-plaintext highlighter-rouge">m</code> could be <code class="language-plaintext highlighter-rouge">Maybe</code> in the case of two functions that may fail, or <code class="language-plaintext highlighter-rouge">Array</code> in the case of two functions that return multiple values, and so on. What&#x2019;s important is that, to <em>use</em> <code class="language-plaintext highlighter-rouge">mcompose</code>, our <code class="language-plaintext highlighter-rouge">m</code> <strong>must</strong> be a <code class="language-plaintext highlighter-rouge">Chain</code> type.</p>

<p>Now, you can make something very monoid-looking with regular <code class="language-plaintext highlighter-rouge">compose</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Compose</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Compose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">//- Remember, for semigroups:</span>
<span class="c1">//- concat :: Semigroup s =&gt; s -&gt; s -&gt; s</span>
<span class="c1">//- Replace s with (a -&gt; a)...</span>
<span class="c1">//+ concat ::      (a -&gt; a)</span>
<span class="c1">//+        -&gt; (a -&gt; a)</span>
<span class="c1">//+        -&gt;  a   -&gt;    a</span>
<span class="nx">Compose</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Compose</span><span class="p">(</span>
      <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">(</span><span class="nx">that</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">//- We need something that has no effect...</span>
<span class="c1">//- The `id` function!</span>
<span class="c1">//+ empty :: (a -&gt; a)</span>
<span class="nx">Compose</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Compose</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Mind blown yet? <strong>Function composition is a monoid</strong>! The <code class="language-plaintext highlighter-rouge">x =&gt; x</code> function is our <code class="language-plaintext highlighter-rouge">empty</code> (because it doesn&#x2019;t do anything), and composition is <code class="language-plaintext highlighter-rouge">concat</code> (because it combines two functions into a pipeline). See? <strong>Everything is just monoids</strong>. Monoids <em>all</em> the way down.</p>

<blockquote>
  <p>Typically, the <code class="language-plaintext highlighter-rouge">Compose</code> type is used for other things (remember <a href="/2017/05/08/fantas-eel-and-specification-12/">the <code class="language-plaintext highlighter-rouge">Traversable</code> post</a>?), but we&#x2019;re using it here as just a nice, <em>clear</em> name for this example.</p>
</blockquote>

<p>Now, here&#x2019;s the <strong>real wizardry</strong>: can we do the same thing with <code class="language-plaintext highlighter-rouge">mcompose</code>? Well, we could certainly write a <code class="language-plaintext highlighter-rouge">Semigroup</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MCompose</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">MCompose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">//- Just as we did with Compose...</span>
<span class="c1">//+ concat :: Chain m</span>
<span class="c1">//+        =&gt;        (a -&gt; m a)</span>
<span class="c1">//+        -&gt; (a -&gt; m a)</span>
<span class="c1">//+        -&gt;  a     -&gt;    m a</span>
<span class="nx">MCompose</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MCompose</span><span class="p">(</span>
      <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">concat</code> now just does <code class="language-plaintext highlighter-rouge">mcompose</code> instead of <code class="language-plaintext highlighter-rouge">compose</code>, as we expected. If we want an <code class="language-plaintext highlighter-rouge">empty</code>, though, it would need to be an <code class="language-plaintext highlighter-rouge">a -&gt; m a</code> function. Well, <strong>reader mine</strong>, it just so happens that we&#x2019;ve already seen that very function: from <code class="language-plaintext highlighter-rouge">Applicative</code>, the <code class="language-plaintext highlighter-rouge">of</code> function!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- So, we need empty :: (a -&gt; m a)</span>
<span class="c1">//+ empty :: Chain m, Applicative m</span>
<span class="c1">//+       =&gt; (a -&gt; m a)</span>
<span class="nx">MCompose</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="nx">MCompose</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">M</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">// Or just `MCompose(M.of)`!</span>
</code></pre></div></div>

<blockquote>
  <p>Note that, as with lots of interesting <code class="language-plaintext highlighter-rouge">Monoid</code> types, we&#x2019;d need a <code class="language-plaintext highlighter-rouge">TypeRep</code> to build <code class="language-plaintext highlighter-rouge">MCompose</code> to know which <code class="language-plaintext highlighter-rouge">M</code> type we&#x2019;re using.</p>
</blockquote>

<p>To make <code class="language-plaintext highlighter-rouge">MCompose</code> a full <code class="language-plaintext highlighter-rouge">Monoid</code>, we need our <code class="language-plaintext highlighter-rouge">M</code> type to have an <code class="language-plaintext highlighter-rouge">of</code> method <em>and</em> be <code class="language-plaintext highlighter-rouge">Chain</code>able. <code class="language-plaintext highlighter-rouge">Chain</code> for the <code class="language-plaintext highlighter-rouge">Semigroup</code>, plus <code class="language-plaintext highlighter-rouge">Applicative</code> for the <code class="language-plaintext highlighter-rouge">Monoid</code>.</p>

<p>Take a breath, Fantasists: I&#x2019;m aware that I <em>might</em> be alone here, but I think this is <strong>beautiful</strong>. No matter how clever we <em>think</em> we&#x2019;re being, it&#x2019;s all really just <code class="language-plaintext highlighter-rouge">Semigroup</code>s and <code class="language-plaintext highlighter-rouge">Monoid</code>s at the end of the day. Under the surface, it <strong>never</strong> gets more <strong>complex</strong> than that.</p>

<p>Let&#x2019;s not get <em>too</em> excited just yet, though; remember that there are <strong>laws</strong> with <code class="language-plaintext highlighter-rouge">empty</code>. Think back to <a href="/2017/03/21/fantas-eel-and-specification-5/">the <code class="language-plaintext highlighter-rouge">Monoid</code> post</a>: it has to satisfy <strong>left and right identity</strong>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For any monoid x...</span>
<span class="nx">x</span>
  <span class="c1">// Right identity</span>
  <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

  <span class="c1">// Left identity</span>
  <span class="o">===</span> <span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>


<span class="c1">// So, for `MCompose` and some `f`...</span>
<span class="nx">MCompose</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

  <span class="c1">// Right identity</span>
  <span class="o">===</span> <span class="nx">MCompose</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">MCompose</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

  <span class="c1">// Left identity</span>
  <span class="o">===</span> <span class="nx">MCompose</span><span class="p">.</span><span class="nx">empty</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">MCompose</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>

<span class="c1">//- In other words, `of` can&apos;t disrupt the</span>
<span class="c1">//- sequence held inside `mcompose`! For</span>
<span class="c1">//- the sake of clarity, this just means:</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">M</span><span class="p">.</span><span class="k">of</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="o">===</span> <span class="nx">f</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">M</span><span class="p">.</span><span class="k">of</span><span class="p">)</span> <span class="o">===</span> <span class="nx">f</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
</code></pre></div></div>

<p>And there we have it: <code class="language-plaintext highlighter-rouge">of</code> <strong>cannot disrupt the sequence</strong>. All it can do is put a value into an <strong>empty</strong> context, placing it somewhere in our sequence. No <strong>tricks</strong>, no <strong>magic</strong>, no <strong>side-effects</strong>.</p>

<p>So, for your most <strong>strict</strong> and <strong>correct</strong> definition, <code class="language-plaintext highlighter-rouge">M</code> is a <code class="language-plaintext highlighter-rouge">Monad</code> if you can substitute it into our <code class="language-plaintext highlighter-rouge">MCompose</code> without breaking the <code class="language-plaintext highlighter-rouge">Monoid</code> laws. <strong>That&#x2019;s it</strong>!</p>

<hr>

<blockquote>
  <p>For those skipping ahead, <strong>stop scrolling</strong>!</p>
</blockquote>

<p>Ok, big deal, <code class="language-plaintext highlighter-rouge">Monad</code> is to <code class="language-plaintext highlighter-rouge">Chain</code> as <code class="language-plaintext highlighter-rouge">Monoid</code> is to <code class="language-plaintext highlighter-rouge">Semigroup</code>; why is everyone getting so <em>excited</em> about this, though? Well, remember how we said we could use <code class="language-plaintext highlighter-rouge">Chain</code> to define <strong>execution order</strong>?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ getUserByName :: String -&gt; Promise User</span>
<span class="kd">const</span> <span class="nx">getUserByName</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">=&gt;</span>
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="cm">/* Some AJAX */</span><span class="p">)</span>

<span class="c1">//+ getFriends :: User -&gt; Promise [User]</span>
<span class="kd">const</span> <span class="nx">getFriends</span> <span class="o">=</span> <span class="nx">user</span> <span class="o">=&gt;</span>
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="cm">/* Some more AJAX */</span><span class="p">)</span>

<span class="c1">// e.g. returns [every, person, ever]</span>
<span class="nx">getUser</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Baymax</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">getFriends</span><span class="p">)</span>
</code></pre></div></div>

<p>With this, we can define <a href="https://twitter.com/am_i_tom/status/850082511900332033"><strong>entire programs</strong> using <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">chain</code></a>! We can do this because we can <strong>sequence</strong> our actions. What we get with <code class="language-plaintext highlighter-rouge">of</code> is the ability to <em>lift</em> variables into that context whenever we like!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">optimisedGetFriends</span> <span class="o">=</span> <span class="nx">user</span>
  <span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="dl">&quot;</span><span class="s2">Howard Moon</span><span class="dl">&quot;</span>
  <span class="p">?</span> <span class="nb">Promise</span><span class="p">.</span><span class="k">of</span><span class="p">([])</span> <span class="c1">// Lift into Promise</span>
  <span class="p">:</span> <span class="nx">getFriends</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="c1">// Promise-returner</span>
</code></pre></div></div>

<p>We know that <code class="language-plaintext highlighter-rouge">getFriends</code> returns a <code class="language-plaintext highlighter-rouge">Promise</code>, so our speedy result needs to do the same. Luckily, we can just <em>lift</em> our speedy result into a <strong>pure</strong> <code class="language-plaintext highlighter-rouge">Promise</code>, and we&#x2019;re <strong>good to go</strong>!</p>

<p>Although it may <em>seem</em> improbable, we actually now have the capability to write <strong>any</strong> <code class="language-plaintext highlighter-rouge">IO</code> logic we might want to write:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nb">Promise</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">fantasy-promises</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">rl</span> <span class="o">=</span>
  <span class="nx">require</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">readline</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">createInterface</span><span class="p">({</span>
    <span class="na">input</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">,</span>
    <span class="na">output</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span>
  <span class="p">})</span>

<span class="c1">//+ prompt :: Promise String</span>
<span class="kd">const</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
  <span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">question</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">&gt;</span><span class="dl">&apos;</span><span class="p">,</span> <span class="nx">res</span><span class="p">))</span>

<span class="c1">//- We use &quot;Unit&quot; to mean &quot;undefined&quot;.</span>
<span class="c1">//+ speak :: String -&gt; Promise Unit</span>
<span class="kd">const</span> <span class="nx">speak</span> <span class="o">=</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
  <span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">string</span><span class="p">)))</span>

<span class="c1">//- Our entire asynchronous app!</span>
<span class="c1">//+ MyApp :: Promise String</span>
<span class="kd">const</span> <span class="nx">MyApp</span> <span class="o">=</span>
  <span class="c1">// Get the name...</span>
  <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">What is your name?</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">prompt</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span>

    <span class="c1">// Get the age...</span>
    <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">And what is your age?</span><span class="dl">&apos;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">prompt</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">age</span> <span class="o">=&gt;</span>

      <span class="c1">// Do the logic...</span>
      <span class="nx">age</span> <span class="o">&gt;</span> <span class="mi">30</span>

      <span class="p">?</span> <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Seriously, </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">?!</span><span class="dl">&apos;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">speak</span><span class="p">(</span>
          <span class="dl">&apos;</span><span class="s1">You don</span><span class="se">\&apos;</span><span class="s1">t look a day over </span><span class="dl">&apos;</span>
            <span class="o">+</span> <span class="p">(</span><span class="nx">age</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span><span class="p">))</span>

      <span class="p">:</span> <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hmm, I can believe that!</span><span class="dl">&apos;</span><span class="p">))</span>

    <span class="c1">// Return the name!</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">name</span><span class="p">)))</span>

<span class="c1">//- Our one little impurity:</span>

<span class="c1">// We run our program with a final</span>
<span class="c1">// handler for when we&apos;re all done!</span>
<span class="nx">MyApp</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// Do some database stuff...</span>
  <span class="c1">// Do some beeping and booping...</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">FLATTERED </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">name</span><span class="p">)</span>
  <span class="nx">rl</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span> <span class="c1">// Or whatever</span>
<span class="p">})</span>
</code></pre></div></div>

<p>That, <em>beautiful</em> Fantasists, is (basically) an <strong>entirely purely-functional</strong> app. Let&#x2019;s talk about a few cool things here.</p>

<p>Firstly, <strong>every step</strong> is <code class="language-plaintext highlighter-rouge">chain</code>ed together, so we&#x2019;re <strong>explicitly</strong> giving the <strong>order</strong> in which stuff should happen.</p>

<p>Secondly, we can <strong>nest</strong> <code class="language-plaintext highlighter-rouge">chain</code> to get access to <strong>previous values</strong> in <strong>later actions</strong>.</p>

<p>Thirdly, <code class="language-plaintext highlighter-rouge">chain</code> means we can do <strong>everything with arrow functions</strong>. Every command is a <em>single-expression</em> function; it&#x2019;s <strong>super neat</strong>! Try re-formatting this example on a bigger screen; all my examples are written for <em>mobile</em>, but this example can look far more readable with 80-character width!</p>

<p>Fourthly, following on from the <em>first</em> point, there&#x2019;s <strong>no mention</strong> of <strong>async</strong> with <code class="language-plaintext highlighter-rouge">chain</code> - we specify the <strong>order</strong>, and <code class="language-plaintext highlighter-rouge">Promise.chain</code> does the promise-wiring <strong>for us</strong>! At this point, async behaviour is literally <strong>just</strong> an <strong>implementation detail</strong>.</p>

<p>Fifthly (<em>are these still words?</em>), <code class="language-plaintext highlighter-rouge">MyApp</code> - our whole program - <strong>is a value</strong>! It has a type <code class="language-plaintext highlighter-rouge">Promise String</code>, and we can use that <code class="language-plaintext highlighter-rouge">String</code>! What does <em>that</em> mean? <strong>We can chain programs together</strong>!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ BigApp :: Promise Unit</span>
<span class="kd">const</span> <span class="nx">BigApp</span> <span class="o">=</span>
  <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">PLAYER ONE</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">MyApp</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">player1</span> <span class="o">=&gt;</span>

    <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">PLAYER TWO</span><span class="dl">&apos;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">MyApp</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">player2</span> <span class="o">=&gt;</span>

      <span class="nx">speak</span><span class="p">(</span><span class="nx">player1</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> vs </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">player2</span><span class="p">)))</span>
</code></pre></div></div>

<p><strong>OMGWTF</strong>! We took our <strong>entire</strong> program and used it as a <strong>value</strong>&#x2026; <strong>twice</strong>! As a consequence, we can just write lots of little programs and <strong>chain</strong> (<em>compose, concat, bind, whatever you want to say</em>) them together into <strong>bigger ones</strong>! Remember, too, that <code class="language-plaintext highlighter-rouge">Monad</code>s are all also <code class="language-plaintext highlighter-rouge">Applicatives</code>&#x2026;</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ BigApp_ :: Promise Unit</span>
<span class="kd">const</span> <span class="nx">BigApp_</span> <span class="o">=</span>
  <span class="nx">lift2</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> vs </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span>
    <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">PLAYER ONE</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">MyApp</span><span class="p">),</span>
    <span class="nx">speak</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">PLAYER TWO</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">MyApp</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>Oh yeah</strong>! Our programs are now <strong>totally composable</strong> <code class="language-plaintext highlighter-rouge">Applicative</code>s, just like any other value. Our <strong>entire programs</strong>! All a functional program <em>really</em> does is collect some <em>little</em> programs together with <code class="language-plaintext highlighter-rouge">ap</code> and <code class="language-plaintext highlighter-rouge">chain</code>. It really is <strong>that neat</strong>!</p>

<blockquote>
  <p>Why do we use <code class="language-plaintext highlighter-rouge">fantasy-promises</code> instead of the built-in <code class="language-plaintext highlighter-rouge">Promise</code>? Our <strong>functional</strong> <code class="language-plaintext highlighter-rouge">Promise</code> doesn&#x2019;t execute until we call <code class="language-plaintext highlighter-rouge">fork</code> - that means we can <strong>delay</strong> the call until we&#x2019;ve <strong>defined</strong> its behaviour. With a built-in <code class="language-plaintext highlighter-rouge">Promise</code>, things start happening immediately, which can lead to <strong>non-determinism</strong> and <strong>race conditions</strong>. This way, we maintain <strong>full control</strong>!</p>
</blockquote>

<p>Of course, maybe the syntax is a bit <em>ugly</em>, but that&#x2019;s what <strong>helper functions</strong> are for! Also, why stop at <code class="language-plaintext highlighter-rouge">Promise</code>? This fanciness works for <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">Either</code>, <code class="language-plaintext highlighter-rouge">Function</code>, <code class="language-plaintext highlighter-rouge">Pair</code>, and <strong>so many more</strong>!</p>

<p>Keep fiddling, using those <code class="language-plaintext highlighter-rouge">Task</code>/<code class="language-plaintext highlighter-rouge">Promise</code> isomorphisms to do things  in parallel, using <code class="language-plaintext highlighter-rouge">Maybe</code> to avoid <code class="language-plaintext highlighter-rouge">undefined</code> / <code class="language-plaintext highlighter-rouge">null</code> along the way, using <code class="language-plaintext highlighter-rouge">Array</code> to return multiple choices; if you can handle all that, you&#x2019;re a <strong>fully-fledged</strong> functional aficionado!</p>

<hr>

<p>You might be wondering what the <em>rest</em> is for if we now have all the tools we&#x2019;ll ever need, and that&#x2019;s certainly a good question. The rest are <strong>optional</strong>; monadic functional programming doesn&#x2019;t <strong>require</strong> an understanding of <code class="language-plaintext highlighter-rouge">Comonad</code> or <code class="language-plaintext highlighter-rouge">Profunctor</code>, but nor does it require an understanding of <code class="language-plaintext highlighter-rouge">Alt</code> or <code class="language-plaintext highlighter-rouge">Traversable</code>; these are just <strong>design patterns</strong> to help our code to be as  <strong>polymorphic</strong> as possible.</p>

<p>As always, there&#x2019;s <a href="https://gist.github.com/richdouglasevans/ea96fb5fc8bb55d832a8a20f8c14d4ed">a <strong>Gist</strong> for the article</a>, so have a <strong>play</strong> with it! Here&#x2019;s a little idea for an exercise: write a <strong>monadic</strong> functional CLI app to play &#x201C;higher or lower&#x201D;. You know everything you need to know; <strong>trust me</strong>!</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 17: Comonad</h1>
  <span class="post-date">19 Jun 2017</span>
  <p><strong>&#x2018;Ello &#x2018;ello</strong>! Remember that <code class="language-plaintext highlighter-rouge">Monad</code> thing we used to be afraid of, and how it just boiled down to a way for us to <strong>sequence</strong> our ideas? How <code class="language-plaintext highlighter-rouge">Extend</code> was really just <code class="language-plaintext highlighter-rouge">Chain</code> backwards? Well, today, we&#x2019;ll answer the question that I&#x2019;m sure has plagued you <em>all</em> week: <strong>what <em>is</em> a backwards <code class="language-plaintext highlighter-rouge">Monad</code></strong>?</p>

<p>First up, we should talk about the <strong>name</strong>. <em>No</em>, not the <code class="language-plaintext highlighter-rouge">monad</code> bit - the <code class="language-plaintext highlighter-rouge">co</code> bit. When we talk about structures like <code class="language-plaintext highlighter-rouge">Monad</code>, we sometimes talk about the idea of the <strong>dual structure</strong>. Now, for our purposes, we can just think of this as, &#x201C;<em>The same, but with all the arrows backwards</em>&#x201D;.</p>

<blockquote>
  <p>This is a <em>surprisingly</em> good intuition for dual structures. Seriously.</p>
</blockquote>

<p>Hey, that was our <strong>first hint</strong>! <code class="language-plaintext highlighter-rouge">Comonad</code> is <code class="language-plaintext highlighter-rouge">Monad</code> with &#x201C;the arrows backwards&#x201D;. When we <strong>boil it down</strong>, there are really only two <strong>interesting</strong> things that a <code class="language-plaintext highlighter-rouge">Monad</code> can do:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- For any monad `m`:</span>
<span class="kr">of</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">chain</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>From this, we can derive all the other fun stuff like <code class="language-plaintext highlighter-rouge">join</code>, <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">ap</code>, and whatnot. So, let&#x2019;s write this all <strong>backwards</strong>, turning our entire types the <strong>wrong way round</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Turn the arrows around...</span>
<span class="n">coOf</span> <span class="o">::</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">coChain</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;-</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">m</span> <span class="n">b</span>

<span class="c1">-- Or, more familiarly...</span>
<span class="c1">-- For any Comonad `w`:</span>
<span class="n">coOf</span> <span class="o">::</span> <span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">coChain</span> <span class="o">::</span> <span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">w</span> <span class="n">b</span>
</code></pre></div></div>

<p>Well, here&#x2019;s the <strong>good news</strong>: we already know <code class="language-plaintext highlighter-rouge">coChain</code>, and we call it <code class="language-plaintext highlighter-rouge">extend</code>! That leaves us with that <code class="language-plaintext highlighter-rouge">coOf</code> function, which the <a href="https://github.com/fantasyland/fantasy-land">glorious Fantasy Land spec</a> calls <strong><code class="language-plaintext highlighter-rouge">extract</code></strong>.</p>

<p>When I first looked at <code class="language-plaintext highlighter-rouge">extract</code>, I got a bit confused. Couldn&#x2019;t we do that with <code class="language-plaintext highlighter-rouge">Monad</code>? If not, what&#x2019;s the <em>point</em> in a <code class="language-plaintext highlighter-rouge">Monad</code> if we can&#x2019;t get a value back <em>out</em>? What helped me was looking <strong>a little closer</strong> at <code class="language-plaintext highlighter-rouge">extract</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extract</span> <span class="o">::</span> <span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>That function takes <strong>any</strong> <code class="language-plaintext highlighter-rouge">Comonad</code> and returns the value <strong>inside</strong>. We couldn&#x2019;t do that for <code class="language-plaintext highlighter-rouge">Maybe</code>, because some of our values - <code class="language-plaintext highlighter-rouge">Nothing</code> - don&#x2019;t have a value to return! We couldn&#x2019;t do it for <code class="language-plaintext highlighter-rouge">Array</code>; what if it&#x2019;s <strong>empty</strong>? We couldn&#x2019;t do it for <code class="language-plaintext highlighter-rouge">Promise</code>; we don&#x2019;t know what the value <em>is</em> yet! It turns out that, for a <em>lot</em> of <code class="language-plaintext highlighter-rouge">Monad</code> types, this function <strong>isn&#x2019;t as easy</strong> to write as we might think at first glance.</p>

<p>Let&#x2019;s think about <code class="language-plaintext highlighter-rouge">Maybe</code> for a second, though. Would it be a <code class="language-plaintext highlighter-rouge">Comonad</code> if we removed the <code class="language-plaintext highlighter-rouge">Nothing</code> option? Well, yes, but then it wouldn&#x2019;t be a <code class="language-plaintext highlighter-rouge">Maybe</code> - it would be <code class="language-plaintext highlighter-rouge">Identity</code> with a funny name!</p>

<p>What about <code class="language-plaintext highlighter-rouge">Array</code>? What if we made a type like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- An array with AT LEAST ONE element.</span>
<span class="c1">//+ data NonEmpty = NonEmpty a (Array a)</span>
<span class="kd">const</span> <span class="nx">NonEmpty</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span>
  <span class="dl">&apos;</span><span class="s1">NonEmpty</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">head</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">tail</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1">// Extend would function the same way as it</span>
<span class="c1">// did for Array in the last article...</span>

<span class="nx">NonEmpty</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extract</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span>
<span class="p">}</span>

<span class="c1">// e.g.</span>
<span class="nx">NonEmpty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]).</span><span class="nx">extract</span><span class="p">()</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p>Now we have a <strong>type</strong> for non-empty lists, we can <strong>guarantee</strong> a value to extract! This type, it transpires, forms a beautiful <code class="language-plaintext highlighter-rouge">Comonad</code>.</p>

<blockquote>
  <p>A piece of good advice is to <strong>make illegal states unrepresentable</strong>. If we need an array somewhere in our code that <strong>must</strong> have at least one element, using the <code class="language-plaintext highlighter-rouge">NonEmpty</code> type gives us an API with that <strong>guarantee</strong>!</p>
</blockquote>

<p>So, <code class="language-plaintext highlighter-rouge">chain</code> gave us sequencing with <strong>write</strong> access to the <strong>output</strong>, and <code class="language-plaintext highlighter-rouge">of</code> let us <strong>lift</strong> a value into the computation whenever we liked. <code class="language-plaintext highlighter-rouge">extend</code> gives us sequencing with <strong>read</strong> access to the <strong>input</strong>, and <code class="language-plaintext highlighter-rouge">extract</code> lets us <strong>extract</strong> a value out of the computation whenever we like!</p>

<blockquote>
  <p>If you&#x2019;ve followed the blog series up until now, <a href="https://github.com/fantasyland/fantasy-land#comonad">the <code class="language-plaintext highlighter-rouge">Comonad</code> laws</a> are going to be what you&#x2019;ve come to expect. <strong>No new ideas</strong>!</p>
</blockquote>

<hr>

<p>Now, before we start to assume that all <code class="language-plaintext highlighter-rouge">Comonad</code> types are just <strong>bastardised <code class="language-plaintext highlighter-rouge">Monad</code> types</strong>, let&#x2019;s look at something <strong>very</strong> comonadic: <code class="language-plaintext highlighter-rouge">Store</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ data Store p s = Store (p -&gt; s) p</span>
<span class="kd">const</span> <span class="nx">Store</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span>
  <span class="dl">&apos;</span><span class="s1">Store</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">lookup</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">pointer</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>The intuition here is that <code class="language-plaintext highlighter-rouge">lookup</code> represents a function to get things <em>out</em> of a &#x201C;store&#x201D; of <code class="language-plaintext highlighter-rouge">s</code>-values, indexed by <code class="language-plaintext highlighter-rouge">p</code>-values. So, if we pass a <code class="language-plaintext highlighter-rouge">p</code> to the <code class="language-plaintext highlighter-rouge">lookup</code> function, we&#x2019;ll get out its corresponding <code class="language-plaintext highlighter-rouge">s</code>. The <code class="language-plaintext highlighter-rouge">pointer</code> value represents the &#x201C;current&#x201D; value. Think of this like the <strong>read head</strong> on an old <strong>hard disk</strong>.</p>

<p>Now, to make this type more useful, we can stick a couple of functions onto this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- &quot;Move&quot; the current pointer.</span>
<span class="c1">//+ seek :: Store p s ~&gt; p -&gt; Store p s</span>
<span class="nx">Store</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">seek</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Store</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">lookup</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//- Have a look at a particular cell.</span>
<span class="c1">//+ peek :: Store p s ~&gt; p -&gt; s</span>
<span class="nx">Store</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And, wouldn&#x2019;t you know it, we can also make this a functor by <a href="/2017/04/15/functions-as-functors/">mapping over the <strong>function</strong></a>!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Compose the functions! Yay!</span>
<span class="nx">Store</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">lookup</span><span class="p">,</span> <span class="nx">pointer</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span>

  <span class="k">return</span> <span class="nx">Store</span><span class="p">(</span><span class="nx">lookup</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nx">pointer</span><span class="p">)</span>
  <span class="c1">// Store(p =&gt; f(lookup(p)), pointer)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, if we&#x2019;re going to make a <code class="language-plaintext highlighter-rouge">Comonad</code> of our <code class="language-plaintext highlighter-rouge">Store</code>, we first need to make it an <code class="language-plaintext highlighter-rouge">Extend</code> instance. Remember: <code class="language-plaintext highlighter-rouge">extend</code> should behave like <code class="language-plaintext highlighter-rouge">map</code>, but with <strong>read-access to the input</strong>. Here&#x2019;s where <code class="language-plaintext highlighter-rouge">Store</code> gets <em>really</em> sneaky.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ extend :: Store p s ~&gt; (Store p s -&gt; t)</span>
<span class="c1">//+                     -&gt; Store p t</span>
<span class="nx">Store</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Store</span><span class="p">(</span>
    <span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">Store</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">lookup</span><span class="p">,</span> <span class="nx">p</span><span class="p">)),</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">pointer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">lookup</code> function now applies <code class="language-plaintext highlighter-rouge">f</code> to a <code class="language-plaintext highlighter-rouge">Store</code> <strong>identical</strong> to the original, but with the focus on the <strong>given index</strong>! Can you see the magic yet? Let&#x2019;s <strong>build something exciting</strong>: <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&#x2019;s <strong>Game of Life</strong></a>.</p>

<hr>

<p>For this, we&#x2019;re going to use a &#x201C;board&#x201D; of <code class="language-plaintext highlighter-rouge">[[Bool]]</code> type to represent our &#x201C;live&#x201D; and &#x201C;dead&#x201D; cells. Something like this, perhaps:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span> <span class="p">],</span>
  <span class="p">[</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span> <span class="p">],</span>
  <span class="p">[</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>  <span class="p">],</span>
  <span class="p">[</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span>  <span class="kc">false</span> <span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>If we want to look up a value in this store, we&#x2019;re going to need an <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> coordinate. What better choice of structure to hold two numbers than a <code class="language-plaintext highlighter-rouge">Pair</code>?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Game</span> <span class="o">=</span> <span class="nx">Store</span><span class="p">(</span>
  <span class="p">({</span> <span class="na">_1</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="na">_2</span><span class="p">:</span> <span class="nx">y</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="c1">// Return the cell OR false.</span>
    <span class="nx">y</span> <span class="k">in</span> <span class="nx">start</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">start</span><span class="p">[</span><span class="nx">y</span><span class="p">]</span>
      <span class="p">?</span> <span class="nx">start</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span>
      <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>

  <span class="c1">// We don&apos;t care about `pointer` yet.</span>
  <span class="nx">Pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<p>Now, we need to write out some logic! The rule for the Game of Life is that, if a <code class="language-plaintext highlighter-rouge">false</code> cell has <strong>exactly three</strong> <code class="language-plaintext highlighter-rouge">true</code> neighbours, make it true. If a <code class="language-plaintext highlighter-rouge">true</code> cell has <strong>two or three</strong> <code class="language-plaintext highlighter-rouge">true</code> neighbours, keep it as true. If <strong>neither</strong> apply, make it <code class="language-plaintext highlighter-rouge">false</code>. We can work this out for any cell with eight sneaky <code class="language-plaintext highlighter-rouge">peek</code>s!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// What will the current cell be next time?</span>
<span class="c1">//+ isSurvivor :: Store (Pair Int Int) Bool</span>
<span class="c1">//+            -&gt; Bool</span>
<span class="kd">const</span> <span class="nx">isSurvivor</span> <span class="o">=</span> <span class="nx">store</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="na">_1</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="na">_2</span><span class="p">:</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">pointer</span>

  <span class="c1">// The number of `true` neighbours.</span>
  <span class="kd">const</span> <span class="nx">neighbours</span> <span class="o">=</span>
    <span class="p">[</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// NW</span>
    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">// N</span>
    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// NE</span>

    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>     <span class="c1">// W</span>
    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>     <span class="c1">// E</span>

    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// SW</span>
    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">// S</span>
    <span class="p">,</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// SE</span>
    <span class="p">]</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nx">peek</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// Look up!</span>
    <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// Ignore false cells</span>
    <span class="p">.</span><span class="nx">length</span>

  <span class="c1">// Exercise: simplify this.</span>
  <span class="k">return</span> <span class="nx">store</span><span class="p">.</span><span class="nx">extract</span><span class="p">()</span> <span class="c1">// Is it true?</span>
    <span class="p">?</span> <span class="nx">neighbours</span> <span class="o">===</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">neighbours</span> <span class="o">===</span> <span class="mi">3</span>
    <span class="p">:</span> <span class="nx">neighbours</span> <span class="o">===</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, <em>why</em> did we go to all this trouble? Well, we now have a <code class="language-plaintext highlighter-rouge">Store (Int, Int) Bool</code> to <code class="language-plaintext highlighter-rouge">Bool</code> function, which is the exact shape that <code class="language-plaintext highlighter-rouge">extend</code> needs&#x2026; and <code class="language-plaintext highlighter-rouge">extend</code> will (lazily!) apply this function to <strong>every cell on the board!</strong> By using <code class="language-plaintext highlighter-rouge">extend</code>, we now get to see the <strong>entire board</strong> one step into <strong>the future</strong>. Isn&#x2019;t that <em>magical</em>?</p>

<blockquote>
  <p>I <em>strongly</em> recommend you look at <a href="https://gist.github.com/richdouglasevans/0f9a57e5a52b13e93c0c03630165ecd8">the Gist for this article</a> and be sure that this makes sense. <code class="language-plaintext highlighter-rouge">Store</code> is an <strong>unfamiliar beast</strong>.</p>
</blockquote>

<hr>

<p>Now, there are plenty of other <code class="language-plaintext highlighter-rouge">Comonad</code> types, but they&#x2019;re not quite as popular as <code class="language-plaintext highlighter-rouge">Monad</code> types, probably because their use isn&#x2019;t so <strong>obvious</strong>. After all, we can write our applications just using <code class="language-plaintext highlighter-rouge">Monad</code> types, so this (<em>unfairly</em>) ends up in the <em>advanced</em> box. How <strong>rude</strong>!</p>

<p>For now, however, we&#x2019;ll stop here. I will come back to <code class="language-plaintext highlighter-rouge">Comonad</code> in other posts - they&#x2019;re my latest <strong>obsession</strong> - but <code class="language-plaintext highlighter-rouge">Store</code> gives a really clear idea about why these are useful. Incidentally, if you want to play the Game of Life, <a href="https://gist.github.com/richdouglasevans/0f9a57e5a52b13e93c0c03630165ecd8">the article&#x2019;s Gist</a> has a working demo!</p>

<p>Next time, we&#x2019;ll be looking at <code class="language-plaintext highlighter-rouge">Bifunctor</code> and <code class="language-plaintext highlighter-rouge">Profunctor</code>: so simple, we&#x2019;re going to do both at the same time! I promise: these last two are going to be a bit of a <strong>cool-down session</strong>. Until then!</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 4: Semigroup</h1>
  <span class="post-date">13 Mar 2017</span>
  <p>Today, after a moment of thanks to all those following this series (seriously, <em>thank you</em> &#x2665;), we can move onto a question that has occupied human thought for aeons: how do we generalise the process of combining (or <a href="https://twitter.com/drboolean/status/700436888390217728">mooshmashing</a>) things together? With <strong>semigroups</strong>, of course!</p>

<p>Now, just as with <a href="/2017/03/09/fantas-eel-and-specification-3/"><code class="language-plaintext highlighter-rouge">Setoid</code></a>, we&#x2019;ll get methods and laws out the way now so that we can move on to fun things. Luckily, there&#x2019;s only one of each! A valid <code class="language-plaintext highlighter-rouge">Semigroup</code> must have a <code class="language-plaintext highlighter-rouge">concat</code> method with the following signature:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">concat</span> <span class="o">::</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p><em>A <code class="language-plaintext highlighter-rouge">Semigroup</code>&#x2019;s <code class="language-plaintext highlighter-rouge">concat</code> method must take another value of the same type, and return a third value of the same type.</em> The only law we have to worry about here is <strong>associativity</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
</code></pre></div></div>

<p>In other words, as long as the left-to-right order is maintained, we can put the brackets wherever we like. Just take a moment to think about how much <strong>freedom</strong> we have with this structure! As stated earlier, <code class="language-plaintext highlighter-rouge">Semigroup</code> types are designed to be mooshmashed together. How the mooshmashing works is <em>entirely</em> up to you.</p>

<p>Let&#x2019;s start with a look at <strong>strings</strong>. By chance, JavaScript&#x2019;s <code class="language-plaintext highlighter-rouge">String</code> type is <em>already</em> a Fantasy Land-compliant semigroup!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &apos;hello, world!&apos;</span>
<span class="dl">&apos;</span><span class="s1">hello</span><span class="dl">&apos;</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">, world!</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">// This operation is associative, too!</span>
<span class="dl">&apos;</span><span class="s1">hello</span><span class="dl">&apos;</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">, </span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">world!</span><span class="dl">&apos;</span><span class="p">)</span>
<span class="dl">&apos;</span><span class="s1">hello</span><span class="dl">&apos;</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">, </span><span class="dl">&apos;</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">world!</span><span class="dl">&apos;</span><span class="p">))</span>
</code></pre></div></div>

<p>We take two strings, and <code class="language-plaintext highlighter-rouge">concat</code> them to make another string. Along those lines, you might also notice that <strong>arrays are already valid semigroups</strong>, too!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">// [1, 2, 3, 4]</span>

<span class="c1">// Aaand it&apos;s associative!</span>
<span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">]))</span>
</code></pre></div></div>

<p>Notice, as well, that we don&#x2019;t put any <strong>constraints</strong> on the array&#x2019;s inner type - we don&#x2019;t need to care <em>what</em> is in the array!</p>

<p>For <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Array</code>, it&#x2019;s pretty obvious what the <code class="language-plaintext highlighter-rouge">concat</code> implementation would be, probably because it&#x2019;s <code class="language-plaintext highlighter-rouge">concat</code>enation. How, though, do we <code class="language-plaintext highlighter-rouge">concat</code> numbers? <code class="language-plaintext highlighter-rouge">+</code>? <code class="language-plaintext highlighter-rouge">*</code>? <code class="language-plaintext highlighter-rouge">max</code>?</p>

<p>The answer is that <strong>it&#x2019;s up to you</strong> - we can pick any of these as they would all satisfy the laws. This is the <strong>freedom of semigroups</strong>. In actual fact, it would even be a valid <code class="language-plaintext highlighter-rouge">concat</code> implementation for strings if they were concatenated with <code class="language-plaintext highlighter-rouge">x + &quot; MITTENS &quot; + y</code> - there really is a <em>lot</em> we can do with semigroups (but <strong>always check the laws</strong>).</p>

<p>For the sake of clarity, we tend to create <strong>separate semigroup types</strong> to encapsulate these ideas. We&#x2019;ll start with a nice, easy one: <code class="language-plaintext highlighter-rouge">Sum</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Sum</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Sum</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">val</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="nx">Sum</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Sum</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="nx">that</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">Sum</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nx">val</span> <span class="c1">// 5</span>
</code></pre></div></div>

<p><strong>That&#x2019;s it</strong>. No hidden magic, no nothing. It&#x2019;s so wonderfully simple; why not write <code class="language-plaintext highlighter-rouge">Product</code> (multiplication), <code class="language-plaintext highlighter-rouge">Max</code>, and <code class="language-plaintext highlighter-rouge">Min</code> types as an exercise? I can promise you that it won&#x2019;t take long!</p>

<p>We&#x2019;re not only restricted to numbers, either. There are two intuitive <code class="language-plaintext highlighter-rouge">Semigroup</code> instances for booleans:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Any</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Any</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">||</span> <span class="nx">that</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">All</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">All</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">&amp;&amp;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Any</code> will hold <code class="language-plaintext highlighter-rouge">true</code> if <em>any</em> concatenated values be <code class="language-plaintext highlighter-rouge">true</code>, and <code class="language-plaintext highlighter-rouge">All</code> will hold <code class="language-plaintext highlighter-rouge">true</code> if <em>all</em> concatenated values be <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>There are also a few others that don&#x2019;t care what the inner type is, such as <code class="language-plaintext highlighter-rouge">First</code> and <code class="language-plaintext highlighter-rouge">Last</code>. Super simple, and we&#x2019;ll see a use for these later:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Return the a value in a.concat(b)</span>
<span class="nx">First</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span>
<span class="p">}</span>

<span class="c1">// Return the b value in a.concat(b)</span>
<span class="nx">Last</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">that</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>We&#x2019;ll also see loads more use cases for these types defined so far when we get on to <strong>monoids</strong> in the next article*.</p>
</blockquote>

<p>We could even define a <a href="http://hackage.haskell.org/package/containers-0.5.10.1/docs/src/Data-Set-Internal.html#union"><code class="language-plaintext highlighter-rouge">Set</code> semigroup</a>, where concatenation is <strong>set union</strong> (or <strong>intersection</strong>!), and the elements of its inner list are unique. If you want to have a go at building such a type, notice that <code class="language-plaintext highlighter-rouge">Set a</code> could only be a <code class="language-plaintext highlighter-rouge">Semigroup</code> if <code class="language-plaintext highlighter-rouge">a</code> were a <code class="language-plaintext highlighter-rouge">Setoid</code> (because you need to check for duplicates) - <em>all these algebraic structures are connected</em>! <strong>Spooky</strong>.</p>

<p>More generally, this is one of many examples of a <code class="language-plaintext highlighter-rouge">Semigroup</code> instance with <strong>constraints</strong>. It&#x2019;s much more common, however, for the constraints to be that inner types <em>also be semigroups</em>.</p>

<p>Let&#x2019;s imagine we have a pair structure, which just holds two values of type <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> respectively. How do we make the <em>pair</em> a semigroup? Well, if we wanted to <code class="language-plaintext highlighter-rouge">concat</code> it with another pair of types <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, the obvious solution would be to <code class="language-plaintext highlighter-rouge">concat</code> the two <code class="language-plaintext highlighter-rouge">a</code> values and the two <code class="language-plaintext highlighter-rouge">b</code>, and return a pair of the results. To do that, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> need to be semigroups:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Tuple</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Tuple</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// concat :: (Semigroup a, Semigroup b) =&gt;</span>
<span class="c1">//   Tuple a b ~&gt; Tuple a b -&gt; Tuple a b</span>
<span class="nx">Tuple</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Tuple</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">a</span><span class="p">),</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Returns Tuple(Sum(3), Any(true))</span>
<span class="nx">Tuple</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">Any</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Tuple</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nx">Any</span><span class="p">(</span><span class="kc">true</span><span class="p">)))</span>
</code></pre></div></div>

<p>We can see here that the <code class="language-plaintext highlighter-rouge">Tuple</code> type is only a semigroup when its component parts are semigroups. This is a clever pattern: one (or both) of those component semigroups could be <em>another</em> pair of other semigroups, and they could <strong>nest</strong> as deep as we need! You can also extend this idea to any fixed groups of elements:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Tuple3</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span>
  <span class="dl">&apos;</span><span class="s1">Tuple3</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">Tuple4</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span>
  <span class="dl">&apos;</span><span class="s1">Tuple4</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">d</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1">// Tuple5, Tuple6, etc...</span>
<span class="c1">// Is `concat` obvious for these?</span>
</code></pre></div></div>

<p>I&#x2019;m pretty sure you can work out how the <code class="language-plaintext highlighter-rouge">Tuple</code>&#x2019;s <code class="language-plaintext highlighter-rouge">concat</code> method can be rewritten for <em>any number of fields</em>! Anyway, let&#x2019;s not waste time writing <code class="language-plaintext highlighter-rouge">concat</code> for <code class="language-plaintext highlighter-rouge">Tuple20</code>. Instead, let&#x2019;s talk about a <em>practical</em> application of this idea: <strong>customer record merging</strong>.</p>

<p>I&#x2019;m sure they&#x2019;re the three words you wanted to hear! Let&#x2019;s imagine you&#x2019;re building some system in which you store customer records that look like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Customer</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Customer</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span>
  <span class="dl">&apos;</span><span class="s1">name</span><span class="dl">&apos;</span><span class="p">,</span>             <span class="c1">// String</span>
  <span class="dl">&apos;</span><span class="s1">favouriteThings</span><span class="dl">&apos;</span><span class="p">,</span>  <span class="c1">// [String]</span>
  <span class="dl">&apos;</span><span class="s1">registrationDate</span><span class="dl">&apos;</span><span class="p">,</span> <span class="c1">// Int -- since epoch</span>
  <span class="dl">&apos;</span><span class="s1">hasMadePurchase</span><span class="dl">&apos;</span>   <span class="c1">// Bool</span>
<span class="p">])</span>
</code></pre></div></div>

<p>For whatever reason - I worked with <a href="http://www.nhs.uk/pages/home.aspx">the NHS</a>, and reasons were <em>bountiful</em>) - you might end up with duplicate records for the same person. In this instance, you&#x2019;d want to write a <code class="language-plaintext highlighter-rouge">concat</code> function to make use of our shiny new <code class="language-plaintext highlighter-rouge">Semigroup</code> machinery:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Customer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Customer</span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>

      <span class="c1">// A `Set` type would be good here.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">favouriteThings</span>
        <span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">favouriteThings</span><span class="p">),</span>

      <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">registrationDate</span><span class="p">,</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">registrationDate</span>
      <span class="p">),</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">hasMadePurchase</span>
        <span class="o">||</span> <span class="nx">that</span><span class="p">.</span><span class="nx">hasMadePurchase</span>
    <span class="p">)</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Well, it <em>is</em> a semigroup, but&#x2026; it&#x2019;s pretty <strong>ugly</strong>, right? Firstly, we&#x2019;re tied to <strong>one</strong> particular merge strategy. Secondly, all these properties&#x2019; strategies look&#x2026; <em>familiar</em>&#x2026;</p>

<p>What we&#x2019;d <em>really</em> like to do is define independent merge strategies, probably using semigroups, to which we can delegate the work. <em>That way</em>, we could even have several <strong>different strategies</strong> for merging, depending on the situation!</p>

<p>To do that, we&#x2019;ll need to translate <code class="language-plaintext highlighter-rouge">Customer</code> into some structure that can hold the same information (or, in fancy terms, <em>something <strong>isomorphic</strong> to our <code class="language-plaintext highlighter-rouge">Customer</code> structure</em>).</p>

<p>We&#x2019;ve actually already defined one such structure: the <code class="language-plaintext highlighter-rouge">Tuple4</code>! We&#x2019;re holding exactly four values, so we can translate to and from this structure without trouble. Our &#x201C;merge strategy&#x201D; is therefore just a way of converting our <code class="language-plaintext highlighter-rouge">Customer</code> object to and from a <code class="language-plaintext highlighter-rouge">Tuple4</code> of <code class="language-plaintext highlighter-rouge">Semigroup</code> types:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myStrategy</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// to :: Customer</span>
  <span class="c1">//    -&gt; Tuple4 (First String)</span>
  <span class="c1">//              [String]</span>
  <span class="c1">//              (Min Int)</span>
  <span class="c1">//              (Any Bool)</span>
  <span class="na">to</span><span class="p">:</span> <span class="nx">customer</span> <span class="o">=&gt;</span> <span class="nx">Tuple4</span><span class="p">(</span>
    <span class="nx">First</span><span class="p">(</span><span class="nx">customer</span><span class="p">.</span><span class="nx">name</span><span class="p">),</span>

    <span class="c1">// Arrays are semigroups already!</span>
    <span class="c1">// We could use Set, though.</span>
    <span class="nx">customer</span><span class="p">.</span><span class="nx">favouriteThings</span><span class="p">,</span>

    <span class="nx">Min</span><span class="p">(</span><span class="nx">customer</span><span class="p">.</span><span class="nx">registrationDate</span><span class="p">),</span>

    <span class="nx">Any</span><span class="p">(</span><span class="nx">customer</span><span class="p">.</span><span class="nx">hasMadePurchase</span><span class="p">)</span>
  <span class="p">),</span>

  <span class="c1">// from :: Tuple4 (First String)</span>
  <span class="c1">//                [String]</span>
  <span class="c1">//                (Min Int)</span>
  <span class="c1">//                (Any Bool)</span>
  <span class="c1">//      -&gt; Customer</span>
  <span class="na">from</span><span class="p">:</span> <span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="nx">Customer</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">to</code> field converts a <code class="language-plaintext highlighter-rouge">Customer</code> into a <code class="language-plaintext highlighter-rouge">Tuple4</code> (with the properties wrapped in <code class="language-plaintext highlighter-rouge">Semigroup</code> types), and our <code class="language-plaintext highlighter-rouge">from</code> field converts back. The <strong>type</strong> of the intermediate structure might look a bit frightening, but&#x2026;</p>

<p><em>Who cares</em>? The important thing is that <strong>it&#x2019;s a semigroup</strong>, and, if we have a semigroup, we can write a <em>gorgeous</em> function for merging values:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// merge :: Semigroup m</span>
<span class="c1">//       =&gt; { to   :: a -&gt; m</span>
<span class="c1">//          , from :: m -&gt; a }</span>
<span class="c1">//       -&gt; a -&gt; a -&gt; a</span>
<span class="kd">const</span> <span class="nx">merge</span> <span class="o">=</span> <span class="nx">strategy</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">strategy</span><span class="p">.</span><span class="k">from</span><span class="p">(</span>
    <span class="nx">strategy</span><span class="p">.</span><span class="nx">to</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">strategy</span><span class="p">.</span><span class="nx">to</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>
  <span class="p">)</span>
</code></pre></div></div>

<p>Look at that signature. Given any two values of a type (not necessarily a <code class="language-plaintext highlighter-rouge">Semigroup</code> type!), if we can give a strategy (isomorphism!) for converting them to and from a given Semigroup, we can merge them!</p>

<p>What if we want to merge <strong>more than two</strong> customers? Well, instead of writing hundreds of functions, let&#x2019;s just do a <code class="language-plaintext highlighter-rouge">reduce</code> on a list to merge them into a given <em>starter customer</em>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">mergeMany</span> <span class="o">=</span> <span class="nx">strategy</span> <span class="o">=&gt;</span> <span class="nx">initial</span> <span class="o">=&gt;</span>
  <span class="nx">customers</span> <span class="o">=&gt;</span> <span class="nx">customers</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="nx">merge</span><span class="p">(</span><span class="nx">strategy</span><span class="p">),</span> <span class="nx">initial</span>
  <span class="p">)</span>
</code></pre></div></div>

<p>Gets me all flustered, it does. We can actually make this <em>even prettier</em> with a little more structure that we&#x2019;ll discuss in the next article on <strong>monoids</strong>, but I think this is a good enough example for now.</p>

<p>After all, we&#x2019;ve taken our problem, separated our concerns, and produced some abstract functions that we could apply to <em>other</em> types - not just <code class="language-plaintext highlighter-rouge">Customer</code>! - regardless of how complex they might be. <strong>It&#x2019;s semigroups all the way down</strong>.</p>

<hr>

<p>We&#x2019;ve seen that semigroups have our back any time we want to <em>merge</em>, <em>mooshmash</em>, or <em>combine</em> (whatever word gives you the best <strong>intuition</strong>!) several data into one. We&#x2019;ve also seen how flexible they can be - everything from <code class="language-plaintext highlighter-rouge">First</code> to <code class="language-plaintext highlighter-rouge">Pair</code> was a law-obiding <code class="language-plaintext highlighter-rouge">Semigroup</code> type.</p>

<p>Yet, just as we&#x2019;ll see with all the other Fantasy Land magic, the interface is <em>exactly</em> what we needed to create some really powerful functions. If you&#x2019;re not convinced, <a href="https://gist.github.com/richdouglasevans/e89b1798820ada6480b6f439d5aca5f2">here&#x2019;s a Gist of the above example</a> to play with.</p>

<p>Next time, we&#x2019;ll look at a very common extension to the idea of semigroups. If you can&#x2019;t wait until then, I actually wrote <a href="/2016/11/03/monoid-est-tonoid/">a blog post on monoids</a> a while back that should help you get a feel before next week.</p>

<p>Finally, another <strong>thank you</strong> to everyone following along. The feedback has been <em>great</em>, and I&#x2019;ve had plenty of questions. Please please <em>please</em> send any my way, via <a href="http://twitter.com/am_i_tom">my Twitter</a> or <a href="http://github.com/i-am-tom">my GitHub</a>, and I&#x2019;ll do what I can to help out.</p>

<p>Keep mooshmashing, and take care &#x2665;</p>

<hr>

<p><em>* I&#x2019;ve given <a href="https://www.youtube.com/watch?v=Sn8uTpySGWA">a lightning talk on monoids</a> in the past, but it&#x2019;s a PHP talk by a younger Tom, so it&#x2019;s all a bit painful to watch, I&#x2019;m afraid!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 16: Extend</h1>
  <span class="post-date">12 Jun 2017</span>
  <p>You&#x2019;re <strong>still</strong> here? That means you survived <code class="language-plaintext highlighter-rouge">Monad</code>! See? Told you it isn&#x2019;t that scary. It&#x2019;s nothing we haven&#x2019;t <strong>already seen</strong>. Well, <em>today</em>, we&#x2019;re going to revisit <code class="language-plaintext highlighter-rouge">Chain</code> with one <em>slight</em> difference. As we know, <code class="language-plaintext highlighter-rouge">Chain</code> takes an <code class="language-plaintext highlighter-rouge">m a</code> to an <code class="language-plaintext highlighter-rouge">m b</code> with some help from an <code class="language-plaintext highlighter-rouge">a -&gt; m b</code> function. It <strong>sequences</strong> our ideas. However, <em>what if I told you</em>&#x2026; we could go <strong>backwards</strong>? Let&#x2019;s <code class="language-plaintext highlighter-rouge">Extend</code> your horizons.</p>

<p>Don&#x2019;t get too excited; the disappointment of <code class="language-plaintext highlighter-rouge">Contravariant</code> will come flooding back! We&#x2019;re certainly not saying that we have a magical <code class="language-plaintext highlighter-rouge">undo</code> for any <code class="language-plaintext highlighter-rouge">Chain</code>. What we <em>are</em> saying, though, is that there are some types for which we can get from <code class="language-plaintext highlighter-rouge">m a</code> to <code class="language-plaintext highlighter-rouge">m b</code> via <code class="language-plaintext highlighter-rouge">m a -&gt; b</code>. Instead of <strong>finishing</strong> in the context, we <strong>start</strong> in it!</p>

<p>Two questions probably come to mind:</p>

<ul>
  <li><strong>How</strong> is this useful?</li>
  <li>&#x2026; See question 1?</li>
</ul>

<p>Well, we&#x2019;ll be answering <strong>at least</strong> one of those questions today! <em>Before</em> that, though, let&#x2019;s go back to our <em>old</em> format and <strong>start</strong> with the <strong>function</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extend</span> <span class="o">::</span> <span class="kt">Extend</span> <span class="n">w</span> <span class="o">=&gt;</span> <span class="n">w</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="p">(</span><span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">w</span> <span class="n">b</span>
</code></pre></div></div>

<blockquote>
  <p>Notice we&#x2019;re using <code class="language-plaintext highlighter-rouge">w</code> here. I kid you <em>not</em>, we use <code class="language-plaintext highlighter-rouge">w</code> because it looks like an upside-down <code class="language-plaintext highlighter-rouge">m</code>, and <code class="language-plaintext highlighter-rouge">m</code> was what we used for <code class="language-plaintext highlighter-rouge">Chain</code>. It&#x2019;s literally there to make the whole thing look <strong>back-to-front</strong> and <strong>upside-down</strong>. I&#x2019;m told that mathematicians call this a <strong>joke</strong>, so do <em>try</em> to laugh!</p>
</blockquote>

<p><em>As we said</em>, it&#x2019;s <code class="language-plaintext highlighter-rouge">Chain</code> going backwards. It even has the same laws backwards! Say hello, once again, to our old friend <strong>associativity</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RHS: Apply to f THEN chain g</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">))</span>

<span class="c1">// RHS: extend f THEN apply to g</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">extend</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">w_</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">w_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>
</code></pre></div></div>

<blockquote>
  <p>Wait, so, if <code class="language-plaintext highlighter-rouge">extend</code> has <strong>associativity</strong>, and if it looks a bit like a <code class="language-plaintext highlighter-rouge">Semigroup</code>&#x2026; (<em>all together now</em>) <strong>where&#x2019;s the <code class="language-plaintext highlighter-rouge">Monoid</code></strong>?!</p>
</blockquote>

<p>It&#x2019;s just like <code class="language-plaintext highlighter-rouge">chain</code>, but backwards. <strong>Everything is backwards</strong>. It&#x2019;s really the only thing you need to remember!</p>

<p><abbr title="Pretty neat, right?">?thgir ,taen ytterP</abbr></p>

<hr>

<p>So, <em>aside</em> from it being backwards, is there anything <em>useful</em> about <code class="language-plaintext highlighter-rouge">Extend</code>? <em>Or</em>, are we just getting a bit tired at this point? <strong>Both</strong>! Hopefully more the former, though&#x2026;</p>

<p>Let&#x2019;s start with an old friend, <a href="/2017/04/27/pairs-as-functors/">the <code class="language-plaintext highlighter-rouge">Pair</code> (or <code class="language-plaintext highlighter-rouge">Writer</code>) type</a>. When we <code class="language-plaintext highlighter-rouge">chain</code>, we have <em>total</em> control over the <strong>output</strong> of our function: we say what we <em>append</em> to the <strong>left-hand side</strong>, and what we want the right-hand value to be. There was, however, one thing we <em>can&#x2019;t</em> do: see what was already <em>in</em> the left part!</p>

<p><code class="language-plaintext highlighter-rouge">Pair</code> really gave us a wonderful way to achieve <strong>write-only</strong> state, but we had no way of <strong>reading</strong> what we&#x2019;d written! Wouldn&#x2019;t it be <strong>great</strong> if we had a <code class="language-plaintext highlighter-rouge">map</code>-like function that let us take a <strong>sneaky peek</strong> at the left-hand side? Something like this, perhaps:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span>  <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1">-- Just like map, but we get a sneaky peek!</span>
<span class="n">sneakyPeekMap</span> <span class="o">::</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
              <span class="o">~&gt;</span> <span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
              <span class="o">-&gt;</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>It&#x2019;s really just like <code class="language-plaintext highlighter-rouge">map</code>, but we get some <strong>context</strong>! Now that we can, whenever we like, take a look at how the left-hand side is doing, we can feed our <strong>hungry adventurer</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Sum represents &quot;hunger&quot;</span>
<span class="kd">const</span> <span class="nx">Adventurer</span> <span class="o">=</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)</span>

<span class="c1">//+ type User = { name :: String, isHungry :: Bool }</span>
<span class="kd">const</span> <span class="nx">exampleUser</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">&apos;</span><span class="s1">Tom</span><span class="dl">&apos;</span><span class="p">,</span>
  <span class="na">isHungry</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// You get the idea... WorkPair again!</span>

<span class="c1">//+ slayDragon :: User -&gt; Adventurer User</span>
<span class="kd">const</span> <span class="nx">slayDragon</span> <span class="o">=</span> <span class="nx">user</span> <span class="o">=&gt;</span>
  <span class="nx">Adventurer</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="nx">user</span><span class="p">)</span>

<span class="c1">//+ slayDragon :: User -&gt; Adventurer User</span>
<span class="kd">const</span> <span class="nx">runFromDragon</span> <span class="o">=</span> <span class="nx">user</span> <span class="o">=&gt;</span>
  <span class="nx">Adventurer</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="nx">user</span><span class="p">)</span>

<span class="c1">//- Eat IF we&apos;re hungry</span>
<span class="c1">//+ eat :: User -&gt; Adventurer User</span>
<span class="kd">const</span> <span class="nx">eat</span> <span class="o">=</span> <span class="nx">user</span> <span class="o">=&gt;</span>
  <span class="nx">user</span><span class="p">.</span><span class="nx">isHungry</span>
  <span class="p">?</span> <span class="nx">Adventurer</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">),</span> <span class="p">{</span>
      <span class="p">...</span> <span class="nx">user</span><span class="p">,</span>
      <span class="na">isHungry</span><span class="p">:</span> <span class="kc">false</span>
    <span class="p">})</span>

  <span class="p">:</span> <span class="nx">Adventurer</span><span class="p">(</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>   <span class="nx">user</span><span class="p">)</span>

<span class="c1">//- How could we know when we&apos;re hungry?</span>
<span class="c1">//- This function goes the other way...</span>
<span class="c1">//+ areWeHungry :: Adventurer User -&gt; User</span>
<span class="kd">const</span> <span class="nx">areWeHungry</span> <span class="o">=</span>
  <span class="p">({</span> <span class="na">_1</span><span class="p">:</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="nx">hunger</span> <span class="p">},</span> <span class="na">_2</span><span class="p">:</span> <span class="nx">user</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="nx">hunger</span> <span class="o">&gt;</span> <span class="mi">200</span>
      <span class="p">?</span> <span class="p">{</span> <span class="p">...</span> <span class="nx">user</span><span class="p">,</span> <span class="na">isHungry</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span>
      <span class="p">:</span> <span class="nx">user</span>

<span class="c1">// Now, we do a thing, check our hunger,</span>
<span class="c1">// and eat if we need to!</span>

<span class="c1">// WE ARE SELF-AWARE.</span>
<span class="c1">// SKYNET</span>

<span class="nx">slayDragon</span><span class="p">(</span><span class="nx">exampleUser</span><span class="p">)</span>
<span class="p">.</span><span class="nx">sneakyPeekMap</span><span class="p">(</span><span class="nx">areWeHungry</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">eat</span><span class="p">)</span>
<span class="c1">// Pair(Sum(100), not hungry)</span>

<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">slayDragon</span><span class="p">)</span>
<span class="p">.</span><span class="nx">sneakyPeekMap</span><span class="p">(</span><span class="nx">areWeHungry</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">eat</span><span class="p">)</span>
<span class="c1">// Pair(Sum(200), not hungry)</span>

<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">runFromDragon</span><span class="p">)</span>
<span class="p">.</span><span class="nx">sneakyPeekMap</span><span class="p">(</span><span class="nx">areWeHungry</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">eat</span><span class="p">)</span>
<span class="c1">// Pair(Sum(150), not hungry)!</span>
</code></pre></div></div>

<p>Just with this <code class="language-plaintext highlighter-rouge">sneakyPeekMap</code>, we can now inspect our character stats and feed that <em>back</em> into our actions. This is <em>so</em> neat: any time you want to update one piece of data depending on another, <code class="language-plaintext highlighter-rouge">sneakyPeekMap</code> is <strong>exactly</strong> what you need. Oh, and by the way, it has a much more common name: <code class="language-plaintext highlighter-rouge">extend</code>!</p>

<hr>

<p><em>So, can I just think of <code class="language-plaintext highlighter-rouge">extend</code> as <code class="language-plaintext highlighter-rouge">sneakyPeekMap</code>?</em> I mean, you basically can; that intuition will get you a <strong>long</strong> way. As an homage to <a href="https://joneshf.github.io/programming/2015/12/31/Comonads-Monoids-and-Trees.html">Hardy Jones&#x2019; functional pearl</a>, let&#x2019;s build a <a href="https://en.wikipedia.org/wiki/Rose_Tree"><strong>Rose Tree</strong></a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- A root and a list of children!</span>
<span class="c1">//+ type RoseTree a = (a, [RoseTree a])</span>
<span class="kd">const</span> <span class="nx">RoseTree</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span>
  <span class="dl">&apos;</span><span class="s1">RoseTree</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">root</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">forest</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p><em>Maybe</em>, you looked at that type and a little voice in the back of your mind said <code class="language-plaintext highlighter-rouge">Functor</code>. If so, <strong>kudos</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">RoseTree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">RoseTree</span><span class="p">(</span>
    <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">),</span> <span class="c1">// Transform the root...</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="c1">// and other trees.</span>
      <span class="nx">rt</span> <span class="o">=&gt;</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>No problem</strong>; transform the root node, and then <em>recursively</em> map over all the child trees. <strong>Bam</strong>. <em>Now</em>, imagine if we wanted to <em>colour</em> this tree&#x2019;s nodes depending on how many <strong>children</strong> they each have. Sounds like we&#x2019;d need to take&#x2026; a <strong>sneaky peek</strong>!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ extend :: RoseTree a</span>
<span class="c1">//+        ~&gt; (RoseTree a -&gt; b)</span>
<span class="c1">//+        -&gt; RoseTree b</span>
<span class="nx">RoseTree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">RoseTree</span><span class="p">(</span>
      <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">rt</span> <span class="o">=&gt;</span>
        <span class="nx">rt</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// Now, it&apos;s super easy to do this!</span>
<span class="nx">MyTree</span><span class="p">.</span><span class="nx">extend</span><span class="p">(({</span> <span class="nx">root</span><span class="p">,</span> <span class="nx">forest</span> <span class="p">})</span> <span class="o">=&gt;</span>
  <span class="nx">forest</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span>
    <span class="p">?</span> <span class="p">{</span> <span class="p">...</span> <span class="nx">root</span><span class="p">,</span> <span class="na">colour</span><span class="p">:</span> <span class="dl">&apos;</span><span class="s1">RED</span><span class="dl">&apos;</span> <span class="p">}</span>
    <span class="p">:</span> <span class="nx">forest</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">5</span>
      <span class="p">?</span> <span class="p">{</span> <span class="p">...</span> <span class="nx">root</span><span class="p">,</span> <span class="na">colour</span><span class="p">:</span> <span class="dl">&apos;</span><span class="s1">ORANGE</span><span class="dl">&apos;</span> <span class="p">}</span>
      <span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="nx">root</span><span class="p">,</span> <span class="na">colour</span><span class="p">:</span> <span class="dl">&apos;</span><span class="s1">GREEN</span><span class="dl">&apos;</span> <span class="p">})</span>
</code></pre></div></div>

<p>With our new-found <strong>superpower</strong>, each node gets to pretend to be the <strong>one in charge</strong>, and can watch over their own forests. The trees in those forests then do the same, and so on, until we <code class="language-plaintext highlighter-rouge">map</code>-with-a-sneaky-peek <strong>the entire forest</strong>! Again, I linked to Hardy&#x2019;s article above, which contains a much <strong>deeper</strong> dive into trees specifically; combining <code class="language-plaintext highlighter-rouge">RoseTree</code> with Hardy&#x2019;s ideas is enough to make your own <strong>billion-dollar React clone</strong>!</p>

<hr>

<p>Let&#x2019;s cast our minds <em>waaay</em> back to <a href="/2017/03/09/fantas-eel-and-specification-3/">the Setoid post</a>, when we looked at <code class="language-plaintext highlighter-rouge">List</code>. List, it turns out, is a <code class="language-plaintext highlighter-rouge">Functor</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- Usually, if you can write something for</span>
<span class="c1">//- Array, you can write it for List!</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="c1">// Do nothing, we&apos;re done!</span>
    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Nil</span><span class="p">,</span>

    <span class="c1">// Transform head, recurse on tail</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">Cons</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">head</span><span class="p">),</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// e.g. Cons(1, Cons(2, Nil))</span>
<span class="c1">//      .map(x =&gt; x + 1)</span>
<span class="c1">// === Cons(2, Cons(3, Nil))</span>
</code></pre></div></div>

<p>Now, for this <strong>convoluted example</strong>, let&#x2019;s imagine we have some weather data for the last few days:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arrayToList</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">xs</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="nx">Nil</span>

  <span class="kd">const</span> <span class="p">[</span> <span class="nx">head</span><span class="p">,</span> <span class="p">...</span> <span class="nx">tail</span> <span class="p">]</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">return</span> <span class="nx">Cons</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">arrayToList</span><span class="p">(</span><span class="nx">tail</span><span class="p">))</span>
<span class="p">}</span>

<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toArray</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">([</span>
      <span class="nx">head</span><span class="p">,</span> <span class="p">...</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">toArray</span><span class="p">()</span>
    <span class="p">]),</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Starting from today... (in celsius!)</span>
<span class="kd">const</span> <span class="nx">temperatures</span> <span class="o">=</span> <span class="nx">arrayToList</span><span class="p">(</span>
  <span class="p">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">])</span>
</code></pre></div></div>

<p>What we want to do is <code class="language-plaintext highlighter-rouge">map</code> over this list to determine whether the temperature has been warmer or cooler than the day before! To do that, we&#x2019;ll probably need to do <em>something</em> sneakily&#x2026; any ideas?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ List a ~&gt; (List a -&gt; b) -&gt; List b</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="c1">// Extend the list, repeat on tail.</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Cons</span><span class="p">(</span>
      <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">),</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Nil</span> <span class="c1">// We&apos;re done!</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// [YAY, YAY, YAY, YAY, BOO, BOO, ???]</span>
<span class="nx">temperatures</span>
<span class="p">.</span><span class="nx">extend</span><span class="p">(({</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="p">})</span> <span class="o">=&gt;</span>
  <span class="nx">tail</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">???</span><span class="dl">&apos;</span>
                   <span class="p">:</span> <span class="nx">head</span> <span class="o">&lt;</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">head</span>
                     <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">BOO</span><span class="dl">&apos;</span> <span class="p">:</span> <span class="dl">&apos;</span><span class="s1">YAY</span><span class="dl">&apos;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">toArray</span><span class="p">()</span>
</code></pre></div></div>

<p>We only used the <em>head</em> of the tail this time, but we could use the whole thing if we wanted! We have the entire thing available to peek sneakily.</p>

<blockquote>
  <p>For example, we could use this technique for lap times to record whether they&#x2019;re <strong>faster or slower</strong> than the <strong>average</strong> so far! <strong>Have a go!</strong></p>
</blockquote>

<p>As we said, we can mimic the same behaviour for <code class="language-plaintext highlighter-rouge">Array</code> to save us all the to-and-fro with <code class="language-plaintext highlighter-rouge">List</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">[]</span>

  <span class="kd">const</span> <span class="p">[</span> <span class="nx">_</span><span class="p">,</span> <span class="p">...</span> <span class="nx">tail</span> <span class="p">]</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">return</span> <span class="p">[</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="p">...</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">]</span>
<span class="p">}</span>

<span class="c1">// Now, we can use array-destructuring :)</span>
<span class="p">;[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">].</span><span class="nx">extend</span><span class="p">(</span>
  <span class="p">([</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span> <span class="nx">tail</span><span class="p">])</span> <span class="o">=&gt;</span>
    <span class="nx">tail</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">???</span><span class="dl">&apos;</span>
    <span class="p">:</span> <span class="nx">head</span> <span class="o">&lt;</span> <span class="nx">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">BOO</span><span class="dl">&apos;</span> <span class="p">:</span> <span class="dl">&apos;</span><span class="s1">YAY</span><span class="dl">&apos;</span><span class="p">)</span>
</code></pre></div></div>

<hr>

<p>I brought these examples up for a reason, Fantasists. <em>Often</em>, <code class="language-plaintext highlighter-rouge">extend</code> isn&#x2019;t just <code class="language-plaintext highlighter-rouge">f =&gt; W.of(f(this))</code> for some <code class="language-plaintext highlighter-rouge">W</code> type; that&#x2019;s what <code class="language-plaintext highlighter-rouge">of</code> is for! <code class="language-plaintext highlighter-rouge">extend</code> is about being able to <code class="language-plaintext highlighter-rouge">map</code> while being aware of the surrounding <strong>construct</strong>.</p>

<p>Think of it like this: when we used <code class="language-plaintext highlighter-rouge">Chain</code>, we had total <strong>write</strong> access to the <strong>output</strong> <em>constructor</em> and <em>values</em>. We could turn <code class="language-plaintext highlighter-rouge">Just</code> into <code class="language-plaintext highlighter-rouge">Nothing</code>, we could fail a <code class="language-plaintext highlighter-rouge">Task</code>, and we could even change the length of an <code class="language-plaintext highlighter-rouge">Array</code>. <strong>Truly, we were powerful</strong>.</p>

<p>With <code class="language-plaintext highlighter-rouge">Extend</code>, we get full <strong>read</strong> access to the <strong>input</strong> <em>constructor</em> and <em>values</em>. It&#x2019;s the <strong>opposite idea</strong>.</p>

<p>Whereas <code class="language-plaintext highlighter-rouge">Chain</code> lets us <strong>inform the future</strong> of the computation, <code class="language-plaintext highlighter-rouge">Extend</code> lets us <strong>be informed by the past</strong>. <em>This is the kind of sentence that ends up on a mug, you know!</em></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- chain: `map` with write-access to output</span>
<span class="c1">-- extend: `map` with read-access to input</span>

<span class="n">map</span>    <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span>  <span class="n">a</span> <span class="o">-&gt;</span>   <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="n">chain</span>  <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span>  <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="n">extend</span> <span class="o">::</span> <span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">w</span> <span class="n">a</span> <span class="o">-&gt;</span>   <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">w</span> <span class="n">b</span>
</code></pre></div></div>

<hr>

<p>There are lots of cool examples of <code class="language-plaintext highlighter-rouge">Extend</code>, but they are often overlooked and generally considered a more &#x201C;advanced&#x201D; topic. After all, with <code class="language-plaintext highlighter-rouge">Monad</code>, we&#x2019;re free to build <strong>anything</strong>; why bother continuing? Well, I hope this gives you an idea of how they work and where you can find them! After all, these are all just <strong>design patterns</strong>: just use them when they&#x2019;re <strong>appropriate</strong>!</p>

<p><em>So, <code class="language-plaintext highlighter-rouge">Semigroup</code> is to <code class="language-plaintext highlighter-rouge">Monoid</code> as <code class="language-plaintext highlighter-rouge">Chain</code> is to <code class="language-plaintext highlighter-rouge">Monad</code> as <code class="language-plaintext highlighter-rouge">Extend</code> is to&#x2026;?</em> We&#x2019;ll find out next time! Before we go, though, here&#x2019;s a very tricky challenge to keep you busy:</p>

<blockquote>
  <p>With <code class="language-plaintext highlighter-rouge">Writer</code>, we needed a <code class="language-plaintext highlighter-rouge">Semigroup</code> on the left to make a <code class="language-plaintext highlighter-rouge">Chain</code> instance, but we didn&#x2019;t for <code class="language-plaintext highlighter-rouge">Extend</code>. <code class="language-plaintext highlighter-rouge">Reader</code> has an <code class="language-plaintext highlighter-rouge">Extend</code> instance; can you think of how we might write that?</p>
</blockquote>

<p>Until then, take a look through <a href="https://gist.github.com/richdouglasevans/61eae2a787bd616f04e63a642a0dca5d">this article&#x2019;s code</a>, and take care!</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 14: ChainRec</h1>
  <span class="post-date">30 May 2017</span>
  <p><strong>Happy Tuesday</strong>, Fantasists! Sorry for the wait; I&#x2019;ve been chasing around <a href="https://github.com/fantasyland/fantasy-land/issues/250">an issue to change this entry</a>! No movement on that yet, so let&#x2019;s <strong>soldier on</strong>! We&#x2019;ve seen that <code class="language-plaintext highlighter-rouge">chain</code> allows us to <strong>sequence</strong> our actions, which means we can now do pretty much <strong>anything we want</strong>! As fellow JavaScripters, this is of course the time we get cynical; it can&#x2019;t be <em>that</em> simple, right? <strong>Absolutely not</strong>, and let&#x2019;s take a look at a <strong>convoluted example</strong> to show us why!</p>

<p>Have a gander at this little number, which emulates the behaviour of the UNIX <code class="language-plaintext highlighter-rouge">seq</code> command, with the help of <a href="/2017/04/27/pairs-as-functors/">our old friend <code class="language-plaintext highlighter-rouge">Pair</code></a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Click the above link for a full</span>
<span class="c1">// explanation of this type!</span>
<span class="kd">const</span> <span class="nx">Writer</span> <span class="o">=</span> <span class="nx">Pair</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span>

<span class="c1">//+ seq :: Int -&gt; Writer [Int] Int</span>
<span class="kd">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">upper</span> <span class="o">=&gt;</span> <span class="p">{</span>

  <span class="c1">//+ seq_ :: Int -&gt; Writer [Int] Int</span>
  <span class="kd">const</span> <span class="nx">seq_</span> <span class="o">=</span> <span class="nx">init</span> <span class="o">=&gt;</span>
    <span class="nx">init</span> <span class="o">&gt;=</span> <span class="nx">upper</span>

    <span class="c1">// If we&apos;re done, stop here!</span>
    <span class="p">?</span> <span class="nx">Writer</span><span class="p">([</span><span class="nx">init</span><span class="p">],</span> <span class="nx">upper</span><span class="p">)</span>

    <span class="c1">// If we&apos;re not...</span>
    <span class="p">:</span> <span class="nx">Writer</span><span class="p">([</span><span class="nx">init</span><span class="p">],</span> <span class="nx">init</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">seq_</span><span class="p">)</span> <span class="c1">// ...chain(seq_)!</span>

  <span class="c1">// Kick everything off</span>
  <span class="k">return</span> <span class="nx">seq_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">seq</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nx">_1</span> <span class="c1">// [1, 2, 3, 4, 5]</span>
</code></pre></div></div>

<p>Everything looks <strong>fine</strong> so far: <code class="language-plaintext highlighter-rouge">seq_</code> is just a <strong>recursive</strong> function. Until <code class="language-plaintext highlighter-rouge">init</code> exceeds <code class="language-plaintext highlighter-rouge">upper</code>, we <strong>log</strong> the current value and call <code class="language-plaintext highlighter-rouge">seq_</code> on the <strong>next</strong> integer. Pick any number and see that it works: <code class="language-plaintext highlighter-rouge">10</code>, <code class="language-plaintext highlighter-rouge">100</code>, <code class="language-plaintext highlighter-rouge">1000</code>, &#x2026; <strong>oh</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; seq(10000)._1
RangeError: Maximum call stack size exceeded
</code></pre></div></div>

<p>Now, we&#x2019;re supposedly using <strong>computers</strong>. They take people to the <strong>moon</strong>, control <strong>nuclear reactors</strong>, and get us <strong>pictures of cats</strong>; <em>surely</em> it&#x2019;s not too big an ask to count to <code class="language-plaintext highlighter-rouge">10000</code> without exploding?</p>

<p>Our problem here is that, every time we <code class="language-plaintext highlighter-rouge">chain(seq_)</code>, we store the <em>calling</em> function&#x2019;s local state on the <strong>stack</strong> until the <em>called</em> function returns; as you can imagine, it&#x2019;s actually pretty expensive to save <strong>ten thousand</strong> of these states. When we fill up the stack and try to carry on, we cause a <strong>stack overflow</strong> error. <em>If only there were some website to help us&#x2026;</em></p>

<p><em>Typically</em>, in our non-functional JavaScript, we get round this problem with a <strong>loop</strong>. It&#x2019;s no secret that we could write <code class="language-plaintext highlighter-rouge">seq</code> as:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">upper</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">acc</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">upper</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">acc</span>
<span class="p">}</span>

<span class="nx">seq</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="c1">// Bam, no trouble</span>
</code></pre></div></div>

<p>See? <strong>No stack overflow</strong>; we use <code class="language-plaintext highlighter-rouge">acc</code> to store our state at each point <strong>explicitly</strong>, without recursion, and everything just works&#x2026; so, have we been <strong>defeated</strong>? Do we <em>really</em> have to choose between <strong>prettiness</strong> - purity, composition, etc. - and <strong>performance</strong>?</p>

<hr>

<p><strong>Never</strong>! We&#x2019;re <strong>functional programmers</strong>; we solve these problems with <strong>abstraction</strong>, and <code class="language-plaintext highlighter-rouge">ChainRec</code> turns out to be <em>exactly</em> what we need. We&#x2019;re going to start off with a slightly different definition of this spec&#x2019;s function, and work towards the real one. First of all, we&#x2019;ll introduce a <strong>new type</strong>, <code class="language-plaintext highlighter-rouge">Step</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// type Step b a = Done b | Loop a</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">Loop</span><span class="p">,</span> <span class="nx">Done</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">taggedSum</span><span class="p">({</span>
  <span class="na">Done</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">],</span> <span class="na">Loop</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>We&#x2019;re using these two constructors to mimic the two possible states of our imperative solution: are we <code class="language-plaintext highlighter-rouge">Done</code>, or do we still need to <code class="language-plaintext highlighter-rouge">Loop</code>?</p>

<blockquote>
  <p>We <em>could</em> make this a <code class="language-plaintext highlighter-rouge">Functor</code> over <code class="language-plaintext highlighter-rouge">a</code>, but we don&#x2019;t need to; still, it&#x2019;s an <strong>exercise</strong> if you&#x2019;re looking!</p>
</blockquote>

<p>With that in mind, let&#x2019;s define <code class="language-plaintext highlighter-rouge">chainRec</code>. Remember here that all <code class="language-plaintext highlighter-rouge">ChainRec</code> types are also <code class="language-plaintext highlighter-rouge">Chain</code> types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chainRec</span> <span class="o">::</span> <span class="kt">ChainRec</span> <span class="n">m</span>
         <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Step</span> <span class="n">b</span> <span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
         <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>Well, well, well. We start off with a function of type <code class="language-plaintext highlighter-rouge">a -&gt; m (Step b a)</code>, and a value of type <code class="language-plaintext highlighter-rouge">a</code>. We end up with <code class="language-plaintext highlighter-rouge">m b</code>. I reckon the first step is probably to <em>call</em> that function, and end up with <code class="language-plaintext highlighter-rouge">m (Step b a)</code>. When we&#x2019;ve done that, we&#x2019;ll be in one of two situations:</p>

<ul>
  <li>
    <p>That <code class="language-plaintext highlighter-rouge">Step b a</code> will be a <code class="language-plaintext highlighter-rouge">Done b</code>, and we can pull out the <code class="language-plaintext highlighter-rouge">b</code> (by mapping over the <code class="language-plaintext highlighter-rouge">m</code>) and return the answer!</p>
  </li>
  <li>
    <p>That <code class="language-plaintext highlighter-rouge">Step b a</code> will be a <code class="language-plaintext highlighter-rouge">Loop a</code>, and we still don&#x2019;t have a <code class="language-plaintext highlighter-rouge">b</code> to make the answer. What do we do then? We <strong>loop again</strong>!</p>
  </li>
</ul>

<p>We <code class="language-plaintext highlighter-rouge">chain</code> our starter function to our <code class="language-plaintext highlighter-rouge">m a</code>, and repeat this whole process until we finally get a <code class="language-plaintext highlighter-rouge">Done</code> value, and we can <strong>finish up</strong>!</p>

<p>This might be a little <strong>heavy</strong>, so let&#x2019;s implement <code class="language-plaintext highlighter-rouge">chainRec</code> for our <code class="language-plaintext highlighter-rouge">Writer</code> type to clear it up:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We need a TypeRep for the left bit!</span>
<span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Pair_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">_1</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">_2</span><span class="dl">&apos;</span><span class="p">)</span>

  <span class="c1">// ...</span>

  <span class="c1">//+ chainRec</span>
  <span class="c1">//+   :: Monoid m</span>
  <span class="c1">//+   =&gt; (a -&gt; Pair m (Step b a), a)</span>
  <span class="c1">//+   -&gt; (m, b)</span>
  <span class="nx">Pair_</span><span class="p">.</span><span class="nx">chainRec</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Start off &quot;empty&quot;</span>
    <span class="kd">let</span> <span class="nx">acc</span> <span class="o">=</span> <span class="nx">T</span><span class="p">.</span><span class="nx">empty</span><span class="p">()</span>

    <span class="c1">// We have to loop at least once</span>
      <span class="p">,</span> <span class="nx">step</span> <span class="o">=</span> <span class="nx">Loop</span><span class="p">(</span><span class="nx">init</span><span class="p">)</span>

    <span class="k">do</span> <span class="p">{</span>
      <span class="c1">// Call `f` on `Loop`&apos;s value</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>

      <span class="c1">// Update the accumulator,</span>
      <span class="c1">// as well as the current value</span>
      <span class="nx">acc</span>  <span class="o">=</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">_1</span><span class="p">)</span>
      <span class="nx">step</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">_2</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">step</span> <span class="k">instanceof</span> <span class="nx">Loop</span><span class="p">)</span>

    <span class="c1">// Pull out the `Done` value.</span>
    <span class="k">return</span> <span class="nx">Pair_</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">step</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We store our <code class="language-plaintext highlighter-rouge">acc</code>, starting with the &#x201C;empty&#x201D; value for that <code class="language-plaintext highlighter-rouge">Monoid</code>, and update it with every loop. This continues until we hit a <code class="language-plaintext highlighter-rouge">Done</code>, when we make a pair with the final <code class="language-plaintext highlighter-rouge">acc</code> and the value inside the <code class="language-plaintext highlighter-rouge">Done</code>!</p>

<p>It might take a couple read-throughs, but see what&#x2019;s happened: instead of doing <strong>recursion</strong>, we&#x2019;ve used <code class="language-plaintext highlighter-rouge">Step</code> to let a function <em>tell us</em> when it <em>wants</em> to recurse. With that extra bit of <strong>abstraction</strong>, we can hide a <code class="language-plaintext highlighter-rouge">while</code> loop under the hood, and no one will be any the wiser!</p>

<p>So, with all this talk of <strong>accumulated results</strong>, let&#x2019;s get back to that <code class="language-plaintext highlighter-rouge">seq</code> example, and see what we can do:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ seqRec :: Int -&gt; ([Int], Int)</span>
<span class="kd">const</span> <span class="nx">seqRec</span> <span class="o">=</span> <span class="nx">upper</span> <span class="o">=&gt;</span> <span class="nx">Writer</span><span class="p">.</span><span class="nx">chainRec</span><span class="p">(</span>
  <span class="nx">init</span> <span class="o">=&gt;</span> <span class="nx">Writer</span><span class="p">([</span><span class="nx">init</span><span class="p">],</span>
    <span class="nx">init</span> <span class="o">&gt;=</span> <span class="nx">upper</span> <span class="p">?</span> <span class="nx">Done</span><span class="p">(</span><span class="nx">init</span><span class="p">)</span>
                  <span class="p">:</span> <span class="nx">Loop</span><span class="p">(</span><span class="nx">init</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
  <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>Look at the <strong>body</strong>: there&#x2019;s no recursion! We&#x2019;ve abstracted all the recursion into <code class="language-plaintext highlighter-rouge">chainRec</code>, which can do its <strong>sneaky optimisation</strong>. All <em>we</em> say in our <code class="language-plaintext highlighter-rouge">chainRec</code>-using function is whether we&#x2019;re <code class="language-plaintext highlighter-rouge">Done</code> or still need to <code class="language-plaintext highlighter-rouge">Loop</code> - isn&#x2019;t that <strong>clearer</strong>? What&#x2019;s more, it&#x2019;s now totally <strong>stack-safe</strong>!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; seqRec(100000)._1
[1, 2, 3, 4, 5, ...]
</code></pre></div></div>

<p>Just a tiny little extra abstraction and we <strong>scoff</strong> at numbers like <code class="language-plaintext highlighter-rouge">10000</code>. Why stop the momentum? Next stop: <strong>cat pictures on the moon</strong>.</p>

<hr>

<p>Now, we haven&#x2019;t quite matched the spec, but you&#x2019;ll see why. The actual spec gives us no <code class="language-plaintext highlighter-rouge">Step</code> type, which means we end up with the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chainRec</span> <span class="o">::</span> <span class="kt">ChainRec</span> <span class="n">m</span>
         <span class="o">=&gt;</span> <span class="p">((</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
         <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>Now, I have a few problems with this definition, most of which are outlined in <a href="https://github.com/fantasyland/fantasy-land/issues/250">the aforementioned GitHub issue</a>, so we won&#x2019;t go into them too much. What we&#x2019;ll do <em>instead</em> is define a function to turn our <code class="language-plaintext highlighter-rouge">Step</code>-based functions into <strong>spec-compliant</strong> functions. It&#x2019;s a little number I like to call <code class="language-plaintext highlighter-rouge">trainwreck</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ trainwreck</span>
<span class="c1">//+  :: Functor m</span>
<span class="c1">//+  =&gt; (a -&gt; m (Step b a))</span>
<span class="c1">//+  -&gt; ((a -&gt; c, b -&gt; c, a) -&gt; m c)</span>
<span class="kd">const</span> <span class="nx">trainwreck</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span>
  <span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">init</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span>
    <span class="nx">step</span> <span class="o">=&gt;</span> <span class="nx">step</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">Loop</span><span class="p">:</span> <span class="nx">next</span><span class="p">,</span> <span class="na">Done</span><span class="p">:</span> <span class="nx">done</span>
    <span class="p">})</span>
  <span class="p">)</span>

<span class="c1">// Or, with ES6 and polymorphic names...</span>
<span class="kd">const</span> <span class="nx">trainwreck</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">Loop</span><span class="p">,</span> <span class="nx">Done</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span> <span class="nx">Loop</span><span class="p">,</span> <span class="nx">Done</span> <span class="p">}))</span>
</code></pre></div></div>

<p>With this cheeky thing, we can get the best of both worlds; we just wrap our definition of <code class="language-plaintext highlighter-rouge">Pair_.prototype.chainRec</code> in the <code class="language-plaintext highlighter-rouge">trainwreck</code> function and it&#x2019;s good to go! Whether you choose to implement <code class="language-plaintext highlighter-rouge">chainRec</code> on your types with the <code class="language-plaintext highlighter-rouge">trainwreck-Step</code> approach or with the spec&#x2019;s approach is up to you, but I think it&#x2019;s pretty clear that I have a <strong>favourite</strong>!</p>

<blockquote>
  <p>Interestingly, the <em>spec&#x2019;s</em> (more formal) encoding is based on the <a href="http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">Boehm-Berarducci</a> encoding of the <code class="language-plaintext highlighter-rouge">Step</code> type; hat-tip to <a href="https://twitter.com/puffnfresh">Brian McKenna</a> for this one, as I&#x2019;d <strong>never</strong> heard of this!</p>
</blockquote>

<hr>

<p>Last and certainly not least: the <strong>laws</strong>. Wait, you didn&#x2019;t think I&#x2019;d forgotten, did you? <strong>Ha</strong>! We&#x2019;ll define these with <code class="language-plaintext highlighter-rouge">Step</code> to make them a bit more <strong>expressive</strong>, but <a href="https://github.com/fantasyland/fantasy-land#chainrec">the original definitions</a> are of course available on the spec.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For some ChainRec m, predicate p,</span>
<span class="c1">// and some M-returning d and n...</span>
<span class="nx">M</span><span class="p">.</span><span class="nx">chainRec</span><span class="p">(</span>
  <span class="nx">trainwreck</span><span class="p">(</span>
    <span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">d</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">Done</span><span class="p">)</span>
              <span class="p">:</span> <span class="nx">n</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">Next</span><span class="p">)),</span>
  <span class="nx">i</span><span class="p">)</span>

<span class="c1">// Must behave the same as...</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">step</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">d</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
              <span class="p">:</span> <span class="nx">n</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">step</span><span class="p">)</span>
<span class="p">}(</span><span class="nx">i</span><span class="p">))</span>
</code></pre></div></div>

<p>By now, we&#x2019;ve seen the <em>actual</em> difference: the second one will explode before we get anywhere <em>close</em> to the moon. However, in <em>theory</em> (assuming we had an <strong>infinite stack</strong>), these two expressions would always end up at the same point. Again, we&#x2019;re just asserting that <code class="language-plaintext highlighter-rouge">Done</code> and <code class="language-plaintext highlighter-rouge">Next</code> provide an <strong>abstraction</strong> for our recursion.</p>

<p>The other law, which is one of my <em>favourites</em>, is that <code class="language-plaintext highlighter-rouge">chainRec(f)</code> must produce a stack no larger than <code class="language-plaintext highlighter-rouge">n</code> times <code class="language-plaintext highlighter-rouge">f</code>&#x2019;s stack usage, for some <strong>constant</strong> <code class="language-plaintext highlighter-rouge">n</code>. In other words, whether I&#x2019;m looping once or a million times, the stack <strong>must not keep growing</strong>. With this wordy little law, we <strong>ensure</strong> stack safety.</p>

<p>The <code class="language-plaintext highlighter-rouge">ChainRec</code> spec is best-suited towards ideas like <a href="https://github.com/safareli/free">Free structures</a> and <a href="https://github.com/fluture-js/fluture">asynchronous looping</a>: when we could end up with a <em>very</em> complicated structure, <code class="language-plaintext highlighter-rouge">chainRec</code> makes sure we don&#x2019;t hit an unexpected ceiling.</p>

<p>In your day-to-day coding, it&#x2019;s probably not something you&#x2019;ll see an awful lot. In fact, it usually tends to be hidden in implementation detail, rather than being exposed to the user. Stick to the simple, <strong>golden rule</strong>: when <code class="language-plaintext highlighter-rouge">Chain</code> blows your stack, <code class="language-plaintext highlighter-rouge">ChainRec</code> is there to solve the problem. Every <code class="language-plaintext highlighter-rouge">Chain</code> type can implement <code class="language-plaintext highlighter-rouge">ChainRec</code>, so this will <em>always</em> be an available option!</p>

<p>Whether we use it regularly or not, we now have a practical, stack-safe, and <strong>functional</strong> answer to the danger of <code class="language-plaintext highlighter-rouge">chain</code>ing huge computations. We can <strong>sequence</strong> instructions safely, build up large computations, and then <strong>let &#x2018;em rip</strong>.</p>

<p>Next time, we&#x2019;ll look at the <strong>last piece of the puzzle</strong>, and charge through some examples. Brace yourself for the <em>terrifying</em>, <em>incomprehensible</em>, and <em>downright impolite</em> <code class="language-plaintext highlighter-rouge">Monad</code>! Trust me: it&#x2019;s actually <strong>none</strong> of those things. In fact, it&#x2019;s nothing new at all - <strong>rest easy</strong>, Fantasists!</p>

<p>&#x2665;</p>

<p>As usual, feel free to play with <a href="https://gist.github.com/richdouglasevans/4c0a197c3d8312961a1c7fba557f4425">the post&#x2019;s code gist</a> to experiment further!</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 13: Chain</h1>
  <span class="post-date">15 May 2017</span>
  <p><em>You told me to <strong>leave you alone</strong>. My Papa said, &#x201C;<strong>Come on home</strong>&#x201D;. My doctor said, &#x201C;<strong>Take it easy</strong>&#x201D;, but your lovin&#x2019; is <strong>much too strong</strong>. I&#x2019;m added to your&#x2026; <code class="language-plaintext highlighter-rouge">Chain</code>, <code class="language-plaintext highlighter-rouge">Chain</code>, <code class="language-plaintext highlighter-rouge">Chain</code></em>! Maybe we didn&#x2019;t compose <em>that</em> one, but we&#x2019;re going to <code class="language-plaintext highlighter-rouge">compose</code> plenty of things today!</p>

<p>Let&#x2019;s take a moment to recap a few previous posts. When <a href="/2017/03/27/fantas-eel-and-specification-6/">we covered <code class="language-plaintext highlighter-rouge">Functor</code></a>, we saw that functors created <strong>contexts</strong> in which our &#x201C;language&#x201D; could be <strong>extended</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>        <span class="c1">-- Multiple results</span>
<span class="n">m</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>    <span class="c1">-- Possible failure</span>
<span class="n">e</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="n">e</span> <span class="n">b</span> <span class="c1">-- Possible exception</span>
<span class="n">t</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Task</span> <span class="n">e</span> <span class="n">b</span>   <span class="c1">-- Async action</span>
</code></pre></div></div>

<p>We&#x2019;ve also seen that <a href="/2017/04/10/fantas-eel-and-specification-8/"><code class="language-plaintext highlighter-rouge">Applicative</code> functors</a>&#x2019; contexts can be <strong>combined</strong> to give us cool tricks like parallel <code class="language-plaintext highlighter-rouge">Task</code> actions and <a href="/2017/05/08/fantas-eel-and-specification-12/"><code class="language-plaintext highlighter-rouge">Traversable</code></a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Just([-1, -2, -3])</span>
<span class="p">;[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">Maybe</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Just</span><span class="p">(</span><span class="o">-</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">// Logs 50 (after only 2000ms!)</span>
<span class="nx">lift2</span><span class="p">(</span>
  <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span>

  <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">setTimeout</span><span class="p">(</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
      <span class="mi">2000</span><span class="p">)),</span>

  <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">setTimeout</span><span class="p">(</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
      <span class="mi">1000</span><span class="p">)))</span>
<span class="p">.</span><span class="nx">fork</span><span class="p">(</span>
  <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">???</span><span class="dl">&apos;</span><span class="p">),</span>
  <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</code></pre></div></div>

<p>There&#x2019;s one thing we <em>can&#x2019;t</em> do, though. What if we want to <code class="language-plaintext highlighter-rouge">compose</code> two <code class="language-plaintext highlighter-rouge">Functor</code>-returning functions? Take a look at this example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ prop :: String -&gt; StrMap a -&gt; Maybe a</span>
<span class="kd">const</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span>
  <span class="nx">k</span> <span class="k">in</span> <span class="nx">xs</span> <span class="p">?</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">xs</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
          <span class="p">:</span> <span class="nx">Nothing</span>

<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

<span class="c1">// How do we get to the 2?</span>
<span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// Just({ b: { c: 2 } })</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">))</span> <span class="c1">// Just(Just({ c: 2 }))</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">)))</span> <span class="c1">// Just(Just(Just(2)))</span>

<span class="c1">// And if we fail?</span>
<span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// Just({ b: { c: 2 }})</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">badger</span><span class="dl">&apos;</span><span class="p">))</span> <span class="c1">// Just(Nothing)</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">)))</span> <span class="c1">// Just(Nothing)</span>
</code></pre></div></div>

<p>So, we <strong>can</strong> get to the <code class="language-plaintext highlighter-rouge">2</code>, but not without a lot of <strong>mess</strong>. We <code class="language-plaintext highlighter-rouge">map</code> more and more each time, when all we <em>really</em> want is a <code class="language-plaintext highlighter-rouge">Just 2</code> if it works and a <code class="language-plaintext highlighter-rouge">Nothing</code> if it doesn&#x2019;t. What we&#x2019;re missing is a way to <strong>flatten</strong> layers of <code class="language-plaintext highlighter-rouge">Maybe</code>. Enter <code class="language-plaintext highlighter-rouge">join</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ join :: Maybe (Maybe a) ~&gt; Maybe a</span>
<span class="nx">Maybe</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Just</span><span class="p">:</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">,</span>
    <span class="na">Nothing</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Nothing</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// Just({ b: { c: 2 } })</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">)).</span><span class="nx">join</span><span class="p">()</span> <span class="c1">// Just({ c: 2 })</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">)).</span><span class="nx">join</span><span class="p">()</span> <span class="c1">// Just(2)</span>

<span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// Just({ b: { c: 2 } })</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">badger</span><span class="dl">&apos;</span><span class="p">)).</span><span class="nx">join</span><span class="p">()</span> <span class="c1">// Nothing</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">)).</span><span class="nx">join</span><span class="p">()</span> <span class="c1">// Nothing</span>
</code></pre></div></div>

<p>We seem to have <strong>solved</strong> our problem! Each time we <code class="language-plaintext highlighter-rouge">map</code> with a <code class="language-plaintext highlighter-rouge">Maybe</code>-returning function, we call <code class="language-plaintext highlighter-rouge">join</code> to flatten the two <code class="language-plaintext highlighter-rouge">Maybe</code> layers into one. <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">join</code>, <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">join</code>, and so on. Back in <a href="/2017/05/08/fantas-eel-and-specification-12/">the <code class="language-plaintext highlighter-rouge">Traversable</code> post</a>, we saw that the <code class="language-plaintext highlighter-rouge">map</code>/<code class="language-plaintext highlighter-rouge">sequence</code> pattern was common enough that we gave it an alias: <code class="language-plaintext highlighter-rouge">traverse</code>. Wouldn&#x2019;t you know it, the same applies here: the <code class="language-plaintext highlighter-rouge">map</code>/<code class="language-plaintext highlighter-rouge">join</code> pattern is so common, we call it <code class="language-plaintext highlighter-rouge">chain</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ chain :: Maybe a ~&gt; (a -&gt; Maybe b)</span>
<span class="c1">//+                  -&gt; Maybe b</span>
<span class="nx">Maybe</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Just</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
    <span class="na">Nothing</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span> <span class="c1">// Do nothing</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Just like `sequence` is `traverse` with</span>
<span class="c1">// `id`,  `join` is `chain` with `id`!</span>
<span class="c1">//+ join :: Chain m =&gt; m (m a) ~&gt; m a</span>
<span class="kd">const</span> <span class="nx">join</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span>

<span class="c1">// Our example one more time...</span>
<span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// Just({ b: { c: 2 } })</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">))</span> <span class="c1">// Just({ c: 2 })</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">c</span><span class="dl">&apos;</span><span class="p">))</span> <span class="c1">// Just(2)</span>
</code></pre></div></div>

<p><strong>So many parallels!</strong> Now, this fancy little pattern is useful far beyond an occasional <code class="language-plaintext highlighter-rouge">Maybe</code>. It turns out that we can unlock a <strong>lot</strong> of behaviour this way:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ chain :: Either e a</span>
<span class="c1">//+       ~&gt; (a -&gt; Either e b)</span>
<span class="c1">//+       -&gt; Either e b</span>
<span class="nx">Either</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Right</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span>
    <span class="na">Left</span><span class="p">:</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">this</span> <span class="c1">// Do nothing</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">sqrt</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="p">?</span> <span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hey, no!</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">:</span> <span class="nx">Right</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="nx">Right</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">)</span> <span class="c1">// Right(4)</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">)</span> <span class="c1">// Right(2)</span>

<span class="nx">Right</span><span class="p">(</span><span class="mi">81</span><span class="p">)</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">)</span>  <span class="c1">// Right(9)</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// Right(-9) &#x1F62E;</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">)</span>  <span class="c1">// Left(&apos;Hey, no!&apos;)</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// Left(&apos;Hey, no!&apos;)</span>

<span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">eep</span><span class="dl">&apos;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">)</span> <span class="c1">// Left(&apos;eep&apos;)</span>
</code></pre></div></div>

<p>Just as <code class="language-plaintext highlighter-rouge">Maybe</code>&#x2019;s <code class="language-plaintext highlighter-rouge">chain</code> would carry forward a <code class="language-plaintext highlighter-rouge">Nothing</code>, <code class="language-plaintext highlighter-rouge">Either</code>&#x2019;s will carry forward the first <code class="language-plaintext highlighter-rouge">Left</code>. We can then chain a bunch of <code class="language-plaintext highlighter-rouge">Either</code>-returning functions and get the first <code class="language-plaintext highlighter-rouge">Left</code> if anything goes wrong - just like <strong>throwing exceptions</strong>! With <code class="language-plaintext highlighter-rouge">Either</code>, we can model exceptions in a <strong>completely pure way</strong>. <strong>Pure</strong>. Savour this moment. We <strong>fixed</strong> exceptions.</p>

<p>This one&#x2019;s <strong>exciting</strong>, right? Let&#x2019;s see what <code class="language-plaintext highlighter-rouge">Array</code> can do:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ chain :: Array a</span>
<span class="c1">//+       ~&gt; (a -&gt; Array b)</span>
<span class="c1">//+       -&gt; Array b</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Map, then concat the results.</span>
  <span class="k">return</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(...</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NB: **totally** made up.</span>
<span class="kd">const</span> <span class="nx">flights</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">ATL</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">LAX</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">DFW</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="na">ORD</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">DEN</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="na">LAX</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">JFK</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">ATL</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="na">DEN</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">ATL</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">ORD</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">DFW</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="na">JFK</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">LAX</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">DEN</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">//- Where can I go from airport X?</span>
<span class="c1">//+ whereNext :: String -&gt; [String]</span>
<span class="kd">const</span> <span class="nx">whereNext</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">flights</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]</span>

<span class="c1">// JFK, ATL</span>
<span class="nx">whereNext</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">LAX</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">// LAX, DEN, LAX, DFW</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">whereNext</span><span class="p">)</span>

<span class="c1">// JFK, ATL, ATL, ORD, DFW, JFK, ATL</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">whereNext</span><span class="p">)</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">Array</code>, we <code class="language-plaintext highlighter-rouge">map</code> with some <code class="language-plaintext highlighter-rouge">Array</code>-returning function, then flatten all the results into one list. <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">join</code>, just like everything else! Here, we&#x2019;re essentially <strong>traversing a graph</strong>, and building up a list of <strong>possible positions</strong> after each <strong>step</strong>. In fact, languages like <a href="https://github.com/purescript/purescript/wiki/Differences-from-Haskell#array-comprehensions"><strong>PureScript</strong> use <code class="language-plaintext highlighter-rouge">chain</code> to model <strong>loops</strong></a><em>*</em>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- An ugly implementation for range.</span>
<span class="c1">//+ range :: (Int, Int) -&gt; [Int]</span>
<span class="kd">const</span> <span class="nx">range</span> <span class="o">=</span> <span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="p">[...</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">to</span> <span class="o">-</span> <span class="k">from</span><span class="p">)]</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">i</span> <span class="o">+</span> <span class="k">from</span><span class="p">)</span>

<span class="c1">//- The example from that link in JS.</span>
<span class="c1">//+ factors :: Int -&gt; [Pair Int Int]</span>
<span class="kd">const</span> <span class="nx">factors</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">=&gt;</span>
  <span class="nx">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">a</span> <span class="o">=&gt;</span>
    <span class="nx">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">a</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">b</span> <span class="o">=&gt;</span>
      <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="o">!==</span> <span class="nx">n</span>
      <span class="p">?</span> <span class="p">[]</span>
      <span class="p">:</span> <span class="p">[</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">]))</span>

<span class="c1">// (4, 5), (2, 10)</span>
<span class="nx">factors</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div></div>

<hr>

<p>Now, let&#x2019;s talk about <a href="https://github.com/folktale/data.task">our <code class="language-plaintext highlighter-rouge">Task</code> type</a><sup>&#x2020;</sup>. We&#x2019;ve seen that, with its <code class="language-plaintext highlighter-rouge">Apply</code> implementation, we get <strong>parallelism for free</strong>. However, we haven&#x2019;t actually talked about how to get <strong>serial</strong> behaviour. For example, what if we wanted to do some AJAX to get a <em>user</em>, and then use the result to get their <em>friends</em>? Well, <code class="language-plaintext highlighter-rouge">chain</code> would appear to be exactly what we need:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ getUser :: String -&gt; Task e Int</span>
<span class="kd">const</span> <span class="nx">getUser</span> <span class="o">=</span> <span class="nx">email</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Task</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">API</span><span class="p">.</span><span class="nx">getUser</span><span class="p">(</span><span class="nx">email</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
                <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">rej</span><span class="p">))</span>

<span class="c1">//+ getFriendsOf :: Int -&gt; Task e [User]</span>
<span class="kd">const</span> <span class="nx">getFriends</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Task</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">API</span><span class="p">.</span><span class="nx">getFriends</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
                <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">rej</span><span class="p">))</span>

<span class="c1">// Task e [User] - hooray?</span>
<span class="nx">getUser</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">test@test.com</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">getFriends</span><span class="p">)</span>
</code></pre></div></div>

<p>It turns out this behaviour <strong>is</strong> defined on our <code class="language-plaintext highlighter-rouge">Task</code> type, so we can <code class="language-plaintext highlighter-rouge">chain</code> together <code class="language-plaintext highlighter-rouge">Task</code> objects to get <strong>sequencing</strong> when we need it, and <code class="language-plaintext highlighter-rouge">ap</code> them together for <strong>free parallelism</strong>. Before we get <em>too</em> excited, though, let&#x2019;s talk about what&#x2019;s <strong>wrong</strong> here.</p>

<p>If a type <strong>lawfully</strong> implements <code class="language-plaintext highlighter-rouge">Chain</code> (and hence <code class="language-plaintext highlighter-rouge">Apply</code> and <code class="language-plaintext highlighter-rouge">Functor</code>), we can <strong>derive</strong> <code class="language-plaintext highlighter-rouge">ap</code> using <code class="language-plaintext highlighter-rouge">chain</code> and <code class="language-plaintext highlighter-rouge">map</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ ap :: Chain m =&gt; m a ~&gt; m (a -&gt; b) -&gt; m b</span>
<span class="nx">MyType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">f</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>So what</strong>? Well, this <code class="language-plaintext highlighter-rouge">ap</code> doesn&#x2019;t behave like the <code class="language-plaintext highlighter-rouge">ap</code> we already have. Most importantly, there&#x2019;s <strong>no parallelism</strong>! Houston, <strong>we have a problem</strong>. In the case of <code class="language-plaintext highlighter-rouge">Task</code>, either the <code class="language-plaintext highlighter-rouge">ap</code> or <code class="language-plaintext highlighter-rouge">chain</code> method is therefore <strong>unlawful</strong>.</p>

<blockquote>
  <p>There have been <a href="https://github.com/ekmett/either/pull/38#issuecomment-95688646">similar discussions</a> that are worth reading for more background, but this point is quite an <em>advanced</em> discussion, so brace yourself.</p>
</blockquote>

<p>This means that, to write <strong>law-obiding</strong> code, we need to accept that either our <code class="language-plaintext highlighter-rouge">ap</code> method is wrong, or our <code class="language-plaintext highlighter-rouge">chain</code> method shouldn&#x2019;t exist. <em>Personally, I&#x2019;ve always chosen to view <code class="language-plaintext highlighter-rouge">chain</code> as the &#x201C;problem method&#x201D;, and asserted that <code class="language-plaintext highlighter-rouge">Task</code> is an <code class="language-plaintext highlighter-rouge">Applicative</code> but <strong>not</strong> a <code class="language-plaintext highlighter-rouge">Chain</code></em>. What we <strong>should</strong> do is <strong>convert</strong> our <code class="language-plaintext highlighter-rouge">Task</code> to some &#x201C;sequential&#x201D; type when we want to do something sequential:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A &quot;sequential&quot; async type.</span>
<span class="kd">const</span> <span class="nb">Promise</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">fantasy-promises</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">// For &quot;errors&quot; within Promise.</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">Left</span><span class="p">,</span> <span class="nx">Right</span> <span class="p">}</span>
  <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">fantasy-eithers</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">//- Convert a Task to a Promise</span>
<span class="c1">//+ taskToPromise :: Task e a</span>
<span class="c1">//+               -&gt; Promise (Either e a)</span>
<span class="kd">const</span> <span class="nx">taskToPromise</span> <span class="o">=</span> <span class="nx">task</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">(</span>
  <span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">task</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">Left</span><span class="p">(</span><span class="nx">e</span><span class="p">)),</span>
                   <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">Right</span><span class="p">(</span><span class="nx">x</span><span class="p">))))</span>

<span class="c1">//+ promiseToTask :: Promise (Either e a)</span>
<span class="c1">//+               -&gt; Task e a</span>
<span class="kd">const</span> <span class="nx">promiseToTask</span> <span class="o">=</span> <span class="nx">promise</span> <span class="o">=&gt;</span>
  <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">promise</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="nx">either</span> <span class="o">=&gt;</span>
      <span class="nx">either</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
        <span class="na">Left</span><span class="p">:</span> <span class="nx">rej</span><span class="p">,</span>
        <span class="na">Right</span><span class="p">:</span> <span class="nx">res</span>
      <span class="p">})</span>
    <span class="p">)</span>
  <span class="p">)</span>

<span class="c1">//- Finally...</span>
<span class="c1">//+ andThen :: Task e a ~&gt; (a -&gt; Task e b)</span>
<span class="c1">//+                     -&gt; Task e b</span>
<span class="nx">Task</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">andThen</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">promiseToTask</span><span class="p">(</span>
    <span class="nx">taskToPromise</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">either</span> <span class="o">=&gt;</span> <span class="nx">either</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="c1">// We &quot;lift&quot; failure using Promise&apos;</span>
      <span class="c1">// Applicative instance.</span>
      <span class="na">Left</span><span class="p">:</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">either</span><span class="p">),</span>

      <span class="na">Right</span><span class="p">:</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">taskToPromise</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
    <span class="p">}))</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">//- ... which gives us:</span>
<span class="nx">getUser</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">test@test.com</span><span class="dl">&apos;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">andThen</span><span class="p">(</span><span class="nx">getFriends</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Big and scary</strong>, but don&#x2019;t panic. Here, we&#x2019;re taking advantage of the <strong>natural transformation</strong> between <code class="language-plaintext highlighter-rouge">Task</code> and the composition of <code class="language-plaintext highlighter-rouge">Promise</code> and <code class="language-plaintext highlighter-rouge">Either e</code> in <strong>both</strong> directions: we move to a <strong>sequential</strong> context, do something sequential, then move back to the <strong>parallel</strong> context.</p>

<p>With <code class="language-plaintext highlighter-rouge">promiseToTask</code> and <code class="language-plaintext highlighter-rouge">taskToPromise</code>, we can convert any <code class="language-plaintext highlighter-rouge">Promise</code> into a <code class="language-plaintext highlighter-rouge">Task</code> and vice versa. This is exactly what we need in order to say that <code class="language-plaintext highlighter-rouge">Promise</code> and <code class="language-plaintext highlighter-rouge">Task</code> are <strong>isomorphic</strong>!</p>

<blockquote>
  <p><strong>Isomorphisms</strong> come up a lot to avoid these problems: if we can &#x201C;convert&#x201D; a type into another type with a required <strong>capability</strong>, and then convert it back, it&#x2019;s as good as having that capability in our <strong>original</strong> type! The difference is, however, that we&#x2019;re not breaking the <strong>laws</strong>.</p>
</blockquote>

<p>Of course, you could just as easily go ahead and use <code class="language-plaintext highlighter-rouge">chain</code>, and accept that it is <strong>badly-behaved</strong>. That&#x2019;s cool, as long as you&#x2019;re <strong>aware</strong> of this, and know to expect some <strong>unexpected</strong> results. You could also write a simple implementation of <code class="language-plaintext highlighter-rouge">andThen</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+ No intermediate type!</span>
<span class="nx">Task</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">andThen</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span>
      <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">fork</span><span class="p">(</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It&#x2019;s really down to you, but the <em>lengthier</em> method means that we neatly separate our <strong>parallel</strong> and <strong>sequential</strong> types, and can know what behaviour is expected in each. <code class="language-plaintext highlighter-rouge">Task</code>&#x2019;s author wrote a <a href="http://robotlolita.me/2014/03/20/a-monad-in-practicality-controlling-time.html">blog post on async control</a>, which may shed more light here.</p>

<hr>

<p>We&#x2019;ve seen what <code class="language-plaintext highlighter-rouge">chain</code> does: <code class="language-plaintext highlighter-rouge">map</code> then <code class="language-plaintext highlighter-rouge">join</code>. This is why you&#x2019;ll hear it called <code class="language-plaintext highlighter-rouge">flatMap</code> sometimes: it <code class="language-plaintext highlighter-rouge">maps</code> and then &#x201C;flattens&#x201D; two layers of <code class="language-plaintext highlighter-rouge">Chain</code> type into one. You might also hear <code class="language-plaintext highlighter-rouge">concatMap</code> (named after <code class="language-plaintext highlighter-rouge">Array</code>&#x2019;s particular implementation) or <code class="language-plaintext highlighter-rouge">bind</code>.</p>

<p>We&#x2019;ve also seen that we can define <code class="language-plaintext highlighter-rouge">ap</code> in terms of <code class="language-plaintext highlighter-rouge">chain</code> in a way that will work for <strong>any</strong> law-obiding type. <em>If you don&#x2019;t believe me, try it with <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">Either</code>, or <code class="language-plaintext highlighter-rouge">Array</code></em>! This, however, isn&#x2019;t the only <strong>rule</strong> that we have to follow. There&#x2019;s one, very <em>familiar</em>, <strong>law</strong> that comes with this class:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Associativity.</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">chain</span><span class="p">(</span><span class="nx">g</span><span class="p">))</span>

<span class="c1">// Remember Semigroups?</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
</code></pre></div></div>

<p>Just as <code class="language-plaintext highlighter-rouge">Semigroup</code> was associative at <strong>value</strong>-level, and <code class="language-plaintext highlighter-rouge">Apply</code> was associative at <strong>context</strong>-level, we can see that <code class="language-plaintext highlighter-rouge">Chain</code> seems to be associative at an <strong>order</strong>-level: unlike <code class="language-plaintext highlighter-rouge">Apply</code>, which we saw would freely allow for parallelism, <code class="language-plaintext highlighter-rouge">Chain</code> <strong>implies order</strong>. Just look at the type of <code class="language-plaintext highlighter-rouge">chain</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chain</span> <span class="o">::</span> <span class="kt">Chain</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span>
                 <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span>
                 <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">chain</code> function is useless until we know what the <code class="language-plaintext highlighter-rouge">a</code> in <code class="language-plaintext highlighter-rouge">m a</code> is. How can we <code class="language-plaintext highlighter-rouge">chain</code> a function on a <code class="language-plaintext highlighter-rouge">Promise</code> until the first part has completed? How can we <code class="language-plaintext highlighter-rouge">chain</code> a function on a <code class="language-plaintext highlighter-rouge">Maybe</code> until we know whether the first part failed? With <code class="language-plaintext highlighter-rouge">chain</code>, we finally have a way to <strong>encode</strong> order into our programs, and strictly <strong>forbid</strong> parallelism when we need to.</p>

<p>I think it&#x2019;s <strong>amazing</strong> that we managed to achieve all that we have so far <em>without</em> this concept! We&#x2019;re so used to order being determined by the ordering of the lines in our file, but that&#x2019;s because of <strong>state</strong>: we can&#x2019;t mix those lines up because they may depend on one another.</p>

<p>With <strong>purely-functional</strong> code, we know that can&#x2019;t be true, and that all dependencies are <strong>explicit</strong>. Who cares which side of an <code class="language-plaintext highlighter-rouge">ap</code> gets calculated first? Who cares whether a <code class="language-plaintext highlighter-rouge">map</code> happens now or later? Until we <code class="language-plaintext highlighter-rouge">fork</code> or <code class="language-plaintext highlighter-rouge">extract</code> a value from a <code class="language-plaintext highlighter-rouge">Functor</code>, it&#x2019;s just not important - it&#x2019;s an <strong>implementation detail</strong>!</p>

<p>A note to end on: for <code class="language-plaintext highlighter-rouge">Semigroup</code>, we had <code class="language-plaintext highlighter-rouge">Monoid</code>, which brought the <strong>empty value</strong>. For <code class="language-plaintext highlighter-rouge">Apply</code>, we had <code class="language-plaintext highlighter-rouge">Applicative</code>, which brought the <strong>pure context</strong>. Seems logical that <code class="language-plaintext highlighter-rouge">Chain</code> would have a similar partner, right? We&#x2019;ll get to it in a <em>fortnight</em>.</p>

<p>Until then, mess around with <a href="https://gist.github.com/richdouglasevans/d706a914453bdcbdf0df9adf114cfcb6">this post&#x2019;s Gist</a>, and <strong><code class="language-plaintext highlighter-rouge">chain</code> all the things</strong>! With <strong>parallel</strong> and <strong>sequential</strong> power, you actually now have <strong>everything</strong> you need to write any app in an <strong>entirely pure</strong> manner. Check out <a href="https://github.com/fantasyland/fantasy-io">the <code class="language-plaintext highlighter-rouge">fantasy-io</code> library</a> to see how we can encode <strong>any</strong> IO in a <code class="language-plaintext highlighter-rouge">Chain</code> type and completely <strong>remove</strong> the need for <strong>state</strong>. Go on: <strong>I dare you</strong>!</p>

<p>&#x2665;</p>

<iframe src="https://open.spotify.com/embed/track/2oZmMp5M6L0Rh7G84Um2tF" width="300" height="80" frameborder="0" allowtransparency="true"></iframe>

<p><em>* <code class="language-plaintext highlighter-rouge">do</code> notation really just connects each line with a <code class="language-plaintext highlighter-rouge">chain</code> call (or <code class="language-plaintext highlighter-rouge">bind</code>, as it&#x2019;s known in Haskell/PureScript). Here&#x2019;s <a href="https://en.wikibooks.org/wiki/Haskell/do_notation#Just_sugar">more information on <code class="language-plaintext highlighter-rouge">do</code></a>, but I wouldn&#x2019;t worry too much at this stage.</em></p>

<p><em><sup>&#x2020;</sup> Hat-tip to <a href="https://twitter.com/safareli/">@safareli</a>, who reminded me to include this bit!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 12: Traversable</h1>
  <span class="post-date">08 May 2017</span>
  <p>It&#x2019;s <strong><code class="language-plaintext highlighter-rouge">Traversable</code> Monday&#x2122;</strong>, everyone! Granted, <em>tomorrow</em> would have made for a catchier opening, but I wasn&#x2019;t thinking this far ahead when I picked the day to release these. Still, I bet you can&#x2019;t <em>wait</em> for <code class="language-plaintext highlighter-rouge">Monad</code>s now! Putting all that aside, does everyone remember how great the <code class="language-plaintext highlighter-rouge">insideOut</code> function from <a href="/2017/04/17/fantas-eel-and-specification-9/">the <code class="language-plaintext highlighter-rouge">Applicative</code> post</a> was? Well, today&#x2019;s post is all about your <strong>new favourite typeclass</strong>.</p>

<p>This little class comes with, hands down, the most <em>frightening</em> signature we&#x2019;ve seen so far! Just <em>look</em> at this thing:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">traverse</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Traversable</span> <span class="n">t</span>
         <span class="o">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">TypeRep</span> <span class="n">f</span><span class="p">,</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
         <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p><em>Right</em>? Let&#x2019;s break it down. We can take a <code class="language-plaintext highlighter-rouge">Traversable</code> structure (whatever <em>that</em> means) with an inner <code class="language-plaintext highlighter-rouge">a</code> type, use this <code class="language-plaintext highlighter-rouge">a -&gt; f b</code> function (where <code class="language-plaintext highlighter-rouge">f</code> is some <code class="language-plaintext highlighter-rouge">Applicative</code>), and we&#x2019;ll land on <code class="language-plaintext highlighter-rouge">f (t b)</code>. <em>Wait, <strong>what</strong></em>?</p>

<p>The little bit of <strong>magic</strong> here is that, if we used the <code class="language-plaintext highlighter-rouge">a -&gt; f b</code> with <code class="language-plaintext highlighter-rouge">map</code>, we&#x2019;d end up with <code class="language-plaintext highlighter-rouge">t (f b)</code>, right? The <code class="language-plaintext highlighter-rouge">f b</code> replaces the <code class="language-plaintext highlighter-rouge">a</code> in the <code class="language-plaintext highlighter-rouge">t a</code>; nothing we haven&#x2019;t seen before. <strong>However</strong>, with <code class="language-plaintext highlighter-rouge">traverse</code>, the <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">t</code> come out <strong>the other way round!</strong></p>

<hr>

<p>In a <strong>shocking</strong> development, let&#x2019;s see some examples <em>before</em> we trouble ourselves with the laws, as they&#x2019;re a bit <strong>intimidating</strong>. Let&#x2019;s say you have an <code class="language-plaintext highlighter-rouge">Array</code> of <code class="language-plaintext highlighter-rouge">Int</code> user IDs, and we need to do some <strong>AJAX</strong> for each one to get some details:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// getById :: Int -&gt; Task e User</span>
<span class="kd">const</span> <span class="nx">getById</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="c1">// Do some AJAX</span>
</code></pre></div></div>

<p>Luckily, we have our wonderful <code class="language-plaintext highlighter-rouge">Task</code> applicative to encapsulate the AJAX requests. We map over our <code class="language-plaintext highlighter-rouge">Array</code> with <code class="language-plaintext highlighter-rouge">getById</code>, and we end up with an <code class="language-plaintext highlighter-rouge">Array</code> of <code class="language-plaintext highlighter-rouge">Task</code> objects. <strong>Neat</strong>! However, whatever we&#x2019;re doing with them, we probably want to do it on the <em>entire</em> <code class="language-plaintext highlighter-rouge">Array</code>, so wouldn&#x2019;t it be better to combine them into a single <code class="language-plaintext highlighter-rouge">Task e [User]</code>? Well, our luck just continues, because we have our nifty little <code class="language-plaintext highlighter-rouge">insideOut</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// insideOut :: Applicative f</span>
<span class="c1">//           =&gt; [f a] -&gt; f [a]</span>
<span class="kd">const</span> <span class="nx">insideOut</span> <span class="o">=</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lift2</span><span class="p">(</span><span class="nx">append</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span>
  <span class="nx">T</span><span class="p">.</span><span class="k">of</span><span class="p">([]))</span>

<span class="c1">// paralleliseTaskArray</span>
<span class="c1">//   :: [Int] -&gt; Task e [User]</span>
<span class="kd">const</span> <span class="nx">paralleliseTaskArray</span> <span class="o">=</span> <span class="nx">users</span> <span class="o">=&gt;</span>
  <span class="nx">insideOut</span><span class="p">(</span><span class="nx">Task</span><span class="p">,</span> <span class="nx">users</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">API</span><span class="p">.</span><span class="nx">getById</span><span class="p">))</span>
</code></pre></div></div>

<p>First we <code class="language-plaintext highlighter-rouge">map</code>, then we <code class="language-plaintext highlighter-rouge">insideOut</code>. Thanks to <code class="language-plaintext highlighter-rouge">Task</code>&#x2019;s <code class="language-plaintext highlighter-rouge">Applicative</code> instance, we&#x2019;ve successfully reached our goal! On top of <em>that</em>, the wonder of  <code class="language-plaintext highlighter-rouge">Apply</code> means all our AJAX will happen <strong>in parallel</strong>, with no extra effort!</p>

<p>Well, it turns out that there&#x2019;s a name for <code class="language-plaintext highlighter-rouge">insideOut</code> that encompasses more outer types than just <code class="language-plaintext highlighter-rouge">Array</code>, and we call it <code class="language-plaintext highlighter-rouge">sequence</code>! What&#x2019;s more, a <code class="language-plaintext highlighter-rouge">map</code> immediately followed by <code class="language-plaintext highlighter-rouge">sequence</code> has a more common name: <code class="language-plaintext highlighter-rouge">traverse</code>!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">traverse</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
      <span class="c1">//    Here&apos;s the map bit! vvvv</span>
      <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lift2</span><span class="p">(</span><span class="nx">append</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">acc</span><span class="p">),</span>
      <span class="nx">T</span><span class="p">.</span><span class="k">of</span><span class="p">([]))</span>
  <span class="p">}</span>

<span class="c1">// Don&apos;t worry, though: `sequence` can also</span>
<span class="c1">// be written as a super-simple `traverse`!</span>
<span class="kd">const</span> <span class="nx">sequence</span> <span class="o">=</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span>
</code></pre></div></div>

<p>So, whenever we see <code class="language-plaintext highlighter-rouge">map</code> followed by <code class="language-plaintext highlighter-rouge">sequence</code>, we can just use <code class="language-plaintext highlighter-rouge">traverse</code>. Whenever all we want to do is <strong>flip the types</strong>, we can use <code class="language-plaintext highlighter-rouge">sequence</code>.</p>

<blockquote>
  <p><em>I usually define <code class="language-plaintext highlighter-rouge">sequence</code> <strong>and</strong> <code class="language-plaintext highlighter-rouge">traverse</code> on my <code class="language-plaintext highlighter-rouge">Traversable</code> types because they both get plenty of use.</em></p>
</blockquote>

<p>Thinking about inner types, why stop with <code class="language-plaintext highlighter-rouge">Task</code>? What if we use another <code class="language-plaintext highlighter-rouge">Applicative</code> instead? Let&#x2019;s play with <code class="language-plaintext highlighter-rouge">Either</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// toChar :: Int -&gt; Either String Char</span>
<span class="kd">const</span> <span class="nx">toChar</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">25</span>
  <span class="p">?</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> is out of bounds!</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">:</span> <span class="nx">Right</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">65</span><span class="p">))</span>

<span class="c1">// Right([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])</span>
<span class="p">;[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">].</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">Either</span><span class="p">,</span> <span class="nx">toChar</span><span class="p">)</span>

<span class="c1">// Left(&apos;-2 is out of bounds!&apos;)</span>
<span class="p">;[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">].</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">Either</span><span class="p">,</span> <span class="nx">toChar</span><span class="p">)</span>
</code></pre></div></div>

<p>By using <code class="language-plaintext highlighter-rouge">traverse</code> with an inner type of <code class="language-plaintext highlighter-rouge">Either</code>, we get back the first <code class="language-plaintext highlighter-rouge">Left</code> if <em>any</em> of the values <code class="language-plaintext highlighter-rouge">map</code> to a <code class="language-plaintext highlighter-rouge">Left</code>! In other words, we get back the <strong>first error</strong>. Consider, for a minute, how <strong>incredibly useful</strong> this is for <strong>form validation</strong>.</p>

<blockquote>
  <p><em>What if we just want the successes, and to filter out the rest</em>? We <code class="language-plaintext highlighter-rouge">map</code> our function, then <code class="language-plaintext highlighter-rouge">map(map(x =&gt; [x]))</code> to get all the <code class="language-plaintext highlighter-rouge">Right</code> values into a singleton list, then <code class="language-plaintext highlighter-rouge">fold</code> the list with the <code class="language-plaintext highlighter-rouge">Either</code> <strong>semigroup</strong> starting with <code class="language-plaintext highlighter-rouge">Right([])</code>. I swear, I can&#x2019;t get through a single post without mentioning some sort of fold!</p>
</blockquote>

<p>In fact, why stop with <code class="language-plaintext highlighter-rouge">Array</code>? We can define <code class="language-plaintext highlighter-rouge">Traversable</code> instances for all sorts of things: <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">Either</code>, <code class="language-plaintext highlighter-rouge">Pair</code>, and even our <code class="language-plaintext highlighter-rouge">Tree</code> from last time! What&#x2019;s the <em>secret</em>, though?</p>

<p>A <code class="language-plaintext highlighter-rouge">Traversable</code> type needs to know how to <strong>rebuild itself</strong>. It pulls itself apart, lifts each part into the <code class="language-plaintext highlighter-rouge">Applicative</code>, and then puts itself back together. With the wonderful help of <code class="language-plaintext highlighter-rouge">of</code> and <code class="language-plaintext highlighter-rouge">ap</code>, it&#x2019;s not hard to get all the pieces <em>into</em> the <code class="language-plaintext highlighter-rouge">Applicative</code>, so the only trickery is the work on either side. <em>Luckily</em>, this is often very straightforward:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Transform _2, then `map` in the _1!</span>
<span class="nx">Pair</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">traverse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span>
    <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Pair</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Keep the nothing OR map in the Just!</span>
<span class="nx">Maybe</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">traverse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Just</span><span class="p">:</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">Maybe</span><span class="p">.</span><span class="nx">Just</span><span class="p">),</span>
    <span class="na">Nothing</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">Maybe</span><span class="p">.</span><span class="nx">Nothing</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Lift all the bits, then rebuild!</span>
<span class="nx">Tree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">traverse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Node</span><span class="p">:</span> <span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lift3</span><span class="p">(</span>
      <span class="nx">l</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">r</span> <span class="o">=&gt;</span>
        <span class="nx">Tree</span><span class="p">.</span><span class="nx">Node</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">r</span><span class="p">),</span>

      <span class="nx">l</span><span class="p">.</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span><span class="p">),</span>
      <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span><span class="p">))</span>
    <span class="na">Leaf</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">Tree</span><span class="p">.</span><span class="nx">Leaf</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><em>If you&#x2019;ve been following the <a href="/2017/04/15/functions-as-functors/">Reader</a>/<a href="/2017/04/27/pairs-as-functors/">Writer</a>/State series, we&#x2019;ll actually be taking a look at the <code class="language-plaintext highlighter-rouge">Pair</code> traversable in the finale!</em></p>
</blockquote>

<p>If you can <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">reduce</code> your type (i.e. it&#x2019;s a <code class="language-plaintext highlighter-rouge">Functor</code> and a <code class="language-plaintext highlighter-rouge">Foldable</code>), there&#x2019;s a really good chance that it can be a <code class="language-plaintext highlighter-rouge">Traversable</code>, too. Trust me: <code class="language-plaintext highlighter-rouge">Task</code>&#x2019;s <code class="language-plaintext highlighter-rouge">Applicative</code> instance is <em>enough</em> reason to get excited about this!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Task</code> is also a good example of a type that <em>isn&#x2019;t</em> <code class="language-plaintext highlighter-rouge">Traversable</code>, despite it having a similar structure to <code class="language-plaintext highlighter-rouge">Either</code>. What&#x2019;s the difference? Well, consider a <code class="language-plaintext highlighter-rouge">Task</code> that returns a <code class="language-plaintext highlighter-rouge">Maybe</code> to denote success. If we <em>could</em> traverse <code class="language-plaintext highlighter-rouge">Task</code>, we&#x2019;d get back <code class="language-plaintext highlighter-rouge">Just</code> a successful task, or <code class="language-plaintext highlighter-rouge">Nothing</code>. See why this is impossible? We don&#x2019;t <em>know</em> whether the <code class="language-plaintext highlighter-rouge">Task</code> succeeds until we run it!</p>
</blockquote>

<hr>

<p>Before you get <em>too</em> excited and go all <strong>super-villian</strong> on me with your new-found <strong>superpowers</strong>, let&#x2019;s end on <strong>the laws</strong>. <em>Brace yourselves</em>. We&#x2019;ll start with <strong>identity</strong>, as it&#x2019;s definitely the simplest:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">u</span><span class="p">.</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">F</span><span class="p">.</span><span class="k">of</span><span class="p">)</span> <span class="o">===</span> <span class="nx">F</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span>
</code></pre></div></div>

<p>If we take a <code class="language-plaintext highlighter-rouge">Traversable</code> structure of type <code class="language-plaintext highlighter-rouge">T a</code>, and <em>traverse</em> it with <code class="language-plaintext highlighter-rouge">F.of</code> (which is <code class="language-plaintext highlighter-rouge">a -&gt; F a</code> for some <code class="language-plaintext highlighter-rouge">Applicative F</code>), we&#x2019;ll get back <code class="language-plaintext highlighter-rouge">F (T a)</code>. <strong>Map and turn inside-out</strong>. What <em>this</em> law says is that we&#x2019;d have ended up in the same place if we&#x2019;d just called <code class="language-plaintext highlighter-rouge">F.of</code> on the whole <code class="language-plaintext highlighter-rouge">T a</code> structure. Squint a little, and ignore the <code class="language-plaintext highlighter-rouge">TypeRep</code>: <code class="language-plaintext highlighter-rouge">U.traverse(F.of) === F.of(U)</code> doesn&#x2019;t look a million miles from <code class="language-plaintext highlighter-rouge">U.map(id) === id(U)</code> (the identity law for <code class="language-plaintext highlighter-rouge">Functor</code>), does it?</p>

<p>Next up is <strong>naturality</strong>, which is a bit of a mess in the spec, so let&#x2019;s try to <strong>clean it up</strong>. Let&#x2019;s imagine we have two <code class="language-plaintext highlighter-rouge">Applicative</code> types, <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">G</code>, and some function <code class="language-plaintext highlighter-rouge">t :: F a -&gt; G a</code>, that does nothing but <strong>change the <code class="language-plaintext highlighter-rouge">Applicative</code></strong>.</p>

<blockquote>
  <p>A function that transforms one <code class="language-plaintext highlighter-rouge">Functor</code> into another <em>without</em> touching the inner value is called a <strong>natural transformation</strong>!</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">t</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">sequence</span><span class="p">(</span><span class="nx">F</span><span class="p">))</span> <span class="o">===</span> <span class="nx">u</span><span class="p">.</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</code></pre></div></div>

<p>So, we start with some <code class="language-plaintext highlighter-rouge">U (F a)</code>-type thing, <code class="language-plaintext highlighter-rouge">sequence</code> it, and land on <code class="language-plaintext highlighter-rouge">F (U a)</code>. We then call <code class="language-plaintext highlighter-rouge">t</code> on the result, and finally land on <code class="language-plaintext highlighter-rouge">G (u a)</code>. <strong>Naturality</strong> says that we could just call <code class="language-plaintext highlighter-rouge">t</code> directly in a <code class="language-plaintext highlighter-rouge">traverse</code> and end up in the same place! I read this as saying, &#x201C;<em>A <code class="language-plaintext highlighter-rouge">traverse</code> should behave the same way regardless of the inner <code class="language-plaintext highlighter-rouge">Applicative</code></em>&#x201D;; it doesn&#x2019;t matter whether we do the transformation <strong>during</strong> or <strong>after</strong>.</p>

<blockquote>
  <p>This law is actually <em>implied</em> by <strong>parametricity</strong>, which is a topic we might cover in the future. Basically, it means that the type signature of <code class="language-plaintext highlighter-rouge">traverse</code> is restricted enough that this can&#x2019;t <strong>not</strong> be true for any <code class="language-plaintext highlighter-rouge">Traversable</code> that follows the <strong>other two</strong> laws!</p>
</blockquote>

<p>Last up is <strong>composition</strong>, and we&#x2019;re going to need to introduce a type we haven&#x2019;t seen before. <code class="language-plaintext highlighter-rouge">Compose</code> is a way of combining two <code class="language-plaintext highlighter-rouge">Functor</code>s into one (and even two <code class="language-plaintext highlighter-rouge">Applicative</code>s into one!), and it goes a little something like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Type Compose f g a = Compose (f (g a))</span>
<span class="kd">const</span> <span class="nx">Compose</span> <span class="o">=</span> <span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">G</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Compose_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Compose</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">stack</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="c1">// compose(F.of, G.of)</span>
  <span class="nx">Compose_</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span>
    <span class="nx">Compose_</span><span class="p">(</span><span class="nx">F</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">G</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>

  <span class="c1">// Basically map(map(f))</span>
  <span class="nx">Compose_</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Compose_</span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
        <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Basically lift2(ap, this, fs)</span>
  <span class="nx">Compose_</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Compose_</span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">stack</span>
          <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
          <span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Compose_</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We&#x2019;re not going to spend too much time on this type, so have a <strong>couple of looks</strong> to make sure you&#x2019;re following. The key point here is that we&#x2019;ve stacked two <code class="language-plaintext highlighter-rouge">Applicative</code>s to form a <strong>composite</strong> <code class="language-plaintext highlighter-rouge">Applicative</code> - how <strong>amazing</strong> is that? Even more excitingly, this rule generalises to <strong>any number</strong> of nested <code class="language-plaintext highlighter-rouge">Applicative</code>s - they compose <strong>completely mechanically</strong>!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Compose</code> will <em>also</em> be an important part of the upcoming <code class="language-plaintext highlighter-rouge">State</code> post, so don&#x2019;t think we&#x2019;ve seen the last of it!</p>
</blockquote>

<p>Anyway, let&#x2019;s get back to the point of introducing this type <em>here</em>. We&#x2019;ll use <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">G</code> as our <code class="language-plaintext highlighter-rouge">Applicative</code> placeholders again, and end up with the law below. <a href="https://github.com/fantasyland/fantasy-land#traversable">The spec</a> only uses <code class="language-plaintext highlighter-rouge">traverse</code>, but this should make things a bit clearer:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Comp</span> <span class="o">=</span> <span class="nx">Compose</span><span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">G</span><span class="p">)</span>

<span class="c1">// The type signature helps, I think:</span>
<span class="c1">// t (F (G a)) -&gt; Compose F G (t a)</span>
<span class="nx">u</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">Comp</span><span class="p">).</span><span class="nx">sequence</span><span class="p">(</span><span class="nx">Comp</span><span class="p">)</span> <span class="o">===</span>
  <span class="nx">Comp</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">sequence</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">sequence</span><span class="p">(</span><span class="nx">G</span><span class="p">)))</span>
</code></pre></div></div>

<p>This one&#x2019;s the <strong>ugliest</strong> of the bunch! We start with some <code class="language-plaintext highlighter-rouge">u</code> of type <code class="language-plaintext highlighter-rouge">t (F (G a))</code>, where <code class="language-plaintext highlighter-rouge">t</code> is <code class="language-plaintext highlighter-rouge">Traversable</code>. On the <strong>left-hand</strong> side, we <code class="language-plaintext highlighter-rouge">map</code> over this with <code class="language-plaintext highlighter-rouge">Comp</code> and land on <code class="language-plaintext highlighter-rouge">t (Compose F G a)</code>. Because <code class="language-plaintext highlighter-rouge">Compose F G</code> is an <code class="language-plaintext highlighter-rouge">Applicative</code>, we can turn this <strong>inside out</strong> and land on <code class="language-plaintext highlighter-rouge">Compose F G (t a)</code>. Whew!</p>

<p>The <strong>right-hand</strong> side says we can <code class="language-plaintext highlighter-rouge">sequence</code> the <code class="language-plaintext highlighter-rouge">t (F (G a))</code> to get us to <code class="language-plaintext highlighter-rouge">F (t (G a))</code>, then <code class="language-plaintext highlighter-rouge">map</code> a <code class="language-plaintext highlighter-rouge">sequence</code> over it to get us to <code class="language-plaintext highlighter-rouge">F (G (t a))</code>. If we pass this into <code class="language-plaintext highlighter-rouge">Comp</code>, we land on <code class="language-plaintext highlighter-rouge">Compose F G (t a)</code>, and we <strong>must land</strong> on the <strong>same result</strong> as the left-hand side did!</p>

<p>This is a <em>really</em> dense law, but <strong>just remember this</strong>: we can either <code class="language-plaintext highlighter-rouge">Compose</code> the <code class="language-plaintext highlighter-rouge">Applicative</code>s <strong>inside</strong> the <code class="language-plaintext highlighter-rouge">Traversable</code> and <em>then</em> <code class="language-plaintext highlighter-rouge">sequence</code>, or <code class="language-plaintext highlighter-rouge">sequence</code> and <em>then</em> <code class="language-plaintext highlighter-rouge">Compose</code>. <strong>It shouldn&#x2019;t matter</strong>. I read this as a kind of <strong>re-inforcement</strong> of <strong>naturality</strong>; not only should the <code class="language-plaintext highlighter-rouge">Traversable</code> leave the <code class="language-plaintext highlighter-rouge">Applicative</code> alone, but it should <strong>respect <code class="language-plaintext highlighter-rouge">Applicative</code> composition</strong>.</p>

<hr>

<p><code class="language-plaintext highlighter-rouge">Traversable</code> has some <em>thorough</em> laws, but this is a <strong>good thing</strong>! The tighter the <strong>restrictions</strong>, the better we can <strong>optimise</strong> the instances we write: we&#x2019;ve already had a <em>taste</em> of the power behind the <code class="language-plaintext highlighter-rouge">Traversable</code> / <code class="language-plaintext highlighter-rouge">Applicative</code> relationship! <em>However</em>, there&#x2019;s a problem that we still haven&#x2019;t addressed:</p>

<p>We know we can do <strong>parallel</strong> computation with our <code class="language-plaintext highlighter-rouge">Applicative</code>, but how do we do <strong>serial</strong> computation? How do we <strong>compose</strong> functions that return <code class="language-plaintext highlighter-rouge">Functor</code>s? These questions, and others, will be solved <strong>next week</strong> when we cover <code class="language-plaintext highlighter-rouge">chain</code>.</p>

<p>Until then, <code class="language-plaintext highlighter-rouge">traverse</code> all the things! A Gist of this post&#x2019;s <a href="https://gist.github.com/i-am-tom/0fa536e81787df1c94a55f1b4c92e94e">motivating examples</a> is available. <code class="language-plaintext highlighter-rouge">Array</code> will, by far, be the one you use the most, but don&#x2019;t be afraid to experiment. I look forward to your creations!</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 9: Applicative</h1>
  <span class="post-date">17 Apr 2017</span>
  <p><em>I asked my <strong>German</strong> friend whether any of this series&#x2019; posts particularly stood out. They said <strong>9</strong>, so I&#x2019;d better make this a good one!</em> I told you we were doing jokes now, right? Moving on&#x2026; <em>Today</em>, we&#x2019;re going to finish up a topic we started last week and move from our <code class="language-plaintext highlighter-rouge">Apply</code> types to <code class="language-plaintext highlighter-rouge">Applicative</code>. If you understood <a href="/2017/04/10/fantas-eel-and-specification-8/">the Apply post</a>, this one is <em>hopefully</em> going to be pretty intuitive. <strong>Hooray</strong>!</p>

<p><code class="language-plaintext highlighter-rouge">Applicative</code> types are <code class="language-plaintext highlighter-rouge">Apply</code> types with one extra function, which we define in <a href="https://github.com/fantasyland/fantasy-land#applicative">Fantasy Land</a> as <code class="language-plaintext highlighter-rouge">of</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">of</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">of</code>, we can take a value, and <strong>lift</strong> it into the given <code class="language-plaintext highlighter-rouge">Applicative</code>. That&#x2019;s it! In the wild, <em>most</em> <code class="language-plaintext highlighter-rouge">Apply</code> types you practically use will also be <code class="language-plaintext highlighter-rouge">Applicative</code>, but we&#x2019;ll go through a counter-example later on! Anyway, wouldn&#x2019;t you know, there are a few <strong>laws</strong> to go with it, tying <code class="language-plaintext highlighter-rouge">ap</code> and <code class="language-plaintext highlighter-rouge">of</code> together:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For some applicative A...</span>

<span class="c1">// Identity.</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">))</span> <span class="o">===</span> <span class="nx">v</span>

<span class="c1">// Homomorphism</span>
<span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">// Interchange</span>
<span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">y</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span> <span class="o">===</span> <span class="nx">u</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>With <strong>identity</strong>, we&#x2019;ve lifted the identity function (<code class="language-plaintext highlighter-rouge">x =&gt; x</code>) into our <strong>context</strong>, applied it to the inner value, and, surprise, <strong>nothing happened</strong>.</p>

<p>The <strong>homomorphism</strong> law says that we can lift a function and its argument <strong>separately</strong> and <em>then</em> combine them, <strong>or</strong> combine them and <em>then</em> lift the result. Either way, we&#x2019;ll end up with the same answer! The <code class="language-plaintext highlighter-rouge">of</code> function can do <em>nothing</em> but put the value into the <code class="language-plaintext highlighter-rouge">Applicative</code>. No tricks. <strong>No side effects</strong>.</p>

<p><strong>Interchange</strong> is a little more complex. We can lift <code class="language-plaintext highlighter-rouge">y</code> and apply it to the function in <code class="language-plaintext highlighter-rouge">u</code>, <em>or</em> we can lift <code class="language-plaintext highlighter-rouge">f =&gt; f(y)</code>, and apply <code class="language-plaintext highlighter-rouge">u</code> to that. I think of this one as, &#x201C;<em>Nothing special happens to one particular side of <code class="language-plaintext highlighter-rouge">ap</code> - it just applies the value in the right side to the value in the left</em>&#x201D;.</p>

<hr>

<p>So, why is this <code class="language-plaintext highlighter-rouge">of</code> thing <em>useful</em>? Well, the most exciting reason is that we can write functions generic to <strong>any applicative</strong>. Let&#x2019;s write a function that takes a <strong>list</strong> of <strong>applicative-wrapped</strong> values, and returns an <strong>applicative-wrapped list</strong> of values. Note that <code class="language-plaintext highlighter-rouge">T</code> is a <code class="language-plaintext highlighter-rouge">TypeRep</code> variable - we&#x2019;ve seen these before in <a href="/2017/03/21/fantas-eel-and-specification-5/">the monoid post</a>. We need it in case the list is empty:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// append :: a -&gt; [a] -&gt; [a]</span>
<span class="kd">const</span> <span class="nx">append</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="nx">y</span><span class="p">])</span>

<span class="c1">// There&apos;s that sneaky lift2 again!</span>
<span class="c1">// lift2 :: Applicative f</span>
<span class="c1">//       =&gt; (a -&gt; b -&gt; c, f a, f b)</span>
<span class="c1">//       -&gt; f c</span>
<span class="kd">const</span> <span class="nx">lift2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>

<span class="c1">// insideOut :: Applicative f</span>
<span class="c1">//           =&gt; [f a] -&gt; f [a]</span>
<span class="kd">const</span> <span class="nx">insideOut</span> <span class="o">=</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lift2</span><span class="p">(</span><span class="nx">append</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span>
  <span class="nx">T</span><span class="p">.</span><span class="k">of</span><span class="p">([]))</span> <span class="c1">// To start us off!</span>

<span class="c1">// For example...</span>

<span class="c1">// Just [2, 10, 3]</span>
<span class="nx">insideOut</span><span class="p">(</span><span class="nx">Maybe</span><span class="p">,</span> <span class="p">[</span> <span class="nx">Just</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                 <span class="p">,</span> <span class="nx">Just</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                 <span class="p">,</span> <span class="nx">Just</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">])</span>

<span class="c1">// Nothing</span>
<span class="nx">insideOut</span><span class="p">(</span><span class="nx">Maybe</span><span class="p">,</span> <span class="p">[</span> <span class="nx">Just</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                 <span class="p">,</span> <span class="nx">Nothing</span>
                 <span class="p">,</span> <span class="nx">Just</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">])</span>
</code></pre></div></div>

<p><strong>First of all</strong>, we lift an empty list into the applicative context. Then, value by value, we <strong>combine</strong> the contexts with a function to <code class="language-plaintext highlighter-rouge">append</code> the value to that inner list. <em>Neat</em>, right? We&#x2019;ll see in a few weeks that this <code class="language-plaintext highlighter-rouge">insideOut</code> can be generalised further to become a super-helpful function called <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Traversable.html#v:sequenceA"><code class="language-plaintext highlighter-rouge">sequenceA</code></a> that works on a lot more than just lists!</p>

<blockquote>
  <p>This is pretty useful for AJAX, too. We can use our <code class="language-plaintext highlighter-rouge">data.task</code> applicative to create a list of requests - a <code class="language-plaintext highlighter-rouge">[Task e a]</code> - and then combine them into a single <code class="language-plaintext highlighter-rouge">Task</code> containing the eventual results - a <code class="language-plaintext highlighter-rouge">Task e [a]</code> - using <code class="language-plaintext highlighter-rouge">insideOut</code>!</p>
</blockquote>

<p>Notice that we only <em>need</em> an <code class="language-plaintext highlighter-rouge">Applicative</code> because the list <em>could</em> be empty. Otherwise, we could just <code class="language-plaintext highlighter-rouge">map</code> over the first with <code class="language-plaintext highlighter-rouge">x =&gt; [x]</code> and use that one as the accumulator - we&#x2019;d only need <code class="language-plaintext highlighter-rouge">Apply</code>! <em>Anyone else having <a href="http://www.tomharding.me/2017/03/13/fantas-eel-and-specification-5/">flashbacks to monoids</a></em>? They&#x2019;re all <strong>very strongly-connected</strong>:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">concat</code> can combine any non-zero number of <strong>values</strong> (of the same type) into one.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ap</code> can combine any non-zero number of <strong>contexts</strong> (of the same type) into one.</p>
  </li>
  <li>
    <p>If we might need to handle zero <strong>values</strong>, we will need to use <code class="language-plaintext highlighter-rouge">empty</code>.</p>
  </li>
  <li>
    <p>If we might need to handle zero <strong>contexts</strong>, we will need to use <code class="language-plaintext highlighter-rouge">of</code>.</p>
  </li>
</ul>

<p>Wizardry. <strong>For our next trick</strong>, let&#x2019;s notice that you can turn <em>any</em> <code class="language-plaintext highlighter-rouge">Applicative</code> into a valid <code class="language-plaintext highlighter-rouge">Monoid</code> if the inner type is a <code class="language-plaintext highlighter-rouge">Monoid</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Note: we need a TypeRep to get empty!</span>
<span class="kd">const</span> <span class="nx">MyApplicative</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// Whatever your instance is...</span>
  <span class="c1">// const MyApp = daggy.tagged(&apos;MyApp&apos;, [&apos;x&apos;])</span>
  <span class="c1">// Put your map/ap/of here...</span>

  <span class="c1">// concat :: Semigroup a =&gt; MyApp a</span>
  <span class="c1">//                       ~&gt; MyApp a</span>
  <span class="c1">//                       -&gt; MyApp a</span>
  <span class="nx">MyApp</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">lift2</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">y</span><span class="p">),</span>
                   <span class="k">this</span><span class="p">,</span> <span class="nx">that</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="c1">// empty :: Monoid a =&gt; () -&gt; MyApp a</span>
  <span class="nx">MyApp</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">MyApp</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

  <span class="k">return</span> <span class="nx">MyApp</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above will <em>always</em> be <strong>valid</strong>. Notice that it doesn&#x2019;t care about the shape of our <code class="language-plaintext highlighter-rouge">Applicative</code> at all - we can write these implementations using just the <strong>interface</strong> (<code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">ap</code>, and <code class="language-plaintext highlighter-rouge">of</code>) for <em>any</em> applicative. Of course, <code class="language-plaintext highlighter-rouge">Applicative</code> types <em>can</em> use different implementations for <code class="language-plaintext highlighter-rouge">Monoid</code>. For example, look at <code class="language-plaintext highlighter-rouge">Maybe</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Usual implementation:</span>
<span class="nx">Just</span><span class="p">([</span><span class="mi">2</span><span class="p">]).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Just</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span> <span class="c1">// Just([2, 3])</span>
<span class="nx">Just</span><span class="p">([</span><span class="mi">2</span><span class="p">]).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>   <span class="c1">// Just([2])</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Just</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>   <span class="c1">// Just([3])</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>     <span class="c1">// Nothing</span>

<span class="nx">Maybe</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Nothing</span>

<span class="c1">// With the above implementation:</span>
<span class="nx">Just</span><span class="p">([</span><span class="mi">2</span><span class="p">]).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Just</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span> <span class="c1">// Just([2, 3])</span>
<span class="nx">Just</span><span class="p">([</span><span class="mi">2</span><span class="p">]).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>   <span class="c1">// Nothing</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Just</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>   <span class="c1">// Nothing</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>     <span class="c1">// Nothing</span>

<span class="nx">Maybe</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Just</span><span class="p">(</span>
  <span class="nx">MyInnerType</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>
</code></pre></div></div>

<p>A type <em>might</em> have more than one implementation for any given typeclass (such as <code class="language-plaintext highlighter-rouge">Semigroup</code>); the choice is up to the <strong>implementer</strong> and the <strong>users</strong>! As we can see, <code class="language-plaintext highlighter-rouge">Maybe</code>&#x2019;s usual implementation probably works better. Particularly the <code class="language-plaintext highlighter-rouge">empty</code> bit.</p>

<p>Still, if we have an <code class="language-plaintext highlighter-rouge">Applicative</code> type, we know <strong>for sure</strong> that have at least <em>one</em> valid <code class="language-plaintext highlighter-rouge">Monoid</code> definition! <strong>Magical</strong>, <em>right</em>?</p>

<hr>

<p>All the <code class="language-plaintext highlighter-rouge">Apply</code> types we&#x2019;ve seen so far have, coincidentally, been <code class="language-plaintext highlighter-rouge">Applicative</code>. We can see it&#x2019;s pretty easy in many cases to make an <code class="language-plaintext highlighter-rouge">of</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="nx">Either</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nb">Function</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">x</span>
<span class="nx">Maybe</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nx">Task</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</code></pre></div></div>

<p>We&#x2019;re really just constructing the simplest possible value within a type that can hold a value for us. No tricks, nothing fancy. Even <code class="language-plaintext highlighter-rouge">Task</code>, if you remember our <code class="language-plaintext highlighter-rouge">Promise</code> analogy, is about as routine as we could make it. However, let&#x2019;s talk about <strong>pairs</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pair :: (l, r) -&gt; Pair l r</span>
<span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">x</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">y</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// Map over the RIGHT side. The functor</span>
<span class="c1">// is `Pair l` and `r` is the inner type.</span>
<span class="c1">// map :: Pair l r ~&gt; (r -&gt; s)</span>
<span class="c1">//                 -&gt; Pair l s</span>
<span class="nx">Pair</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Pair</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Apply this to that, retain this&apos; left.</span>
<span class="c1">// ap :: Pair l r ~&gt; Pair l (r -&gt; s)</span>
<span class="c1">//                -&gt; Pair l s</span>
<span class="nx">Pair</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Pair</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">that</span><span class="p">.</span><span class="nx">y</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// But wait...</span>
<span class="c1">// of :: r -&gt; Pair l r</span>
<span class="nx">Pair</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Pair</span><span class="p">({</span><span class="nx">WHAT</span> <span class="nx">GOES</span> <span class="nx">HERE</span><span class="p">},</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>&#x2026; <em>Ah</em>. Look at the signature for <code class="language-plaintext highlighter-rouge">of</code> - there&#x2019;s a magical <code class="language-plaintext highlighter-rouge">l</code> value that just appears! We don&#x2019;t know what type it is, so we don&#x2019;t know what it can do, which means we can&#x2019;t find a value to fill this gap. Sure, we can <code class="language-plaintext highlighter-rouge">ap</code> - because we have two <code class="language-plaintext highlighter-rouge">l</code> values to choose from! - but we can&#x2019;t <code class="language-plaintext highlighter-rouge">of</code>.</p>

<p>How do we solve this? With the same <em>magical</em> pattern that has been going on throughout this post: we require <code class="language-plaintext highlighter-rouge">l</code> to be a <code class="language-plaintext highlighter-rouge">Monoid</code>. If <code class="language-plaintext highlighter-rouge">l</code> is a <code class="language-plaintext highlighter-rouge">Monoid</code>, we know we can call <code class="language-plaintext highlighter-rouge">l.empty()</code> to get a value for that gap!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TypeRep!</span>
<span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">Pair_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">x</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">y</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="c1">// And now we&apos;re fine! Hooray!</span>
  <span class="nx">Pair_</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Pair_</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">empty</span><span class="p">(),</span> <span class="nx">x</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">Pair_</span>
<span class="p">}</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>

<span class="c1">// SUCCESS!</span>
<span class="kd">const</span> <span class="nx">MyPair</span> <span class="o">=</span> <span class="nx">Pair</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span>
<span class="nx">MyPair</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// Pair([], 2)</span>
</code></pre></div></div>

<blockquote>
  <p>So, an <code class="language-plaintext highlighter-rouge">Apply</code> is an <code class="language-plaintext highlighter-rouge">Applicative</code> without <code class="language-plaintext highlighter-rouge">of</code>. An <code class="language-plaintext highlighter-rouge">Applicative</code> without <code class="language-plaintext highlighter-rouge">ap</code> also has a name: <a href="https://hackage.haskell.org/package/pointed-5/docs/Data-Pointed.html"><code class="language-plaintext highlighter-rouge">Pointed</code></a>. However, there are <strong>no laws</strong> attached to it independently, so it&#x2019;s not particularly useful on its own - just a bit of trivia!</p>
</blockquote>

<hr>

<p>That, good people of The Internet, is <em>all</em> there is to <code class="language-plaintext highlighter-rouge">Applicative</code>. Most of this was covered in the last post, so there are hopefully no great surprises. The important take away is that the relationship between <code class="language-plaintext highlighter-rouge">Semigroup</code> and <code class="language-plaintext highlighter-rouge">Monoid</code> is <em>very</em> similar to that of <code class="language-plaintext highlighter-rouge">Apply</code> and <code class="language-plaintext highlighter-rouge">Applicative</code>. This isn&#x2019;t the last time we&#x2019;ll see such a relationship, either! Isn&#x2019;t it weird how everything&#x2019;s <strong>connected</strong>? Baffles me, at least.</p>

<p>Anyway, I hope this has been useful, and, as always, <a href="http://twitter.com/am_i_tom">I&#x2019;m available on twitter</a> to answer any questions you might have. Next time, we&#x2019;ll be tackling <code class="language-plaintext highlighter-rouge">Alt</code>. Don&#x2019;t worry: it&#x2019;s going to be pretty familiar-looking if you&#x2019;ve been through all the posts in this series. Until then, though, go forth and <code class="language-plaintext highlighter-rouge">Apply</code>!</p>

<p>Thank you <em>so much</em> for reading, and take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 11: Foldable</h1>
  <span class="post-date">01 May 2017</span>
  <p>Welcome back, Fantasists! This week has been <strong>hectic</strong>, so I haven&#x2019;t caught up the <a href="http://github.com/i-am-tom/fantas-eel-and-specification">companion repository</a> as I&#x2019;d hoped to. However, I should have some time to devote to it this week, so watch this space! Anyway, why don&#x2019;t we have some <strong>down time</strong> before we get onto the <strong>really grizzly</strong> parts of the spec? Let&#x2019;s take a look at <code class="language-plaintext highlighter-rouge">Foldable</code>.</p>

<p>Wouldn&#x2019;t you know it, this one comes with a <strong>new function</strong> to add to our repertoire, and it&#x2019;s one that might look a bit <em>familiar</em> to some readers:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reduce</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span>
  <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>Do we already know of any <code class="language-plaintext highlighter-rouge">Foldable</code> types? I&#x2019;ll suggest one:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Array</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">reduce</span> <span class="o">::</span>
  <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">~&gt;</span> <span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>Straight away, <code class="language-plaintext highlighter-rouge">Array</code> is a valid <code class="language-plaintext highlighter-rouge">Foldable</code> type. In fact, Fantasy Land&#x2019;s <code class="language-plaintext highlighter-rouge">Foldable</code> was <em>deliberately</em> modelled after <code class="language-plaintext highlighter-rouge">Array</code>. Why? Because this structure <strong>generalises</strong> <code class="language-plaintext highlighter-rouge">Array.reduce</code>. <strong>Bam</strong>. With that in mind, let&#x2019;s look at its law:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">toArray</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="nx">x</span><span class="p">]),</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="nx">u</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">toArray</span><span class="p">(</span><span class="nx">u</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div></div>

<p>This is a <strong>really</strong> weird law because it&#x2019;s not very&#x2026; rigorous. You&#x2019;re unlikely to write a <code class="language-plaintext highlighter-rouge">Foldable</code> and get this wrong, because the <code class="language-plaintext highlighter-rouge">reduce</code> in <code class="language-plaintext highlighter-rouge">toArray</code> probably works in the exact same way as the <code class="language-plaintext highlighter-rouge">reduce</code> outside. In fact, it&#x2019;s probably best to look at this more as a <strong>behaviour</strong> than a <strong>law</strong>. <em>You still have to obey it, though!</em></p>

<p>There&#x2019;s a <em>lot</em> of space for interpretation here, which isn&#x2019;t necessarily a good thing. <strong>On the other hand</strong>, it makes it really easy to give some examples!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// reduce :: Maybe a</span>
<span class="c1">//        ~&gt; ((b, a) -&gt; b, b) -&gt; b</span>
<span class="nx">Maybe</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduce</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="c1">// Call the function...</span>
      <span class="na">Just</span><span class="p">:</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">),</span>

      <span class="c1">// ... or don&apos;t!</span>
      <span class="na">Nothing</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">acc</span>
    <span class="p">})</span>
  <span class="p">}</span>

<span class="c1">// reduce :: Either e a</span>
<span class="c1">//        ~&gt; ((b, a) -&gt; b, b) -&gt; b</span>
<span class="nx">Either</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduce</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="c1">// Call the function...</span>
      <span class="na">Right</span><span class="p">:</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">),</span>

      <span class="c1">// Or don&apos;t!</span>
      <span class="na">Left</span><span class="p">:</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">acc</span>
    <span class="p">})</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">Nothing</code> and <code class="language-plaintext highlighter-rouge">Left</code> represent <strong>failure</strong>, we just return the accumulator. Otherwise, we can use our <code class="language-plaintext highlighter-rouge">f</code> function once. These examples really just highlight that you don&#x2019;t <em>need</em> a structure with (potentially) multiple values in order to write a <code class="language-plaintext highlighter-rouge">Foldable</code> instance. However, it&#x2019;s definitely <strong>most useful</strong> when that&#x2019;s the case. For example, let&#x2019;s build a <strong>binary tree</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BTree a</span>
<span class="kd">const</span> <span class="nx">BTree</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">taggedSum</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">BTree</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Recursion!</span>
  <span class="c1">// Node (BTree a) a (BTree a)</span>
  <span class="na">Node</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">left</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">x</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">right</span><span class="dl">&apos;</span><span class="p">],</span>

  <span class="c1">// Leaf</span>
  <span class="na">Leaf</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>So, <code class="language-plaintext highlighter-rouge">Node</code>s represent &#x201C;branch points&#x201D; of the tree with values, and <code class="language-plaintext highlighter-rouge">Leaf</code>s represent the ends of branches. Because <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code> are also <code class="language-plaintext highlighter-rouge">BTree</code> instances, this gives us a recursive tree construction:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">Leaf</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">BTree</span>

<span class="c1">//      3</span>
<span class="c1">//     / \</span>
<span class="c1">//    1   5</span>
<span class="c1">//   /|   |\</span>
<span class="c1">//  X 2   4 X</span>
<span class="c1">//   /|   |\</span>
<span class="c1">//  X X   X X</span>
<span class="kd">const</span> <span class="nx">MyTree</span> <span class="o">=</span>
  <span class="nx">Node</span><span class="p">(</span>
    <span class="nx">Node</span><span class="p">(</span>
      <span class="nx">Leaf</span><span class="p">,</span>
      <span class="mi">1</span><span class="p">,</span>
      <span class="nx">Node</span><span class="p">(</span>
        <span class="nx">Leaf</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">,</span>
        <span class="nx">Leaf</span> <span class="p">)</span> <span class="p">),</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="nx">Node</span><span class="p">(</span>
      <span class="nx">Node</span><span class="p">(</span>
        <span class="nx">Leaf</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">,</span>
        <span class="nx">Leaf</span> <span class="p">),</span>
      <span class="mi">5</span><span class="p">,</span>
      <span class="nx">Leaf</span> <span class="p">)</span> <span class="p">)</span>
</code></pre></div></div>

<p><em>I&#x2019;m too ashamed to say how long I spent drawing that tree.</em> Now, <code class="language-plaintext highlighter-rouge">Array.reduce</code> combines all our values together (<em>if your <a href="/2017/03/13/fantas-eel-and-specification-4/"><code class="language-plaintext highlighter-rouge">Semigroup</code></a> or <a href="/2017/03/21/fantas-eel-and-specification-5/"><code class="language-plaintext highlighter-rouge">Monoid</code></a> klaxon just sounded, then I&#x2019;m super proud &#x2665;</em>) from left to right, so that&#x2019;s probably what we want to imitate with this tree. How do we do that? With <strong>magical recursion</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">BTree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduce</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">Node</span><span class="p">:</span> <span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Reduce the tree on the left...</span>
        <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span>

        <span class="c1">// Plus the middle element...</span>
        <span class="kd">const</span> <span class="nx">leftAndMiddle</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>

        <span class="c1">// And then the right tree...</span>
        <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">leftAndMiddle</span><span class="p">)</span>
      <span class="p">},</span>

      <span class="c1">// Return what we started with!</span>
      <span class="na">Leaf</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">acc</span>
    <span class="p">})</span>
  <span class="p">}</span>

<span class="nx">MyTree</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 15</span>
</code></pre></div></div>

<p><strong>Woo</strong>! We reduce the tree starting from the <strong>left-most</strong> element and work across. Whenever we hit a <code class="language-plaintext highlighter-rouge">Node</code>, we just <strong>recurse</strong> and do the same thing!</p>

<p>We saw at the end of the last snippet that we can find the <strong>sum</strong> of all the elements, and we could just as easily write <code class="language-plaintext highlighter-rouge">min</code>, <code class="language-plaintext highlighter-rouge">max</code>, <code class="language-plaintext highlighter-rouge">product</code>, or whatever. In fact, <a href="/2017/02/24/reductio-and-abstract-em/">you can do anything with <code class="language-plaintext highlighter-rouge">Array.reduce</code></a> and generalise it to all <code class="language-plaintext highlighter-rouge">Foldable</code> types immediately! Whether we then have a <code class="language-plaintext highlighter-rouge">Maybe</code>, an <code class="language-plaintext highlighter-rouge">Array</code>, or even a <code class="language-plaintext highlighter-rouge">BTree</code>, our functions will <strong>Just Work&#x2122;</strong>!</p>

<hr>

<p><code class="language-plaintext highlighter-rouge">Product</code>? <code class="language-plaintext highlighter-rouge">Min</code>? <code class="language-plaintext highlighter-rouge">Max</code>? This really does sound like <code class="language-plaintext highlighter-rouge">Monoid</code> again, doesn&#x2019;t it? Well, there are <strong>no coincidences</strong> in Fantasy Land. Back in <a href="/2017/03/21/fantas-eel-and-specification-5/">the <code class="language-plaintext highlighter-rouge">Monoid</code> post</a>, we wrote the <code class="language-plaintext highlighter-rouge">fold</code> function:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A friendly neighbourhood monoid fold.</span>
<span class="c1">// fold :: Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m</span>
<span class="kd">const</span> <span class="nx">fold</span> <span class="o">=</span> <span class="nx">M</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">M</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span>
  <span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>
</code></pre></div></div>

<p>With our new-found <code class="language-plaintext highlighter-rouge">Foldable</code> knowledge, we now know that this type signature is <strong>too specific</strong>. Let&#x2019;s fix it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fold</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">m</span><span class="p">)</span>
     <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span>
</code></pre></div></div>

<p>Yes, this function will in fact work with <strong>any</strong> <code class="language-plaintext highlighter-rouge">Foldable</code> structure and <strong>any</strong> <code class="language-plaintext highlighter-rouge">Monoid</code> - you&#x2019;ll never need to write <code class="language-plaintext highlighter-rouge">reduce</code> again! Get comfortable with <a href="https://joneshf.github.io/programming/2015/12/31/Comonads-Monoids-and-Trees.html">using <code class="language-plaintext highlighter-rouge">Monoid</code> for reductions</a>; it&#x2019;s definitely a good way to make your code more <strong>declarative</strong>, and hence more <strong>readable</strong>. I know you&#x2019;re probably <em>sick</em> of hearing about monoids, but they really are <strong>everywhere</strong>!</p>

<hr>

<p>It turns out that <em>many</em> of your favourite <code class="language-plaintext highlighter-rouge">Functor</code> types have sensible implementations for <code class="language-plaintext highlighter-rouge">reduce</code>. However, there are <strong>exceptions</strong>:</p>

<p>We can&#x2019;t <code class="language-plaintext highlighter-rouge">reduce</code> <a href="https://github.com/folktale/data.task/">the <code class="language-plaintext highlighter-rouge">Task</code> type</a> because we don&#x2019;t know what the inner values are going to be! It&#x2019;s the same with <code class="language-plaintext highlighter-rouge">Function</code>: we don&#x2019;t know what the return value is going to be until we give it an <strong>argument</strong>. Remember: <strong>functors&#x2019; inner values aren&#x2019;t always reachable</strong>.</p>

<blockquote>
  <p>Incidentally, if a <code class="language-plaintext highlighter-rouge">Functor</code> <em>does</em> have an always-reachable inner value, we can call it <a href="https://hackage.haskell.org/package/pointed-5/docs/Data-Copointed.html">a <code class="language-plaintext highlighter-rouge">Copointed</code> functor</a>. Remember how <a href="/2017/04/17/fantas-eel-and-specification-9/"><code class="language-plaintext highlighter-rouge">Applicative</code>&#x2019;s <code class="language-plaintext highlighter-rouge">of</code> is a function of <code class="language-plaintext highlighter-rouge">Pointed</code></a> functors? Think about the relationship between <code class="language-plaintext highlighter-rouge">Pointed</code> and <code class="language-plaintext highlighter-rouge">Copointed</code>. There are <strong>no coincidences</strong> in Fantasy Land!</p>
</blockquote>

<hr>

<p>This week, why not make a <code class="language-plaintext highlighter-rouge">Foldable</code> <strong>Rose Tree</strong>? Or <strong>Set</strong>? There are plenty of opportunities to practise here. Before we go, some of you may have noticed that you can <code class="language-plaintext highlighter-rouge">reduce</code> most things by just returning the <strong>initial value</strong> given to you:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">MyType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduce</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span>
</code></pre></div></div>

<p>It satisfies the &#x201C;law&#x201D;, right? This is what I mean: this law is <strong>not a good&#x2019;un</strong>, and leaves too much room for interpretation. Still, there&#x2019;s no point in <em>moaning</em>: we&#x2019;ll see next time that <code class="language-plaintext highlighter-rouge">Traversable</code> (my <strong>all-time favourite</strong> part of the Fantasy Land spec!) saves the day! From now on, Fantasists, the excitement is <strong>non-stop</strong>.</p>

<p>&#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Pairs as Functors</h1>
  <span class="post-date">27 Apr 2017</span>
  <p>Two-ish weeks ago, we talked about the <a href="/2017/04/15/functions-as-functors/">wonderful flexibility of <code class="language-plaintext highlighter-rouge">Function</code></a> when you start treating it as a <code class="language-plaintext highlighter-rouge">Functor</code>. We started off with <strong>composition</strong>, then <strong>branching</strong> composition, and then finally <strong>environment-aware</strong> composition. We also gave our humble function a new name: <code class="language-plaintext highlighter-rouge">Reader</code>. Today, we&#x2019;re going to walk the same path for <code class="language-plaintext highlighter-rouge">Pair</code>, and build up a closely-related idea.</p>

<h2 id="functor"><code class="language-plaintext highlighter-rouge">Functor</code></h2>

<p>It&#x2019;s pretty simple to write an implementation of <code class="language-plaintext highlighter-rouge">Functor</code> for a <code class="language-plaintext highlighter-rouge">Pair a b</code> structure:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">_1</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">_2</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// We just transform the second value!</span>
<span class="c1">// map :: Pair a b ~&gt; (b -&gt; c) -&gt; Pair a c</span>
<span class="nx">Pair</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Pair</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We transform the second half, but leave the first alone. I&#x2019;m going to suggest that we treat the <code class="language-plaintext highlighter-rouge">Pair</code> functor as a way of modelling <strong>values with metadata</strong> - some <strong>extra information</strong> about the value. I&#x2019;ll admit that this, in isolation, is not particularly useful. However, we&#x2019;ll see that, with some extra functionality provided by <code class="language-plaintext highlighter-rouge">ap</code> and <code class="language-plaintext highlighter-rouge">chain</code>, it&#x2019;ll start to make sense.</p>

<h2 id="applicative"><code class="language-plaintext highlighter-rouge">Applicative</code></h2>

<p>Now, let&#x2019;s make something <em>interesting</em>. Turns out that one useful <code class="language-plaintext highlighter-rouge">Applicative</code> implementation requires the left-hand side to be a <code class="language-plaintext highlighter-rouge">Monoid</code>. We can implement this like so:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Pair_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">_1</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">_2</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="nx">Pair_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Pair_</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="nx">Pair_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Pair_</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">_1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">),</span>
                 <span class="nx">fs</span><span class="p">.</span><span class="nx">_2</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="nx">Pair_</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">Pair_</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">empty</span><span class="p">(),</span> <span class="nx">x</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">Pair_</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><em>As usual, note that only a <code class="language-plaintext highlighter-rouge">Semigroup</code> is required for <code class="language-plaintext highlighter-rouge">Apply</code>, but <code class="language-plaintext highlighter-rouge">of</code> needs <code class="language-plaintext highlighter-rouge">empty</code> to produce a valid left-hand value</em>.</p>
</blockquote>

<p>Turns out this is a pretty useful implementation, which is definitely made more readable with some help from <code class="language-plaintext highlighter-rouge">lift2</code>. <em>Readers of the Fantasy Land series will remember <a href="http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/">the post on <code class="language-plaintext highlighter-rouge">Apply</code></a>, where we discussed <code class="language-plaintext highlighter-rouge">lift2</code> as a way of &#x201C;combining contexts&#x201D; with a given function.</em> Let&#x2019;s imagine we have a set of actions that have &#x201C;costs&#x201D;. We can write them as a <code class="language-plaintext highlighter-rouge">Pair</code> with <code class="language-plaintext highlighter-rouge">Sum</code> as the left-side monoid:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CostPair</span> <span class="o">=</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)</span>

<span class="c1">//- Database lookups are pretty costly...</span>
<span class="c1">//+ userFromDB :: Int</span>
<span class="c1">//+            -&gt; Pair (Sum Int) String</span>
<span class="kd">const</span> <span class="nx">nameFromDB</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="nx">CostPair</span><span class="p">(</span>
  <span class="nx">Sum</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="nx">getUserById</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>

<span class="c1">//- ... but ordering/counting is harder.</span>
<span class="c1">//+ rankFromDB :: Int</span>
<span class="c1">//+            -&gt; Pair (Sum Int) Int</span>
<span class="kd">const</span> <span class="nx">rankFromDB</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="nx">CostPair</span><span class="p">(</span>
  <span class="nx">Sum</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="nx">getUserRankById</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>

<span class="c1">//- Do both jobs, end up with Sum(600)!</span>
<span class="c1">//+ getUserData :: Int</span>
<span class="c1">//+             -&gt; Pair (Sum Int) User</span>
<span class="kd">const</span> <span class="nx">getUserData</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="nx">lift2</span><span class="p">(</span>
  <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="na">rank</span><span class="p">:</span> <span class="nx">y</span> <span class="p">}),</span>
  <span class="nx">nameFromDB</span><span class="p">(</span><span class="nx">id</span><span class="p">),</span> <span class="nx">rankFromDB</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>

<span class="c1">// ===================== //</span>

<span class="c1">//- By the way, we can use `Function` as an</span>
<span class="c1">//- `Applicative` as we did last time, and</span>
<span class="c1">//- that lets us write this with a couple</span>
<span class="c1">//- of `lift2` calls! Beautiful point-free!</span>
<span class="c1">//+ getUserData_ :: Int</span>
<span class="c1">//+              -&gt; Pair (Sum Int) User</span>
<span class="kd">const</span> <span class="nx">getUserData_</span> <span class="o">=</span> <span class="nx">lift2</span><span class="p">(</span>
  <span class="nx">lift2</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="na">rank</span><span class="p">:</span> <span class="nx">y</span> <span class="p">}),</span>
  <span class="nx">nameFromDB</span><span class="p">,</span> <span class="nx">rankFromDB</span><span class="p">)</span>
</code></pre></div></div>

<p>So, we can collect the &#x201C;cost&#x201D; of our computation as we go, which we could then analyse at the end. As we said with <code class="language-plaintext highlighter-rouge">Functor</code>, the <code class="language-plaintext highlighter-rouge">Pair</code> allows for <strong>metadata</strong>, which, in this case, is cost of computation. We could also swap out <code class="language-plaintext highlighter-rouge">Sum</code> for <code class="language-plaintext highlighter-rouge">Max</code> to find the most expensive operation in our app, or <code class="language-plaintext highlighter-rouge">Average</code> to&#x2026; well, find the average!</p>

<h2 id="monad"><code class="language-plaintext highlighter-rouge">Monad</code></h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="nx">Pair_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">Pair_</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">_1</span><span class="p">),</span>
                 <span class="nx">that</span><span class="p">.</span><span class="nx">_2</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Again, <code class="language-plaintext highlighter-rouge">Monad</code> requires <code class="language-plaintext highlighter-rouge">of</code> (<code class="language-plaintext highlighter-rouge">Applicative</code>) and thus needs a <code class="language-plaintext highlighter-rouge">Monoid</code> for the left side. <code class="language-plaintext highlighter-rouge">Chain</code> doesn&#x2019;t require <code class="language-plaintext highlighter-rouge">of</code>, and so we can get away with a <code class="language-plaintext highlighter-rouge">Semigroup</code>.</p>
</blockquote>

<p>This <code class="language-plaintext highlighter-rouge">chain</code> function allows us to string actions together, while also collecting a value in the monoid, as we did before. Of course, this will work with the <code class="language-plaintext highlighter-rouge">CostPair</code> we defined above, but let&#x2019;s try something a bit different. Let&#x2019;s instead use <code class="language-plaintext highlighter-rouge">[String]</code> as our monoid, and play some <a href="https://en.wikipedia.org/wiki/Guess_Who%3F">Guess Who?</a></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sneaky monkey patch!</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>

<span class="nx">LogPair</span> <span class="o">=</span> <span class="nx">Pair</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span>

<span class="c1">// Lift the users into the LogPair type.</span>
<span class="c1">// (The left side at this point is [])</span>
<span class="nx">LogPair</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="nx">users</span><span class="p">)</span>

<span class="c1">// Keep only the users with brown hair</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">users</span> <span class="o">=&gt;</span> <span class="nx">LogPair</span><span class="p">(</span>
  <span class="p">[</span><span class="dl">&apos;</span><span class="s1">Brown hair</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="nx">users</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">hair</span> <span class="o">===</span> <span class="dl">&apos;</span><span class="s1">brown</span><span class="dl">&apos;</span><span class="p">)))</span>

<span class="c1">// Keep only the users over 180cm tall</span>
<span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">users</span> <span class="o">=&gt;</span> <span class="nx">LogPair</span><span class="p">(</span>
  <span class="p">[</span><span class="dl">&apos;</span><span class="s1">Tall</span><span class="dl">&apos;</span><span class="p">],</span>
  <span class="nx">users</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">height</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">)))</span>

<span class="c1">// Count the remaining users</span>
<span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">users</span> <span class="o">=&gt;</span> <span class="nx">users</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>

<span class="c1">// e.g.: Pair([&apos;Brown Hair&apos;, &apos;Tall&apos;], 36)</span>
</code></pre></div></div>

<p>We can see that our final result is another <code class="language-plaintext highlighter-rouge">Pair</code>, whose right side holds the number of remaining users, as we&#x2019;d expect. However, the left side is now a list of all the actions that got us to that number! If you built your whole app inside the <code class="language-plaintext highlighter-rouge">Pair</code> monad, you would have a purely-functional <strong>logger</strong>, to which you could write any number of messages at any time. On top of that, <code class="language-plaintext highlighter-rouge">Array</code>&#x2019;s <code class="language-plaintext highlighter-rouge">Monoid</code> implementation doesn&#x2019;t care about the <em>inner</em> type, so you can log any data structure you want!</p>

<p>This nifty little pattern - writing something to a log (or really just appending to a monoid) while transforming the other value - is what gives this type the common name <code class="language-plaintext highlighter-rouge">Writer</code>. It is, in essence, the opposite of <code class="language-plaintext highlighter-rouge">Reader</code>: <code class="language-plaintext highlighter-rouge">Reader</code> can <em>read</em> from some &#x201C;global&#x201D; state, <code class="language-plaintext highlighter-rouge">Writer</code> can <em>write</em> to some &#x201C;global&#x201D; state.</p>

<hr>

<p>So, we&#x2019;ve seen that, through a different lens, <code class="language-plaintext highlighter-rouge">s -&gt; a</code> is a <code class="language-plaintext highlighter-rouge">Reader</code>, and <code class="language-plaintext highlighter-rouge">(s, a)</code> is a <code class="language-plaintext highlighter-rouge">Writer</code>. We have <strong>readable or writable state</strong>, and they&#x2019;re purely functional! There&#x2019;s only one downside, though: what if we want <em>both</em>?</p>

<p>Think about what state <em>is</em> in stateful languages. It&#x2019;s a thing that can change as a result of <strong>any instruction</strong>. This means, really, our stateful languages execute functions kinda like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">execute</span> <span class="o">::</span> <span class="p">(</span><span class="kt">State</span><span class="p">,</span> <span class="kt">Action</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span>
</code></pre></div></div>

<p>We take an <strong>instruction</strong> (<code class="language-plaintext highlighter-rouge">Action</code>) and the <strong>current state</strong>, and we get back a potentially <strong>new state</strong>. Maybe something has been written the console, maybe a variable has been updated, etc. That&#x2019;s really the most abstract that we can make it, and will look familiar to users of packages like <a href="http://redux.js.org/docs/basics/Reducers.html#handling-actions">Redux</a>. Now, take a closer look at <code class="language-plaintext highlighter-rouge">execute</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--                FUNCTION v</span>
<span class="n">execute</span> <span class="o">::</span> <span class="p">(</span><span class="kt">State</span><span class="p">,</span> <span class="kt">Action</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span>
<span class="c1">--               ^ PAIR</span>
</code></pre></div></div>

<p><strong>OMGWTF</strong>. Turns out that <code class="language-plaintext highlighter-rouge">execute</code> is a combination of <code class="language-plaintext highlighter-rouge">Reader</code> and <code class="language-plaintext highlighter-rouge">Writer</code>! Well, if we can make <strong>read-only</strong> state purely functional, and <strong>write-only</strong> state purely functional, and we can see that <code class="language-plaintext highlighter-rouge">State</code> is really just a combination of the two&#x2026; there has to be a way to build purely functional <strong>read and write</strong> state, right?</p>

<p><strong>Right</strong>. Next time, we&#x2019;ll look at the <code class="language-plaintext highlighter-rouge">State</code> type, and see how we can combine these two principles to give us everything we need to combat those <strong>pesky naysayers</strong> who think functional programming is impractical. <strong>Get excited</strong>!</p>

<p>&#x2665;</p>

<p><em>PS: if you want to play with the code in this post, I&#x2019;ve put <a href="https://gist.github.com/i-am-tom/286cb133f74404305814e311e7162351">all the code in a Gist</a>, so why not mess around with it?</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Functions as Functors</h1>
  <span class="post-date">15 Apr 2017</span>
  <p>Hello! I was explaining the other day how <code class="language-plaintext highlighter-rouge">Function</code>&#x2019;s implementations of the different typeclasses can be useful, and I thought I might as well write them up in case they can be useful to someone. It&#x2019;s also <em>much</em> easier than writing <strong>140-character blocks</strong>. Specifically, we&#x2019;ll go through <code class="language-plaintext highlighter-rouge">Functor</code>, <code class="language-plaintext highlighter-rouge">Apply</code>, and <code class="language-plaintext highlighter-rouge">Chain</code>, with examples all the way.</p>

<p>In all these cases, I&#x2019;ve represented the <code class="language-plaintext highlighter-rouge">Function</code> type as <code class="language-plaintext highlighter-rouge">((-&gt;) x)</code>. So, <code class="language-plaintext highlighter-rouge">Function a</code> means <code class="language-plaintext highlighter-rouge">((-&gt;) x) a</code>, which <em>probably</em> looks more familiar as <code class="language-plaintext highlighter-rouge">x -&gt; a</code>. Read it as, &#x201C;<em>A function from values of type</em> <code class="language-plaintext highlighter-rouge">x</code> <em>to values of type</em> <code class="language-plaintext highlighter-rouge">a</code>&#x201D;. I&#x2019;ve written the signatures in all three styles, along with the general rule where applicable.</p>

<h2 id="functor"><code class="language-plaintext highlighter-rouge">Functor</code></h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//       f  a ~&gt; (a -&gt; b) -&gt;       f  b</span>
<span class="c1">// Function a ~&gt; (a -&gt; b) -&gt; Function b</span>
<span class="c1">// ((-&gt;) x) a ~&gt; (a -&gt; b) -&gt; ((-&gt;) x) b</span>
<span class="c1">//  (x -&gt; a)  ~&gt; (a -&gt; b) -&gt;  (x -&gt; b)</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What <code class="language-plaintext highlighter-rouge">map</code> does is create a <em>new</em> function that calls the original, <em>and then</em> the mapping function, to build up a kind of pipeline:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myFunction</span> <span class="o">=</span>
  <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">// Returns &quot;7.5&quot;</span>
<span class="nx">myFunction</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello, world!</span><span class="dl">&apos;</span><span class="p">)</span>
</code></pre></div></div>

<p>Of course, you probably know of another tool for creating pipelines of functions:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The `map` we know and love.</span>
<span class="c1">// map :: Functor f =&gt; (b -&gt; c)</span>
<span class="c1">//                  -&gt; f b -&gt; f c</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

<span class="c1">// WHAT IF I TOLD YOU...</span>

<span class="c1">// Read `f` in the above as ((-&gt;) a)...</span>
<span class="c1">// compose :: (b -&gt; c)</span>
<span class="c1">//         -&gt; (a -&gt; b)</span>
<span class="c1">//         -&gt;  a -&gt; c</span>
<span class="kd">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="nx">map</span> <span class="c1">// WHAT</span>
</code></pre></div></div>

<p>I <em>know</em>, right?</p>

<h2 id="apply"><code class="language-plaintext highlighter-rouge">Apply</code></h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// f  a ~&gt; f (a -&gt; b)</span>
<span class="c1">//      -&gt; f  b</span>

<span class="c1">// Function a ~&gt; Function (a -&gt; b)</span>
<span class="c1">//            -&gt; Function b</span>

<span class="c1">// ((-&gt;) x) a ~&gt; ((-&gt;) x) (a -&gt; b)</span>
<span class="c1">//            -&gt; ((-&gt;) x) b</span>

<span class="c1">//  (x -&gt; a) ~&gt; (x -&gt; a -&gt; b)</span>
<span class="c1">//           -&gt;  (x -&gt; b)</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Some of you will know that I find <code class="language-plaintext highlighter-rouge">Apply</code> to be best appreciated through the lens of <code class="language-plaintext highlighter-rouge">lift2</code>. As mentioned in <a href="http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/">the <code class="language-plaintext highlighter-rouge">Apply</code> article of the Fantasy Land series</a>, <code class="language-plaintext highlighter-rouge">lift2</code> <em>combines</em> two contexts into one:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (a -&gt; b -&gt; c) -&gt; f a</span>
<span class="c1">//               -&gt; f b</span>
<span class="c1">//               -&gt; f c</span>

<span class="c1">// (a -&gt; b -&gt; c) -&gt; Function a</span>
<span class="c1">//               -&gt; Function b</span>
<span class="c1">//               -&gt; Function c</span>

<span class="c1">// (a -&gt; b -&gt; c) -&gt; ((-&gt;) x) a</span>
<span class="c1">//               -&gt; ((-&gt;) x) b</span>
<span class="c1">//               -&gt; ((-&gt;) x) c</span>

<span class="c1">// (a -&gt; b -&gt; c) -&gt; (x -&gt; a)</span>
<span class="c1">//               -&gt; (x -&gt; b)</span>
<span class="c1">//               -&gt; (x -&gt; c)</span>

<span class="kd">const</span> <span class="nx">lift2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
</code></pre></div></div>

<p>What we end up with is a function of one argument (type <code class="language-plaintext highlighter-rouge">x</code>), which applies to <code class="language-plaintext highlighter-rouge">f</code> the result of applying that argument to <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. Ramda fans may recognise this as <a href="http://ramdajs.com/docs/#converge"><code class="language-plaintext highlighter-rouge">converge</code></a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// From the Ramda docs:</span>
<span class="kd">const</span> <span class="nx">divide</span> <span class="o">=</span> <span class="nx">x</span>  <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span>

<span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">length</span>

<span class="c1">// divide(sum, length)</span>
<span class="c1">//   === 28 / 7 === 4</span>
<span class="kd">const</span> <span class="nx">average</span> <span class="o">=</span> <span class="nx">lift2</span><span class="p">(</span><span class="nx">divide</span><span class="p">,</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
<span class="nx">average</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="c1">// This generalises to liftN!</span>
<span class="kd">const</span> <span class="nx">lift3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>

<span class="c1">// Some password checks...</span>

<span class="kd">const</span> <span class="nx">longEnough</span> <span class="o">=</span>
  <span class="nx">length</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// Functor!</span>

<span class="kd">const</span> <span class="nx">hasNumber</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="kc">null</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\d</span><span class="sr">+/g</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">hasUppercase</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="kc">null</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">A-Z</span><span class="se">]</span><span class="sr">+/g</span><span class="p">)</span>

<span class="c1">// Some combining function...</span>
<span class="kd">const</span> <span class="nx">and3</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span>

<span class="c1">// Combine the three functions with and3</span>
<span class="kd">const</span> <span class="nx">passwordCheck</span> <span class="o">=</span> <span class="nx">lift3</span><span class="p">(</span>
  <span class="nx">and3</span><span class="p">,</span> <span class="nx">longEnough</span>
      <span class="p">,</span> <span class="nx">hasNumber</span>
      <span class="p">,</span> <span class="nx">hasUppercase</span><span class="p">)</span>

<span class="nx">passwordCheck</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">abcdef</span><span class="dl">&apos;</span><span class="p">)</span>    <span class="c1">// false</span>
<span class="nx">passwordCheck</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">abcdefghi</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">passwordCheck</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">abcdefgh1</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">passwordCheck</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Abcdefgh1</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>So, we can take a set of functions that act on the same type, and <strong>combine</strong> their outputs with another function. <strong>This is the magic of <code class="language-plaintext highlighter-rouge">ap</code></strong>.</p>

<h2 id="chain"><code class="language-plaintext highlighter-rouge">Chain</code></h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// m  a ~&gt; (a -&gt; m b)</span>
<span class="c1">//      -&gt; m b</span>

<span class="c1">// Function a ~&gt; (a -&gt; Function b)</span>
<span class="c1">//            -&gt; Function b</span>

<span class="c1">// ((-&gt;) x) a ~&gt; (a -&gt; ((-&gt;) x) b)</span>
<span class="c1">//            -&gt; ((-&gt;) x) b</span>

<span class="c1">//  (x -&gt; a) ~&gt; (a -&gt; x -&gt; b)</span>
<span class="c1">//           -&gt; x -&gt; b</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">chain</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">))(</span><span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Function</code> type also has a <code class="language-plaintext highlighter-rouge">Chain</code> implementation, with an eventual type that looks really similar to <code class="language-plaintext highlighter-rouge">Functor</code>. The difference this time, however, is that the intermediate function can <strong>access the <em>original</em> argument</strong>. No matter how many functions we <code class="language-plaintext highlighter-rouge">chain</code> together, the second argument to the <code class="language-plaintext highlighter-rouge">chain</code> function will always be of type <code class="language-plaintext highlighter-rouge">x</code>, and the value of the original input.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myNextFunction</span> <span class="o">=</span>
  <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">s</span> <span class="o">=&gt;</span>
    <span class="dl">&apos;</span><span class="s1">started from the </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">s</span>
      <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> now we </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">)</span>

<span class="c1">// started from the Hello! now we 4</span>
<span class="nx">myNextFunction</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello!</span><span class="dl">&apos;</span><span class="p">)</span>
</code></pre></div></div>

<p>So, after two <code class="language-plaintext highlighter-rouge">map</code> calls that transform the input entirely, <code class="language-plaintext highlighter-rouge">chain</code> <em>re-introduces</em> the original value. In fact, we can call <code class="language-plaintext highlighter-rouge">chain</code> <em>whenever</em> we want access to that initial value. We can&#x2019;t <em>modify</em> the value - it&#x2019;s effectively <strong>read-only</strong>. This is why the <code class="language-plaintext highlighter-rouge">Function</code> type, when used as a <code class="language-plaintext highlighter-rouge">Functor</code>, is often called <code class="language-plaintext highlighter-rouge">Reader</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Reader</code>&#x2019;s most obvious application is to provide a way of accessing some global application state (e.g. config or a database):</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a -&gt;       f  a</span>
<span class="c1">// a -&gt; Function a</span>
<span class="c1">// a -&gt; ((-&gt;) x) a</span>
<span class="c1">// a -&gt;   x -&gt; a</span>
<span class="nb">Function</span><span class="p">.</span><span class="k">of</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">x</span>

<span class="kd">const</span> <span class="nx">MyApp</span> <span class="o">=</span>
  <span class="c1">// Set a &quot;starting value&quot;... or just</span>
  <span class="c1">// a function that _takes_ a starting</span>
  <span class="c1">// value and THEN the environment!</span>
  <span class="nb">Function</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello, </span><span class="dl">&apos;</span><span class="p">)</span>

  <span class="c1">// Get a variable from environment,</span>
  <span class="c1">// augment the string.</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">isProduction</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="nx">x</span> <span class="o">+</span> <span class="p">(</span><span class="nx">isProduction</span> <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">customers</span><span class="dl">&apos;</span>
                      <span class="p">:</span> <span class="dl">&apos;</span><span class="s1">developers</span><span class="dl">&apos;</span><span class="p">))</span>

  <span class="c1">// Augment the string.</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span><span class="p">)</span>

  <span class="c1">// Get ANOTHER variable from the</span>
  <span class="c1">// environment, augment the string.</span>
  <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">caller</span> <span class="p">})</span> <span class="o">=&gt;</span>
    <span class="nx">caller</span> <span class="o">===</span> <span class="dl">&apos;</span><span class="s1">browser</span><span class="dl">&apos;</span>
    <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">&lt;h1&gt;</span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">&lt;/h1&gt;</span><span class="dl">&apos;</span>
    <span class="p">:</span> <span class="dl">&apos;</span><span class="s1">{ data: &quot;</span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">}&quot; }</span><span class="dl">&apos;</span><span class="p">)</span>

  <span class="c1">// Send to the consumer.</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">sendToConsumer</span><span class="p">)</span>

<span class="c1">// This object becomes our app&apos;s &quot;global</span>
<span class="c1">// config&quot;, and the function returns</span>
<span class="c1">// whatever `sendToConsumer` would if given</span>
<span class="c1">// &apos;{ data: &quot;hello, customers!&quot; }&apos;</span>
<span class="nx">MyApp</span><span class="p">({</span>
  <span class="na">isProduction</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">caller</span><span class="p">:</span> <span class="dl">&apos;</span><span class="s1">api</span><span class="dl">&apos;</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Here, our argument is a config object, and our app is free to pick bits out whenever it chooses. Also notice the <code class="language-plaintext highlighter-rouge">Function.of</code> at the top - this is the <code class="language-plaintext highlighter-rouge">Pointed</code> implementation. This was the ingredient missing from <code class="language-plaintext highlighter-rouge">Apply</code> for an <code class="language-plaintext highlighter-rouge">Applicative</code>, and from <code class="language-plaintext highlighter-rouge">Chain</code> for a <code class="language-plaintext highlighter-rouge">Monad</code>. Developers, meet <strong>the <code class="language-plaintext highlighter-rouge">Reader</code> monad</strong>, in all its glory.</p>

<p>I think <code class="language-plaintext highlighter-rouge">Function</code> provides three instances here that are of immediate benefit, and they all have uses in <strong>practical</strong> code! I hope you found this useful, and I hope to see a lot more uses of <code class="language-plaintext highlighter-rouge">Function</code> as a <code class="language-plaintext highlighter-rouge">Functor</code>  in the wild.</p>

<p>Until Monday, have fun, enjoy the long weekend, and take care! &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 10: Alt, Plus, and Alternative</h1>
  <span class="post-date">24 Apr 2017</span>
  <p>We&#x2019;re in <strong>double digits</strong>! Isn&#x2019;t this exciting? It also means that, by my estimations, we&#x2019;re <strong>well over half way</strong>! Before we get <em>too</em> excited by <code class="language-plaintext highlighter-rouge">Profunctor</code> and <code class="language-plaintext highlighter-rouge">Comonad</code>, though, might I tempt you with an&#x2026; <code class="language-plaintext highlighter-rouge">Alternative</code>?</p>

<p>Today, we&#x2019;re going to bundle together <strong>three</strong> very well-related entries in the spec, starting with <code class="language-plaintext highlighter-rouge">Alt</code>. This little typeclass has one function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alt</span> <span class="o">::</span> <span class="kt">Alt</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>As we know, with great algebraic structure, come great <strong>laws</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Associativity</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">alt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>

<span class="c1">// Distributivity</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">alt</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
</code></pre></div></div>

<p>The <strong>associativity</strong> law is <em>exactly</em> what we saw in <a href="/2017/03/13/fantas-eel-and-specification-4/">the <code class="language-plaintext highlighter-rouge">Semigroup</code> post</a> with <code class="language-plaintext highlighter-rouge">concat</code>! As we said back then, think of it as, &#x201C;<em>Keeping left-to-right order the same, you can combine the elements however you like</em>&#x201D;.</p>

<p><strong>Distributivity</strong> gives us another clue that we might be looking at something a bit <code class="language-plaintext highlighter-rouge">Semigroup</code>-flavoured. We can <strong><code class="language-plaintext highlighter-rouge">map</code> first</strong> over the elements and then <code class="language-plaintext highlighter-rouge">alt</code> <strong>or</strong> <strong><code class="language-plaintext highlighter-rouge">alt</code> first</strong> and then <code class="language-plaintext highlighter-rouge">map</code> over the result, and we&#x2019;ll end up at the <strong>same value</strong>. Either way, some kind of &#x201C;combination&#x201D; definitely seems to be going on here.</p>

<p>So, <strong>what is it</strong>? Well&#x2026; it&#x2019;s like a <strong>semigroup for functors</strong>. It&#x2019;s a way of combining values of a functor type <em>without</em> the requirement that the inner type be a <code class="language-plaintext highlighter-rouge">Semigroup</code>. <em>Why</em>, you ask? Well, we get a little hint from the name.</p>

<p><code class="language-plaintext highlighter-rouge">Alt</code> allows us to provide some <em>alternative</em> value as a &#x201C;fallback&#x201D; when the first &#x201C;fails&#x201D;. Of course, this is particularly relevant to types with some notion of <strong>failure</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Maybe</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">alt</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Just</span><span class="p">:</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">,</span>
    <span class="na">Nothing</span><span class="p">:</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">that</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we have a <code class="language-plaintext highlighter-rouge">Just</code> on the left, we return it. Otherwise, we <strong>fall back</strong> to the second value! Naturally, you can chain as many of these as you like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Just(3) - note the &quot;Nothing&quot;s are</span>
<span class="c1">// usually the result of some functions.</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">).</span><span class="nx">alt</span><span class="p">(</span><span class="nx">Just</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<p>It turns out there are <strong>loads</strong> of use cases for <code class="language-plaintext highlighter-rouge">alt</code>, which isn&#x2019;t too surprising if you look at it as a <strong>functor-level <code class="language-plaintext highlighter-rouge">if/else</code></strong>. You can do <a href="https://gist.github.com/i-am-tom/9651cd1e95443c4cbf3953429e988b07">database connection failover</a>, <a href="https://github.com/slamdata/purescript-routing/blame/master/GUIDE.md#L96-L102">API/resource routing</a>, and, most magically of all, <a href="https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Parser/Declarations.hs#L161-L169">text parsing</a>. <em>Those last two were in PureScript and Haskell respectively, but don&#x2019;t worry: in these languages, <code class="language-plaintext highlighter-rouge">alt</code> has an operator, written as <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code>.</em></p>

<p>The key thing all these cases have in common is that you want to <em>try</em> something with a contingency plan for <em>failure</em>. That&#x2019;s all there is to <code class="language-plaintext highlighter-rouge">Alt</code>!</p>

<hr>

<p>If <code class="language-plaintext highlighter-rouge">Alt</code> will be our functor-level <code class="language-plaintext highlighter-rouge">Semigroup</code>, what&#x2019;s our <strong>functor-level <code class="language-plaintext highlighter-rouge">Monoid</code></strong>? In comes <code class="language-plaintext highlighter-rouge">Plus</code>, which extends <code class="language-plaintext highlighter-rouge">Alt</code> with one more function called <code class="language-plaintext highlighter-rouge">zero</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zero</span> <span class="o">::</span> <span class="kt">Plus</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>Looks a bit like <code class="language-plaintext highlighter-rouge">Monoid</code>&#x2019;s <code class="language-plaintext highlighter-rouge">empty</code>, right? Note that there&#x2019;s no restriction on the <code class="language-plaintext highlighter-rouge">a</code>, so this <code class="language-plaintext highlighter-rouge">zero</code> value must work for <strong>any type</strong>. This one has <strong>three laws</strong>, but the first two will look really familiar to readers of <a href="/2017/03/21/fantas-eel-and-specification-5/">the <code class="language-plaintext highlighter-rouge">Monoid</code> post</a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right identity - zero on the right</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">())</span> <span class="o">===</span> <span class="nx">x</span>

<span class="c1">// Guess what this one&apos;s called?</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">().</span><span class="nx">alt</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">x</span>

<span class="c1">// The new one: annihilation</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">().</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">()</span>
</code></pre></div></div>

<p>The left and right <strong>identity</strong> laws just say, &#x201C;<em><code class="language-plaintext highlighter-rouge">zero</code> makes no difference to the other value, regardless of which side of <code class="language-plaintext highlighter-rouge">alt</code> you put it</em>&#x201D;. <strong>Annihilation</strong> gives us a stronger idea of what <code class="language-plaintext highlighter-rouge">zero</code> does: <strong>nothing</strong>! <code class="language-plaintext highlighter-rouge">Plus</code> types <em>must</em> be functors; for a <code class="language-plaintext highlighter-rouge">map</code> call to do <em>nothing</em> in all cases, the type must have the ability to be <strong>empty</strong>, whatever that means.</p>

<p>Think of our <code class="language-plaintext highlighter-rouge">Maybe</code> type: what can we <code class="language-plaintext highlighter-rouge">map</code> over with <em>any</em> function and not change the value? <code class="language-plaintext highlighter-rouge">Nothing</code>! In fact, <code class="language-plaintext highlighter-rouge">() =&gt; Nothing</code> is the <strong>only valid</strong> implementation of <code class="language-plaintext highlighter-rouge">zero</code> for <code class="language-plaintext highlighter-rouge">Maybe</code>.</p>

<p>What about <code class="language-plaintext highlighter-rouge">Array</code>? Well, <code class="language-plaintext highlighter-rouge">map</code> transforms every value in the array, so the only array that <em>wouldn&#x2019;t</em> be changed is the empty one. <code class="language-plaintext highlighter-rouge">() =&gt; []</code> is the <strong>only valid</strong> implementation of <code class="language-plaintext highlighter-rouge">zero</code> for <code class="language-plaintext highlighter-rouge">Array</code>.</p>

<blockquote>
  <p>We didn&#x2019;t cover <code class="language-plaintext highlighter-rouge">Array</code> as an <code class="language-plaintext highlighter-rouge">Alt</code> because it&#x2019;s a bit of a funny one. Back when we discussed <a href="/2017/03/27/fantas-eel-and-specification-6/">functors</a>, we saw that <code class="language-plaintext highlighter-rouge">Array</code> <em>extends</em> our language to allow us to represent <strong>several values</strong> at once. This can be thought of as <strong>non-determinism</strong> if we see an <code class="language-plaintext highlighter-rouge">Array</code> as the set of <strong>possible values</strong>. Thus, the <code class="language-plaintext highlighter-rouge">alt</code> implementation for <code class="language-plaintext highlighter-rouge">Array</code> is the same as <code class="language-plaintext highlighter-rouge">concat</code> - all we&#x2019;re doing is combining the two sets of possibilities!</p>
</blockquote>

<p>So, <code class="language-plaintext highlighter-rouge">Plus</code> adds to <code class="language-plaintext highlighter-rouge">Alt</code> what <code class="language-plaintext highlighter-rouge">Monoid</code> adds to <code class="language-plaintext highlighter-rouge">Semigroup</code>, and, in fact, what <code class="language-plaintext highlighter-rouge">Applicative</code> adds to <code class="language-plaintext highlighter-rouge">Apply</code>: an <strong>identity</strong>. Are we bored of this pattern yet? I hope not, because we&#x2019;re <em>still</em> not done with it! Incidentally, we can write custom <code class="language-plaintext highlighter-rouge">Semigroup</code> and <code class="language-plaintext highlighter-rouge">Monoid</code> types to encapsulate this behaviour so we can reuse the functions we talked about in their posts:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The value MUST be an Alt-implementer.</span>
<span class="kd">const</span> <span class="nx">Alt</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Alt</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">value</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// Alt is a valid semigroup!</span>
<span class="nx">Alt</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Alt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// The value MUST be a Plus-implementer.</span>
<span class="c1">// And, as usual, we need a TypeRep...</span>
<span class="kd">const</span> <span class="nx">Plus</span> <span class="o">=</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Plus_</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Plus</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">value</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="c1">// Plus is a valid semigroup...</span>
  <span class="nx">Plus_</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">Plus</span><span class="p">(</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span>
          <span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="c1">// ... and a valid monoid!</span>
  <span class="nx">Plus_</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Plus_</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">zero</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Monoids are <strong>everywhere</strong>, I tell you. Stare at something long enough and it&#x2019;ll start to look like a monoid.</p>

<hr>

<p>The final boss level on this <code class="language-plaintext highlighter-rouge">Alt</code> quest is <code class="language-plaintext highlighter-rouge">Alternative</code>. There are <strong>no special functions</strong> for this one, as it is simply the name for a structure that implements both <code class="language-plaintext highlighter-rouge">Plus</code> <em>and</em> <code class="language-plaintext highlighter-rouge">Applicative</code>. Still, I know how much you <em>love</em> laws:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Distributivity</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">g</span><span class="p">))</span> <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">alt</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">g</span><span class="p">))</span>

<span class="c1">// Annihilation</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">())</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">zero</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Distributivity</strong> is exactly as the same law that we saw with <code class="language-plaintext highlighter-rouge">Alt</code> and <code class="language-plaintext highlighter-rouge">map</code> at the beginning of all this, but now for <code class="language-plaintext highlighter-rouge">ap</code>. We can either <strong><code class="language-plaintext highlighter-rouge">alt</code> first</strong> and <em>then</em> <code class="language-plaintext highlighter-rouge">ap</code> the result to <code class="language-plaintext highlighter-rouge">x</code>, <strong>or</strong> we can <strong><code class="language-plaintext highlighter-rouge">ap</code> first</strong> to both separately, and then <code class="language-plaintext highlighter-rouge">alt</code>. Either way, we end up in the same place.</p>

<p><strong>Annihilation</strong> is a <em>really</em> scary word for a not-so-scary idea, if you think back to the <code class="language-plaintext highlighter-rouge">zero</code> values we discussed earlier. You couldn&#x2019;t apply a value to <code class="language-plaintext highlighter-rouge">Nothing</code>, right? Or an empty list of functions? The <strong>annihilation</strong> law defines this behaviour: if you try to do <strong>something with nothing</strong>, you get <strong>nothing</strong>. Whatever you were doing is considered a <em>failure</em>, and <code class="language-plaintext highlighter-rouge">zero</code> is returned.</p>

<p>You&#x2019;ll often hear <code class="language-plaintext highlighter-rouge">Alternative</code> types described as <strong>monoid-shaped applicatives</strong>, and this is a good intuition. We talked about <code class="language-plaintext highlighter-rouge">of</code> as being the <strong>identity</strong> of <code class="language-plaintext highlighter-rouge">Applicative</code>, but this is only at <strong>context-level</strong>. For an <code class="language-plaintext highlighter-rouge">Alternative</code> type, <code class="language-plaintext highlighter-rouge">zero</code> is the identity value at context- <strong>and</strong> value-level.</p>

<hr>

<p><code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">Either</code>: we&#x2019;ve seen a lot of types that can very naturally implement <code class="language-plaintext highlighter-rouge">Alternative</code>. You could even make <code class="language-plaintext highlighter-rouge">Function</code> an <code class="language-plaintext highlighter-rouge">Alternative</code> if you knew the output would be of a <code class="language-plaintext highlighter-rouge">Plus</code>-implementing type. With that, you could then write a function whose body can do <strong>extra computation</strong> depending on the result; who needs <code class="language-plaintext highlighter-rouge">if/else</code>?</p>

<p>That&#x2019;s about all there is to it! <code class="language-plaintext highlighter-rouge">Alt</code>, <code class="language-plaintext highlighter-rouge">Plus</code>, and <code class="language-plaintext highlighter-rouge">Alternative</code> are <strong>under-appreciated</strong> typeclasses, particularly within functional JavaScript. Take some time to look through your code, glare at the <code class="language-plaintext highlighter-rouge">if/else</code>, <code class="language-plaintext highlighter-rouge">try/catch</code>, and <code class="language-plaintext highlighter-rouge">switch</code> blocks, and see whether they&#x2019;re really just <code class="language-plaintext highlighter-rouge">alt</code>s in disguise!</p>

<p>Next time, we&#x2019;ll be looking into your <strong>new favourite</strong> typeclasses: <code class="language-plaintext highlighter-rouge">Foldable</code> and <code class="language-plaintext highlighter-rouge">Traversable</code>. Try to contain your excitement until then!</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 8: Apply</h1>
  <span class="post-date">10 Apr 2017</span>
  <p>Aaand we&#x2019;re back - hello, everyone! Today, we&#x2019;re going to take another look at those mystical <a href="/2017/03/27/fantas-eel-and-specification-6/"><code class="language-plaintext highlighter-rouge">Functor</code> types</a>. We said a couple weeks ago that functors encapsulate a little world (<strong>context</strong>) with some sort of <em>language extension</em>. Well, what happens <strong>when worlds collide</strong>? Let&#x2019;s talk about <code class="language-plaintext highlighter-rouge">Apply</code>.</p>

<p>All <code class="language-plaintext highlighter-rouge">Apply</code> types are <code class="language-plaintext highlighter-rouge">Functor</code> types by requirement, so we know they&#x2019;re definitely &#x201C;containers&#x201D; for other types. The exciting new feature here is this <code class="language-plaintext highlighter-rouge">ap</code> function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ap</span> <span class="o">::</span> <span class="kt">Apply</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="c1">--                 a -&gt;   (a -&gt; b) -&gt;   b</span>
</code></pre></div></div>

<p>If we ignore the <code class="language-plaintext highlighter-rouge">f</code>s, we get the second line, which is our basic <strong>function application</strong>: we <em>apply</em> a value of type <code class="language-plaintext highlighter-rouge">a</code> to a function of type <code class="language-plaintext highlighter-rouge">a -&gt; b</code>, and we get a  value of type <code class="language-plaintext highlighter-rouge">b</code>. <em>Woo!</em> What&#x2019;s the difference with <code class="language-plaintext highlighter-rouge">ap</code>? All those bits are wrapped in the <strong>context</strong> of our <code class="language-plaintext highlighter-rouge">f</code> functor!</p>

<p>That&#x2019;s the, uh, &#x201C;grand reveal&#x201D;. <em>Ta-da</em>. I&#x2019;m not really sure that, in <em>isolation</em>, this particularly helps our <strong>intuition</strong>, though, so let&#x2019;s <em>instead</em> look at <code class="language-plaintext highlighter-rouge">ap</code> within the <code class="language-plaintext highlighter-rouge">lift2</code> function:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Remember: `f` MUST be curried!</span>
<span class="c1">// lift2 :: Applicative f</span>
<span class="c1">//       =&gt;  (a -&gt;   b -&gt;   c)</span>
<span class="c1">//       -&gt; f a -&gt; f b -&gt; f c</span>
<span class="kd">const</span> <span class="nx">lift2</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">=&gt;</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
</code></pre></div></div>

<p>For <em>me</em>, this is <strong>much</strong> clearer. <code class="language-plaintext highlighter-rouge">lift2</code> lets us <strong>combine</strong> two <strong>separate</strong> wrapped values into one with a given function.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">lift1</code>, if you think about it, is just <code class="language-plaintext highlighter-rouge">a.map(f)</code>. The <code class="language-plaintext highlighter-rouge">lift2</code> pattern actually works for any number of arguments; once you finish the article, why not try to write <code class="language-plaintext highlighter-rouge">lift3</code>? Or <code class="language-plaintext highlighter-rouge">lift4</code>?</p>
</blockquote>

<p><em>Wait, <strong>combine</strong>? Do I sense a</em> <a href="/2017/03/13/fantas-eel-and-specification-4/"><code class="language-plaintext highlighter-rouge">Semigroup</code></a>?</p>

<p>Sort of! You can think of it this way: a <code class="language-plaintext highlighter-rouge">Semigroup</code> type allows us to merge <strong>values</strong>. An <code class="language-plaintext highlighter-rouge">Apply</code> type allows us to merge <strong>contexts</strong>. <em>Neat</em>, huh? Now, how could we forget the <strong>laws</strong>?!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span>
<span class="kd">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">g</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">// COMPOSITION LAW</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">compose</span><span class="p">)))</span> <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

<span class="c1">// But, if we write lift3...</span>
<span class="kd">const</span> <span class="nx">lift3</span> <span class="o">=</span>
  <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">=&gt;</span> <span class="nx">c</span> <span class="o">=&gt;</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)))</span>

<span class="c1">// Now our law looks like this!</span>
<span class="nx">lift3</span><span class="p">(</span><span class="nx">compose</span><span class="p">)(</span><span class="nx">f</span><span class="p">)(</span><span class="nx">g</span><span class="p">)(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

<span class="c1">// Remember: x.map(compose(f)(g))</span>
<span class="c1">//       === x.map(g).map(f)</span>
</code></pre></div></div>

<p>By introducing some little helper functions, our law seems much clearer, and a little more familiar. It says that, just as <code class="language-plaintext highlighter-rouge">map</code> could <strong>only</strong> apply a function to the wrapped value, <code class="language-plaintext highlighter-rouge">ap</code> can <strong>only</strong> apply a wrapped function to the wrapped value. <strong>No magic tricks!</strong></p>

<p>Before we go any further, I challenge you take a moment to <em>try</em> to build <code class="language-plaintext highlighter-rouge">lift2</code> without <code class="language-plaintext highlighter-rouge">ap</code>. Just think about <em>why</em> we couldn&#x2019;t do this with a plain old <code class="language-plaintext highlighter-rouge">Functor</code>. If we tried to write <code class="language-plaintext highlighter-rouge">lift2</code>, we might end up here:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lift2F :: Functor f</span>
<span class="c1">//        =&gt; (  a -&gt;   b -&gt;      c)</span>
<span class="c1">//        -&gt;  f a -&gt; f b -&gt; f (f c)</span>
<span class="kd">const</span> <span class="nx">lift2F</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="k">as</span> <span class="o">=&gt;</span> <span class="nx">bs</span> <span class="o">=&gt;</span>
  <span class="k">as</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">bs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">b</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)(</span><span class="nx">b</span><span class="p">)))</span>
</code></pre></div></div>

<p>So, we can apply the inner values to our function - <em>hooray!</em> - but look at the <strong>type</strong> here. We&#x2019;re doing a <code class="language-plaintext highlighter-rouge">map</code> inside a <code class="language-plaintext highlighter-rouge">map</code>, so we&#x2019;ve ended up with <strong>two levels</strong> of our functor type! It&#x2019;s clear that we can&#x2019;t write a <strong>generic</strong> <code class="language-plaintext highlighter-rouge">lift2</code> to work with <em>any</em> <code class="language-plaintext highlighter-rouge">Functor</code>, and <code class="language-plaintext highlighter-rouge">ap</code> is what&#x2019;s missing.</p>

<hr>

<p>With all that out the way, let&#x2019;s look at some examples, shall we? We&#x2019;ll start with the <a href="https://github.com/fantasyland/fantasy-land/blob/master/internal/id.js#L42-L44"><code class="language-plaintext highlighter-rouge">Identity</code> type&#x2019;s <code class="language-plaintext highlighter-rouge">ap</code></a> from our beloved spec:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Identity</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Identity</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">x</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// map :: Identity a ~&gt; (a -&gt; b)</span>
<span class="c1">//                   -&gt; Identity b</span>
<span class="nx">Identity</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ap :: Identity a ~&gt; Identity (a -&gt; b)</span>
<span class="c1">//                  -&gt; Identity b</span>
<span class="nx">Identity</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Identity(5)</span>
<span class="nx">lift2</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)</span>
     <span class="p">(</span><span class="nx">Identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
     <span class="p">(</span><span class="nx">Identity</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<p>No frills, no magic. <code class="language-plaintext highlighter-rouge">Identity.ap</code> takes the function from <code class="language-plaintext highlighter-rouge">b</code>, the value from <code class="language-plaintext highlighter-rouge">this</code>, and returns the <strong>wrapped-up</strong> result. <em>Did you spot the similarity in <strong>type</strong> between <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">ap</code>, by the way</em>? Moving on, here&#x2019;s the slightly more complex implementation for <code class="language-plaintext highlighter-rouge">Array</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Our implementation of ap.</span>
<span class="c1">// ap :: Array a ~&gt; Array (a -&gt; b) -&gt; Array b</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(...</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
    <span class="nx">f</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">))</span>
<span class="p">}</span>

<span class="c1">// 3 x 0 elements</span>
<span class="c1">// []</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">ap</span><span class="p">([])</span>

<span class="c1">// 3 x 1 elements</span>
<span class="c1">// [ &apos;2!&apos;, &apos;3!&apos;, &apos;4!&apos; ]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">.</span><span class="nx">ap</span><span class="p">([</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// 3 x 2 elements</span>
<span class="c1">// [ &apos;2!&apos;, &apos;3!&apos;, &apos;4!&apos;</span>
<span class="c1">// , &apos;2?&apos;, &apos;3?&apos;, &apos;4?&apos; ]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">.</span><span class="nx">ap</span><span class="p">([</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span>
    <span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">?</span><span class="dl">&apos;</span> <span class="p">])</span>
</code></pre></div></div>

<p>I&#x2019;ve put a little note with the answers so we can see what&#x2019;s happening: we get <strong>every</strong> <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> pair. This is called the <strong>cartesian product</strong> of the two arrays. On top of that, when we <code class="language-plaintext highlighter-rouge">lift2</code> an <code class="language-plaintext highlighter-rouge">f</code> over two <code class="language-plaintext highlighter-rouge">Array</code> types, we&#x2019;re actually doing something <em>quite familiar</em>&#x2026;</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nx">lift2</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)(</span><span class="nx">array1</span><span class="p">)(</span><span class="nx">array2</span><span class="p">)</span>

<span class="c1">// ... is the same as...</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">x</span> <span class="k">in</span> <span class="nx">array1</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">y</span> <span class="k">in</span> <span class="nx">array2</span><span class="p">)</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)</span>

<span class="k">return</span> <span class="nx">result</span>
</code></pre></div></div>

<p>We get a really pretty shorthand for <strong>multi-dimensional loops</strong>. Flattening a <strong>loop within a loop</strong> gives us every possible pair of elements, and that&#x2019;s what <code class="language-plaintext highlighter-rouge">ap</code> is for! If this feels weird, just <strong>think of the types</strong>. We have to use <code class="language-plaintext highlighter-rouge">Array (a -&gt; b)</code> and <code class="language-plaintext highlighter-rouge">Array a</code> to get to <code class="language-plaintext highlighter-rouge">Array b</code> without violating the <strong>composition</strong> law; there aren&#x2019;t many possibilities!</p>

<hr>

<p>There are loads of types with <code class="language-plaintext highlighter-rouge">ap</code> instances. Most, we&#x2019;ll see, implement <code class="language-plaintext highlighter-rouge">ap</code> in terms of <code class="language-plaintext highlighter-rouge">chain</code>; we&#x2019;ll look at the <code class="language-plaintext highlighter-rouge">Chain</code> spec in a week or two, so don&#x2019;t worry too much. Most of them are fairly intuitive anyway:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Maybe</code> combines <strong>possible failures</strong>. If either of the two <code class="language-plaintext highlighter-rouge">Maybe</code> values are <code class="language-plaintext highlighter-rouge">Nothing</code>, the result is <code class="language-plaintext highlighter-rouge">Nothing</code>.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Just</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Just</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// Just(-2)</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Just</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// Nothing</span>
<span class="nx">Just</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>       <span class="c1">// Nothing</span>
<span class="nx">Nothing</span><span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Nothing</span><span class="p">)</span>       <span class="c1">// Nothing</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Either</code> combines <strong>possible failures with exceptions</strong>. If either of the two are <code class="language-plaintext highlighter-rouge">Left</code>, the result is the first <code class="language-plaintext highlighter-rouge">Left</code>.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Right</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Right</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// Right(-2)</span>
<span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">halp</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Right</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// Left(&apos;halp&apos;)</span>
<span class="nx">Right</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="p">.</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">eek</span><span class="dl">&apos;</span><span class="p">))</span>    <span class="c1">// Left(&apos;eek&apos;)</span>
<span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">halp</span><span class="dl">&apos;</span><span class="p">).</span><span class="nx">ap</span><span class="p">(</span><span class="nx">Left</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">eek</span><span class="dl">&apos;</span><span class="p">))</span>    <span class="c1">// Left(&apos;eek&apos;)</span>
</code></pre></div></div>

<p>At some point, I&#x2019;d like to write a follow up to <a href="/2016/12/31/yippee-ki-yay-other-functors/">the <code class="language-plaintext highlighter-rouge">Functor</code> post</a> to give some more <em>practical</em> examples, but, for now, this is hopefully understandable (<em>please <a href="http://twitter.com/am_i_tom">tweet me</a> if I&#x2019;m wrong!</em>). Whatever your <code class="language-plaintext highlighter-rouge">Functor</code> trickery, <strong><code class="language-plaintext highlighter-rouge">ap</code> is <code class="language-plaintext highlighter-rouge">map</code> with a wrapped function</strong>. Before we go, though, I&#x2019;d like to talk about <em>one last trick</em> up <code class="language-plaintext highlighter-rouge">Apply</code>&#x2019;s sleeve&#x2026;</p>

<p>A type we <em>haven&#x2019;t</em> talked about before is <code class="language-plaintext highlighter-rouge">Task</code>. This is similar to <code class="language-plaintext highlighter-rouge">Either</code> - it represents either an error <strong>or</strong> a value - but the difference is that <code class="language-plaintext highlighter-rouge">Task</code>&#x2019;s value is the result of a possibly-<strong>asynchronous</strong> computation. They look a <em>lot</em> like <code class="language-plaintext highlighter-rouge">Promise</code> types:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Task</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">data.task</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="c1">// Convert a fetch promise to a Task.</span>
<span class="kd">const</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="nx">url</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Task</span><span class="p">((</span><span class="nx">rej</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">rej</span><span class="p">))</span>
</code></pre></div></div>

<p>We can see that it holds a <strong>function</strong> that will eventually call a resolver. <code class="language-plaintext highlighter-rouge">Task</code>, just like <code class="language-plaintext highlighter-rouge">Promise</code>, sorts out all the async wiring for us. However, an interesting feature of <code class="language-plaintext highlighter-rouge">Task</code> is that it implements <code class="language-plaintext highlighter-rouge">Apply</code>. Let&#x2019;s take a look:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">renderPage</span> <span class="o">=</span> <span class="nx">users</span> <span class="o">=&gt;</span> <span class="nx">posts</span> <span class="o">=&gt;</span>
  <span class="cm">/* Write some HTML with this data... */</span>

<span class="c1">// A Promise of a web page.</span>
<span class="c1">// page :: Task e HTML</span>
<span class="kd">const</span> <span class="nx">page</span> <span class="o">=</span>
  <span class="nx">lift2</span><span class="p">(</span><span class="nx">renderPage</span><span class="p">)</span>
       <span class="p">(</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">/users</span><span class="dl">&apos;</span><span class="p">))</span>
       <span class="p">(</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">/posts</span><span class="dl">&apos;</span><span class="p">))</span>
</code></pre></div></div>

<p>Just as we&#x2019;d expect: we get the two results, and <strong>combine</strong> them into one using <code class="language-plaintext highlighter-rouge">renderPage</code> as the &#x201C;glue&#x201D;. <em>However</em>, we can see that <code class="language-plaintext highlighter-rouge">lift2</code>&#x2019;s second and third arguments have <strong>no dependencies</strong> on one another. Because of this, the arguments to <code class="language-plaintext highlighter-rouge">lift2</code> can always be calculated <strong>in parallel</strong>. Do you hear <em>that</em>? These AJAX requests are <strong>automatically parallelised</strong>! Ooer!</p>

<p>You can see <a href="https://github.com/folktale/data.task/blob/master/lib/task.js#L131-L183"><code class="language-plaintext highlighter-rouge">Task.ap</code>&#x2019;s implementation</a> for an exact explanation, but isn&#x2019;t this <em>great</em>? We can <strong>abstract</strong> parallelism and never have to worry about it! When we have two parallel <code class="language-plaintext highlighter-rouge">Task</code>s and finally want to glue them back together, we just use <code class="language-plaintext highlighter-rouge">lift2</code>! Parallelism becomes an <strong>implementation detail</strong>. <em>Out of sight, out of mind</em>!</p>

<hr>

<p>I think <code class="language-plaintext highlighter-rouge">Task</code> gives a really <strong>strong</strong> case for <code class="language-plaintext highlighter-rouge">Apply</code> and why it&#x2019;s immediately useful. When we look at <code class="language-plaintext highlighter-rouge">Traversable</code> in a few weeks, we&#x2019;ll come back to <code class="language-plaintext highlighter-rouge">ap</code> and see just how <em>powerful</em> it is. Until then, don&#x2019;t overthink <code class="language-plaintext highlighter-rouge">ap</code> - it&#x2019;s just a mechanism for <strong>combining contexts</strong> (worlds!) together without unwrapping them.</p>

<p>I had originally intended to mention <code class="language-plaintext highlighter-rouge">of</code> in this post and cover the full <code class="language-plaintext highlighter-rouge">Applicative</code>. However, it&#x2019;s already quite a long post, so I&#x2019;ll write up that post some time this week! I might even throw in some bigger <em>practical</em> examples for good measure.</p>

<p>If you&#x2019;re still with me, <strong>hooray</strong>! I hope that wasn&#x2019;t <em>too</em> full-on. We&#x2019;re definitely wading in <strong>deeper waters</strong> now, getting to the more advanced parts of the spec. All the more reason to keep <a href="http://twitter.com/am_i_tom">asking questions</a>, though! I want to make this as clear as possible, so don&#x2019;t hesitate to get in touch.</p>

<p>For now until we talk about <code class="language-plaintext highlighter-rouge">Applicative</code>, though, it&#x2019;s goodbye from me! Keep at it, <code class="language-plaintext highlighter-rouge">Apply</code> yourself (<em>zing - this blog has jokes now!</em>), and take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 6: Functor</h1>
  <span class="post-date">27 Mar 2017</span>
  <p>Fantasy Landers, <strong>assemble</strong>! We&#x2019;ve been <code class="language-plaintext highlighter-rouge">concat</code>enating for two weeks now; are you ready for something a bit different? Well, <strong>good news</strong>! If you&#x2019;re humming, &#x201C;<em>Oh won&#x2019;t you take me&#x2026; to functor town?</em>&#x201D;, then this is the article for you. Today, friends, we&#x2019;re going to talk about <strong>functors</strong>.</p>

<blockquote class="twitter-tweet" data-lang="en-gb"><p lang="en" dir="ltr">Another <a href="https://twitter.com/hashtag/functional?src=hash">#functional</a> blog post on <a href="https://twitter.com/hashtag/functors?src=hash">#functors</a> in <a href="https://twitter.com/hashtag/javascript?src=hash">#javascript</a>, including Maybe, Either, and... Function :O <a href="https://t.co/3H5T0yb35w">https://t.co/3H5T0yb35w</a></p>&#x2014; Tom Harding (@am_i_tom) <a href="https://twitter.com/am_i_tom/status/815221887655546880">31 December 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Yes, so, at the very end of last year, I wrote an article about functors that went over several examples of <code class="language-plaintext highlighter-rouge">Functor</code> types. It&#x2019;s a collection of examples of how these can be useful <em>in practice</em>, but it&#x2019;s a bit light on <strong>intuition</strong>. Let&#x2019;s right that wrong today!</p>

<p>I&#x2019;d recommend giving the above a quick read, as this post won&#x2019;t spend much time going over what was said back then. <abbr title="Too long; didn&apos;t read">tl;dr</abbr>, <code class="language-plaintext highlighter-rouge">Functor</code> is just another <strong>typeclass</strong> (a structure just like <code class="language-plaintext highlighter-rouge">Semigroup</code> or <code class="language-plaintext highlighter-rouge">Monoid</code>) with one special method:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Any functor must have a `map` method:</span>
<span class="n">map</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>&#x2026; and (<em>surprise!</em>) a couple of <strong>laws</strong>. For <em>any</em> functor value <code class="language-plaintext highlighter-rouge">u</code>, the following must be true:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Identity</span>
<span class="nx">u</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">u</span>

<span class="c1">// Composition:</span>
<span class="nx">u</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="o">===</span> <span class="nx">u</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
</code></pre></div></div>

<p>They might not be <em>immediately</em> clear, and the definitions in the other article are a bit wordy, but have a couple reads. In <em>my</em> head, I tend to think to myself, <em>a call to <code class="language-plaintext highlighter-rouge">map</code> must return an identical <strong>outer</strong> structure, with the <strong>inner</strong> value(s) transformed.</em></p>

<hr>

<p>If this looks a bit <em>weird</em> to you, then it&#x2019;s probably because <code class="language-plaintext highlighter-rouge">Functor</code> is the <strong>first</strong> entry we&#x2019;ve seen in Fantasy Land that <em>must</em> <strong>contain</strong> some other type.</p>

<p>Think about <code class="language-plaintext highlighter-rouge">String</code>. It has actually ticked all the boxes up until now - it&#x2019;s a <code class="language-plaintext highlighter-rouge">Setoid</code>, <code class="language-plaintext highlighter-rouge">Semigroup</code>, <em>and</em> a <code class="language-plaintext highlighter-rouge">Monoid</code> - but we can&#x2019;t make it a <code class="language-plaintext highlighter-rouge">Functor</code>. This is because <code class="language-plaintext highlighter-rouge">String</code> is just, well, strings!</p>

<p><code class="language-plaintext highlighter-rouge">Array a</code> has also ticked all the boxes so far, but it <em>is</em> a <code class="language-plaintext highlighter-rouge">Functor</code>. This is because it <em>contains</em> a value of type <code class="language-plaintext highlighter-rouge">a</code> (or, usually, several of them). Strings are just strings - you can&#x2019;t have a &#x201C;<code class="language-plaintext highlighter-rouge">String</code> <em>of</em> a thing&#x201D; in the same way as you can have an &#x201C;<code class="language-plaintext highlighter-rouge">Array</code> <em>of</em> a thing&#x201D; or a &#x201C;<code class="language-plaintext highlighter-rouge">Maybe</code> <em>of</em> a thing&#x201D;.</p>

<p><strong><em>Functor types are containers. Not all container types are functors.</em></strong> Want an example? Let&#x2019;s look at <code class="language-plaintext highlighter-rouge">Set a</code> - a collection of <em>unique</em> values of some type <code class="language-plaintext highlighter-rouge">a</code>. There&#x2019;s a catch here, though - <code class="language-plaintext highlighter-rouge">a</code> must be a <code class="language-plaintext highlighter-rouge">Setoid</code>. Looking at the type signature for <code class="language-plaintext highlighter-rouge">map</code>, we see no <code class="language-plaintext highlighter-rouge">Setoid</code> restrictions - we could <code class="language-plaintext highlighter-rouge">map</code> our <code class="language-plaintext highlighter-rouge">Set a</code> values to some not-a-<code class="language-plaintext highlighter-rouge">Setoid</code> type <code class="language-plaintext highlighter-rouge">b</code> (like <code class="language-plaintext highlighter-rouge">Function</code>), and we&#x2019;d have no way of ensuring uniqueness!</p>

<p>A functor <strong>does not care</strong> about the type it&#x2019;s holding. <code class="language-plaintext highlighter-rouge">Set</code>, on the other hand, <em>must</em>. Thus, <code class="language-plaintext highlighter-rouge">Set</code> can&#x2019;t be a <code class="language-plaintext highlighter-rouge">Functor</code>. Don&#x2019;t worry, though - there are plenty of <a href="/2016/12/31/yippee-ki-yay-other-functors/">types that <em>are</em> functors</a>!</p>

<hr>

<p>Ok, everything has hopefully just about made sense up to here. Now&#x2019;s when we get a bit&#x2026; <strong>hand-wavey</strong>. Sorry in advance. We&#x2019;ve been over the <em>laws</em>, and we&#x2019;ve seen some examples. What&#x2019;s the <strong>intuition</strong>, though? If all these wildly different types of things are functors, what behaviour do they all <em>share</em>?</p>

<p>Imagine a world <em>without</em> functors. All we have are basic values: <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Number</code>, that sort of thing. No <code class="language-plaintext highlighter-rouge">Array</code>, though. No <code class="language-plaintext highlighter-rouge">Set</code>, either, as you&#x2019;d <em>internally</em> need an array of values. No nullable values <em>at all</em> (they&#x2019;re not type-safe). No <code class="language-plaintext highlighter-rouge">Function</code>, even! We&#x2019;d have an <strong>extremely limited</strong> set of tools and would probably throw our computers out the window before too long. But, when we start introducing <code class="language-plaintext highlighter-rouge">Functor</code> types:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Type</th>
      <th style="text-align: left">Capability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">a</code></td>
      <td style="text-align: left">Represent a value.</td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">Maybe a</code></td>
      <td style="text-align: left">Represent a <strong>possibly null</strong> value.</td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">Either e a</code></td>
      <td style="text-align: left">Represent a value <strong>or exception</strong>.</td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">Array a</code></td>
      <td style="text-align: left">Represent <strong>a number of values</strong>.</td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">x -&gt; a</code></td>
      <td style="text-align: left">Represent a <strong>mapping to values</strong>.</td>
    </tr>
    <tr>
      <td style="text-align: right">&#x2026;</td>
      <td style="text-align: left">&#x2026;</td>
    </tr>
  </tbody>
</table>

<p>A functor is like a little &#x201C;world&#x201D; in which our boring, functor-less language has been <em>extended</em> in some (hopefully useful!) way. When we put a value into one of these worlds, we say that we&#x2019;re <strong>lifting</strong> the value <em>into</em> the functor.</p>

<p><strong>More than one extension</strong>? What if we want to represent <em>a number of mappings to values</em>? We make an <code class="language-plaintext highlighter-rouge">Array</code> of <code class="language-plaintext highlighter-rouge">Function</code>s! What about a <em>mapping to a possibly null value</em>? We write a <code class="language-plaintext highlighter-rouge">Function</code> that maps to <code class="language-plaintext highlighter-rouge">Maybe</code>s! If we want to combine these capabilities, we simply <strong>nest</strong> them.</p>

<blockquote>
  <p>We&#x2019;ll see that we&#x2019;re not always so lucky with composition-by-nesting when we get on to more complex structures!</p>
</blockquote>

<p>We&#x2019;re there. <strong>That&#x2019;s what a functor does</strong>. It provides some <strong>extended behaviour</strong>, with total, gorgeous <strong>type safety</strong>. Note that our language isn&#x2019;t <em>changed</em> inside a functor type - just <em>extended</em>. This is why the <strong>functor laws</strong> hold. Let&#x2019;s write a couple of little proofs:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For ANY functor *constructor* U:</span>
<span class="c1">// e.g. [x].map(f) === [f(x)]</span>
<span class="nx">U</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="c1">// Read: `map` just applies the function to</span>
<span class="c1">// the inner value. Using only this rule,</span>
<span class="c1">// we win!</span>

<span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>

<span class="c1">// Identity...</span>
<span class="nx">U</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>

  <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">id</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

  <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// id(x) === x</span>

<span class="c1">// Composition...</span>
<span class="nx">U</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

  <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

  <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>

  <span class="o">===</span> <span class="nx">U</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
</code></pre></div></div>

<p>Our laws hold, everything works. If it helps your intuition, just think of <code class="language-plaintext highlighter-rouge">U(x).map(f) === U(f(x))</code> every time you run into a functor. More generally (and correctly), <strong><code class="language-plaintext highlighter-rouge">map</code> applies a function to the value(s) within a functor</strong> and <em>nothing else</em>. That, friends, is all there is to it!</p>

<hr>

<p>So, I&#x2019;m sorry that it got a bit less <em>clearly</em>-defined towards the end. You can see it&#x2019;s quite difficult to define an all-encompassing intuition for functors, but I hope this has given you somewhere to start!</p>

<p>If you want more examples, the Haskell docs contain <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor.html#control.i:Functor">loads of Functor types</a> for you to see! The intuition will come with time. Until then, as always, feel free to <a href="http://twitter.com/am_i_tom">tweet me</a> and I&#x2019;ll do my best to clarify my ramblings.</p>

<p>Next time, we&#x2019;ll look at another type of functor: the <strong>contravariant functor</strong>. Get excited! As always, until then,</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 3.5: Ord</h1>
  <span class="post-date">09 Apr 2017</span>
  <p><em>Honestly, at this rate, the spec is going to grow faster than this blog series&#x2026;</em> We interrupt our usual schedule to introduce <strong>Fantasy Land&#x2019;s newest member</strong>: let&#x2019;s welcome <code class="language-plaintext highlighter-rouge">Ord</code>! <em>Spoiler alert: if you&#x2019;ve been following this series, this is going to be a pretty easy one</em>.</p>

<p><code class="language-plaintext highlighter-rouge">Ord</code> types are types with a <strong>total</strong> ordering. That means that, given <strong>any</strong> two values of a given <code class="language-plaintext highlighter-rouge">Ord</code> type, you can determine whether one be greater than the other. To do this, we actually only need <strong>one method</strong>. Given that all <code class="language-plaintext highlighter-rouge">Ord</code> types must also be <code class="language-plaintext highlighter-rouge">Setoid</code> types, it could actually have been <em>any</em> of the comparison operators (<code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>; <em>think about why <strong>any of these</strong> would have worked</em>), but the spec settled on <code class="language-plaintext highlighter-rouge">&lt;=</code> (less-than-or-equal), which it refers to as <code class="language-plaintext highlighter-rouge">lte</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lte</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Boolean</span>
</code></pre></div></div>

<p>I&#x2019;m sure that, for most of you, this isn&#x2019;t <a href="/2017/03/08/fantas-eel-and-specification-2/">your first type signature</a>, so I&#x2019;ll leave that link for anyone who may not have seen it. It&#x2019;s almost identical to <code class="language-plaintext highlighter-rouge">Setoid</code>&#x2019;s <code class="language-plaintext highlighter-rouge">equals</code>, though; the only difference is that, this time, we return a boolean to indicate whether <code class="language-plaintext highlighter-rouge">this &lt;= that</code>, rather than <code class="language-plaintext highlighter-rouge">this == that</code>. Using only <code class="language-plaintext highlighter-rouge">lte</code> and <code class="language-plaintext highlighter-rouge">equals</code> (because <strong>every <code class="language-plaintext highlighter-rouge">Ord</code> is a <code class="language-plaintext highlighter-rouge">Setoid</code></strong>), we can derive all the things we might want:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Greater than. The OPPOSITE of lte.</span>
<span class="c1">// gt :: Ord a =&gt; a -&gt; a -&gt; Boolean</span>
<span class="kd">const</span> <span class="nx">gt</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="nx">lte</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Greater than or equal.</span>
<span class="c1">// gte :: Ord a =&gt; a -&gt; a -&gt; Boolean</span>
<span class="kd">const</span> <span class="nx">gte</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">gt</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">||</span> <span class="nx">x</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Less than. The OPPOSITE of gte!</span>
<span class="c1">// lt :: Ord a =&gt; a -&gt; a -&gt; Boolean</span>
<span class="kd">const</span> <span class="nx">lt</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="nx">gte</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// And we already have lte!</span>
<span class="c1">// lte :: Ord a =&gt; a -&gt; a -&gt; Boolean</span>
<span class="kd">const</span> <span class="nx">lte</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>That</em> is how, using <code class="language-plaintext highlighter-rouge">equals</code> and one of those four functions, we have enough to derive the other three. This is <em>really neat</em>, and <code class="language-plaintext highlighter-rouge">Ord</code> continues to please:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive Ord definition for List!</span>
<span class="c1">// lte :: Ord a =&gt; [a] ~&gt; [a] -&gt; [a]</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lte</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head_</span><span class="p">,</span> <span class="nx">tail_</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">head</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">head_</span><span class="p">)</span> <span class="p">?</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">tail_</span><span class="p">)</span>
                           <span class="p">:</span> <span class="nx">head</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">head_</span><span class="p">),</span>

      <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kc">false</span>
    <span class="p">}),</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Just for demo - forgive me!</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equals</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="nx">that</span> <span class="p">}</span>

<span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lte</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span> <span class="o">&lt;=</span> <span class="nx">that</span> <span class="p">}</span>

<span class="nx">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">Nil</span><span class="p">)).</span><span class="nx">lte</span><span class="p">(</span><span class="nx">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">Nil</span><span class="p">))</span> <span class="c1">// false</span>
<span class="nx">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">Nil</span><span class="p">).</span><span class="nx">lte</span><span class="p">(</span><span class="nx">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">Nil</span><span class="p">)))</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>Oh yeah, <strong>it composes</strong>; were you expecting anything less? Of course, we can write <code class="language-plaintext highlighter-rouge">Ord</code> instances for container types with inner <code class="language-plaintext highlighter-rouge">Ord</code> types, just as we did for <code class="language-plaintext highlighter-rouge">Setoid</code>, <code class="language-plaintext highlighter-rouge">Monoid</code>, and so on. We just <strong>nest</strong> as we want. Do we want to compare <code class="language-plaintext highlighter-rouge">Tuple</code>s of <code class="language-plaintext highlighter-rouge">List</code>s of <code class="language-plaintext highlighter-rouge">Maybe</code>s of some custom type of ours? No problem! <code class="language-plaintext highlighter-rouge">Ord</code> takes care of everything, just as <code class="language-plaintext highlighter-rouge">Setoid</code> did for equivalence.</p>

<p>Anyway, we got a bit carried away! Let&#x2019;s talk about laws.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Given any two values of an Ord type...</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="kc">true</span> <span class="c1">// Totality</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// Antisymmetry</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">a</span><span class="p">.</span><span class="nx">lte</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// Transitivity</span>
</code></pre></div></div>

<p><strong>Totality</strong> might seem obvious (<code class="language-plaintext highlighter-rouge">a &lt;= b</code> or <code class="language-plaintext highlighter-rouge">b &lt;= a</code>, surely?) when we&#x2019;re talking about integers, for example, but this isn&#x2019;t <em>always</em> so easy. There are examples of types that only have <strong>partial order</strong>, which means that there are certain pairs of values that are incomparable. Because of this, they unfortunately don&#x2019;t make it into the <code class="language-plaintext highlighter-rouge">Ord</code> club!</p>

<blockquote>
  <p>A good example is the <a href="https://en.wikipedia.org/wiki/Semilattice">semilattice</a>, if you&#x2019;re interested, but we won&#x2019;t spend any time discussing this further. <em>Feel free to <a href="http://twitter.com/am_i_tom">tweet me</a> if you want to talk through it, though!</em></p>
</blockquote>

<p><strong>Antisymmetry</strong>, at least to me, seems like a big word for something reasonably obvious. If you compare any <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> values within the type, then find <code class="language-plaintext highlighter-rouge">a.lte(b)</code> <strong>and</strong> <code class="language-plaintext highlighter-rouge">b.lte(a)</code>, well, they can&#x2019;t both be less than the other, right? The only <em>possible</em> explanation is that <code class="language-plaintext highlighter-rouge">a == b</code>!</p>

<p>Finally, <strong>transitivity</strong>, in <em>practice</em>, says that all the values in your type could <em>in theory</em> be arranged into a <strong>fixed, ordered list</strong>. No special cases! Typically, though, you&#x2019;d be doing well to find an implementation that satisfies the other two laws but <em>not</em> this one!</p>

<hr>

<p>That&#x2019;s really all there is, in terms of theory. Significantly less frightening than <a href="/2017/04/03/fantas-eel-and-specification-7/"><code class="language-plaintext highlighter-rouge">Contravariant</code> functors</a>, right? It&#x2019;s really just a way to define, for your type, what it means for one thing to be &#x201C;bigger&#x201D; than another.</p>

<p>Want some <strong>exercises</strong>? Why not write some of your favourite <strong>sorting algorithms</strong> (like <a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble</a>, <a href="https://en.wikipedia.org/wiki/Merge_sort">merge</a>, and <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a>) to work on <strong>any <code class="language-plaintext highlighter-rouge">Ord</code>-implementing structure</strong>*? Maybe write a more <strong>efficient</strong> version of our <a href="/2017/03/09/fantas-eel-and-specification-3/"><code class="language-plaintext highlighter-rouge">Setoid</code>-using <code class="language-plaintext highlighter-rouge">Set</code> type</a> by using an <strong>ordered list</strong> to hold the inner elements? There are plenty of opportunities!</p>

<blockquote>
  <p>Of course, if you <em>don&#x2019;t</em> want to relive your technical interview nightmares, remember that <code class="language-plaintext highlighter-rouge">Ord</code> is just as useful for ordering <strong>search results</strong> on a web page. The Fantasy Land structures are just a bunch of <strong>design patterns</strong> that are written with composition (and <em>discipline</em>!) in mind.</p>
</blockquote>

<p>Regardless, I hope you enjoyed this surprise addition to the series. Normal service will resume, and we&#x2019;ll be discovering <code class="language-plaintext highlighter-rouge">Apply</code> and <code class="language-plaintext highlighter-rouge">Applicative</code> tomorrow, right on schedule. It&#x2019;s <em>also</em> a good time to mention that I&#x2019;ve been putting together <a href="https://github.com/i-am-tom/fantas-eel-and-specification">a collection of Fantasy Land structure examples</a> to go along with this series! I have quite a lot of catching up to do, but I&#x2019;ll get there. I&#x2019;m implementing all the examples and exercises that I mention in the articles, as well as other structures that may be interesting. <em>Naturally, I would be <strong>honoured</strong> if you wanted to contribute any examples you&#x2019;ve found helpful, or even just add a couple comments and helpful tips to what&#x2019;s already there!</em></p>

<p>Anyway, that&#x2019;s all from me! See you tomorrow, everyone - enjoy the rest of your weekends, and take care &#x2665;</p>

<p><em>* If you decide to do this, this is a <strong>great</strong> candidate for an <a href="http://npmjs.com">npm</a> package. Seriously, <strong>I will use this</strong> - let me know when you publish!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 7: Contravariant</h1>
  <span class="post-date">03 Apr 2017</span>
  <p>Well, well, well. We&#x2019;re a fair few weeks into this - I hope this is all still making sense! In the last article, we talked about <strong>functors</strong>, and how they&#x2019;re really just containers to provide &#x201C;language extensions&#x201D; (or <strong>contexts</strong>). Well, today, we&#x2019;re going to talk about another <em>kind</em> of functor that looks&#x2026; <em>ooky spooky</em>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Functor</span>
<span class="n">map</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>

<span class="c1">-- Contravariant</span>
<span class="n">contramap</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>It&#x2019;s no typo: the arrow is <strong>the wrong way round</strong>. This <em>blew my mind</em>. It <em>looks</em> like <code class="language-plaintext highlighter-rouge">contramap</code> can somehow magically work out how to <em>undo</em> a function. Imagine the possibilities:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// f :: String -&gt; Int</span>
<span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span>

<span class="c1">// [&apos;Hello&apos;, &apos;world&apos;]</span>
<span class="p">;[</span><span class="dl">&apos;</span><span class="s1">Hello</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">world</span><span class="dl">&apos;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Impossible</strong>, I hear you say? Well&#x2026;</p>

<p>&#x2026; <em>Yes</em>, you&#x2019;re right this time. <code class="language-plaintext highlighter-rouge">Array</code> isn&#x2019;t a <code class="language-plaintext highlighter-rouge">Contravariant</code> functor - just a normal <code class="language-plaintext highlighter-rouge">Functor</code> (which we can more specifically call a <strong>covariant</strong> functor). In fact, there&#x2019;s <strong>no magic</strong> here at all if we look at the examples of functors that <em>are</em> potential <code class="language-plaintext highlighter-rouge">Contravariant</code> instances. Try this one for size:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// type Predicate a = a -&gt; Bool</span>
<span class="c1">// The `a` is the *INPUT* to the function!</span>
<span class="kd">const</span> <span class="nx">Predicate</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Predicate</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// Make a Predicate that runs `f` to get</span>
<span class="c1">// from `b` to `a`, then uses the original</span>
<span class="c1">// Predicate function!</span>
<span class="c1">// contramap :: Predicate a ~&gt; (b -&gt; a)</span>
<span class="c1">//                          -&gt; Predicate b</span>
<span class="nx">Predicate</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">contramap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Predicate</span><span class="p">(</span>
      <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// isEven :: Predicate Int</span>
<span class="kd">const</span> <span class="nx">isEven</span> <span class="o">=</span> <span class="nx">Predicate</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">// Take a string, run .length, then isEven.</span>
<span class="c1">// lengthIsEven :: Predicate String</span>
<span class="kd">const</span> <span class="nx">lengthIsEven</span> <span class="o">=</span>
  <span class="nx">isEven</span><span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Predicate a</code> is saying that, <em>if I can get from my type</em> <code class="language-plaintext highlighter-rouge">a</code> <em>to</em> <code class="language-plaintext highlighter-rouge">Bool</code><em>, and you can get from your type</em> <code class="language-plaintext highlighter-rouge">b</code> <em>to</em> <code class="language-plaintext highlighter-rouge">a</code><em>, I can get from</em> <code class="language-plaintext highlighter-rouge">b</code> <em>to</em> <code class="language-plaintext highlighter-rouge">Bool</code> <em><strong>via</strong></em> <code class="language-plaintext highlighter-rouge">a</code><em>, and hence give you a</em> <code class="language-plaintext highlighter-rouge">Predicate b</code>! Sorry if that bit takes a couple of read-throughs; in short, <code class="language-plaintext highlighter-rouge">lengthIsEven</code> converts a <code class="language-plaintext highlighter-rouge">String</code> to an <code class="language-plaintext highlighter-rouge">Int</code>, then to a <code class="language-plaintext highlighter-rouge">Bool</code>. We don&#x2019;t <em>care</em> that there&#x2019;s an <code class="language-plaintext highlighter-rouge">Int</code> somewhere in the pipeline - we just care about what the input value has to be.</p>

<p>All smoke and mirrors, right? There&#x2019;s no magical <code class="language-plaintext highlighter-rouge">undo</code> here; it&#x2019;s just that we&#x2019;re adding our actions to the <em>beginning</em> of a mapping. Trust me: you&#x2019;re not as <strong>heartbroken</strong> as I was.</p>

<p>Still, if we can see <em>past</em> this <em>betrayal</em>, we&#x2019;ll of course see that there are some cool things going on here. First of all, our <strong>laws</strong> are basically just the same as <code class="language-plaintext highlighter-rouge">Functor</code>, but a little bit upside down:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Identity</span>
<span class="nx">U</span><span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">U</span>

<span class="c1">// Composition</span>
<span class="nx">U</span><span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">f</span><span class="p">).</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
  <span class="o">===</span> <span class="nx">U</span><span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
</code></pre></div></div>

<p>Identity is the same because &#x201C;doing nothing&#x201D; is still &#x201C;doing nothing&#x201D; if you do it backwards. <em>Probably not a sentence that&#x2019;ll win me awards</em>. Composition is pretty much the same, but the functions are composed <strong>the other way round</strong>!</p>

<p>A <em>lot</em> - probably the overwhelming majority - of <code class="language-plaintext highlighter-rouge">Contravariant</code> examples in the wild will be mappings <em>to</em> specific types. Imagine a <code class="language-plaintext highlighter-rouge">ToString</code> type:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// type ToString a :: a -&gt; String</span>
<span class="kd">const</span> <span class="nx">ToString</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">ToString</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// Add a pre-processor to the pipeline.</span>
<span class="nx">ToString</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">contramap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ToString</span><span class="p">(</span>
      <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// Convert an int to a string.</span>
<span class="c1">// intToString :: ToString Int</span>
<span class="kd">const</span> <span class="nx">intToString</span> <span class="o">=</span>
  <span class="nx">ToString</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">int(</span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">)</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">|</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Optional</span>

<span class="c1">// Convert an array of strings to a string.</span>
<span class="c1">// stringArrayToString :: ToString [String]</span>
<span class="kd">const</span> <span class="nx">stringArrayToString</span> <span class="o">=</span>
  <span class="nx">ToString</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">[ </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> ]</span><span class="dl">&apos;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">, </span><span class="dl">&apos;</span><span class="p">))</span>

<span class="c1">// Given a ToString instance for a type,</span>
<span class="c1">// convert an array of a type to a string.</span>
<span class="c1">// arrayToString :: ToString a</span>
<span class="c1">//               -&gt; ToString [a]</span>
<span class="kd">const</span> <span class="nx">arrayToString</span> <span class="o">=</span> <span class="nx">t</span> <span class="o">=&gt;</span>
  <span class="nx">stringArrayToString</span>
  <span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">f</span><span class="p">))</span>

<span class="c1">// Convert an integer array to a string.</span>
<span class="c1">// intsToString :: ToString [Int]</span>
<span class="kd">const</span> <span class="nx">intsToString</span> <span class="o">=</span>
  <span class="nx">arrayToString</span><span class="p">(</span><span class="nx">intToString</span><span class="p">)</span>

<span class="c1">// Aaand they compose! 2D int array:</span>
<span class="c1">// matrixToString :: ToString [[Int]]</span>
<span class="kd">const</span> <span class="nx">matrixToString</span> <span class="o">=</span>
  <span class="nx">arrayToString</span><span class="p">(</span><span class="nx">intsToString</span><span class="p">)</span>

<span class="c1">// &quot;[ [ int(1), int(2), int(3) ] ]&quot;</span>
<span class="nx">matrixToString</span><span class="p">.</span><span class="nx">f</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div></div>

<p>It&#x2019;s pretty clear to see how this approach could be used to develop a <strong>serializer</strong>: you could output <strong>JSON</strong>, <strong>XML</strong>, or even your own <strong>new format</strong>! It&#x2019;s also a <em>great</em> example of the beauty of <strong>composition</strong>: with functions like <code class="language-plaintext highlighter-rouge">arrayToString</code>, we&#x2019;re using smaller <code class="language-plaintext highlighter-rouge">ToString</code> instances to make instances for other, more <em>complex</em> types!</p>

<p>Another good example that&#x2019;s worth a look is the <code class="language-plaintext highlighter-rouge">Equivalence</code> type:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// type Equivalence a = a -&gt; a -&gt; Bool</span>
<span class="c1">// `a` is the type of *BOTH INPUTS*!</span>
<span class="kd">const</span> <span class="nx">Equivalence</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Equivalence</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">f</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">// Add a pre-processor for the variables.</span>
<span class="nx">Equivalence</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">contramap</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Equivalence</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">g</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// Do a case-insensitive equivalence check.</span>
<span class="c1">// searchCheck :: Equivalence String</span>
<span class="kd">const</span> <span class="nx">searchCheck</span> <span class="o">=</span>

  <span class="c1">// Basic equivalence</span>
  <span class="nx">Equivalence</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">)</span>

  <span class="c1">// Remove symbols</span>
  <span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\W</span><span class="sr">+/</span><span class="p">,</span> <span class="dl">&apos;&apos;</span><span class="p">))</span>

  <span class="c1">// Lowercase alpha</span>
  <span class="p">.</span><span class="nx">contramap</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">())</span>

<span class="c1">// And some tests...</span>
<span class="nx">searchCheck</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">HEllO!</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">searchCheck</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">world</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">werld</span><span class="dl">&apos;</span><span class="p">)</span>  <span class="c1">// false</span>
</code></pre></div></div>

<p>So, we&#x2019;re saying we can compare anything that works with <code class="language-plaintext highlighter-rouge">===</code>, and we can therefore compare values of any type as long as they can be <em>converted</em> to something that works with <code class="language-plaintext highlighter-rouge">===</code>. For <code class="language-plaintext highlighter-rouge">searchCheck</code>, this is really neat - we can supply <strong>steps</strong> for making a value comparable,  for transforming <em>single</em> values, and the <code class="language-plaintext highlighter-rouge">Contravariant</code> instance will compare the inputs after being transformed accordingly. <strong>Hooray</strong>!</p>

<blockquote>
  <p>If you fancy an exercise, why not play around with an <code class="language-plaintext highlighter-rouge">Equivalence</code> using our <a href="/2017/03/09/fantas-eel-and-specification-3/">Setoid comparison</a> - perhaps a starter function of <code class="language-plaintext highlighter-rouge">(x, y) =&gt; x.equals(y)</code>? This should give a <strong>lot</strong> more control when comparing complex types.</p>
</blockquote>

<hr>

<p>Well, that&#x2019;s about it! There&#x2019;s not much to <code class="language-plaintext highlighter-rouge">Contravariant</code> types, and they&#x2019;re relatively rare. However, they&#x2019;re a really good way of making your code more <strong>expressive</strong> (or <strong>self-documenting</strong>, or whatever we call it at the moment):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter</span> <span class="o">::</span> <span class="kt">Predicate</span>   <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span>  <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">group</span>  <span class="o">::</span> <span class="kt">Equivalence</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="n">sort</span>   <span class="o">::</span> <span class="kt">Comparison</span>  <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span>  <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">unique</span> <span class="o">::</span> <span class="kt">Equivalence</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span>  <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<p>I&#x2019;ll leave it to you to write the <code class="language-plaintext highlighter-rouge">Comparison</code> type and its <code class="language-plaintext highlighter-rouge">contramap</code> - it&#x2019;ll look quite a lot like <code class="language-plaintext highlighter-rouge">Equivalence</code> - but you see that these type signatures make it <em>really</em> clear what the functions are probably going to do.</p>

<p>If all else fails, just remember:</p>

<ul>
  <li>
    <p>When <code class="language-plaintext highlighter-rouge">f</code> is a (<strong>covariant</strong>) <code class="language-plaintext highlighter-rouge">Functor</code>, <code class="language-plaintext highlighter-rouge">f a</code> says, &#x201C;<em>If you can give me an</em> <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code><em>, I can give you a</em> <code class="language-plaintext highlighter-rouge">Functor b</code>&#x201D;.</p>
  </li>
  <li>
    <p>When <code class="language-plaintext highlighter-rouge">f</code> is a <code class="language-plaintext highlighter-rouge">Contravariant</code> functor, <code class="language-plaintext highlighter-rouge">f a</code> says, &#x201C;<em>If you can give me a</em> <code class="language-plaintext highlighter-rouge">(b -&gt; a)</code><em>, I can give you a</em> <code class="language-plaintext highlighter-rouge">Contravariant b</code>&#x201D;.</p>
  </li>
</ul>

<p>It&#x2019;s the same - it&#x2019;s just backwards. There&#x2019;s sadly no way we could write <code class="language-plaintext highlighter-rouge">contramap</code> for an array, but do think about why we also couldn&#x2019;t write a <code class="language-plaintext highlighter-rouge">map</code> for <code class="language-plaintext highlighter-rouge">Predicate</code> - some things just aren&#x2019;t meant to be! <em>Sigh</em>.</p>

<p><strong>One last thing</strong> before you go: many of these types are <a href="/2017/03/21/fantas-eel-and-specification-5/">monoids</a>. See? <em>Everything&#x2019;s connected</em>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// It&apos;s like a function to our `All` monoid!</span>
<span class="nx">Predicate</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="nx">Predicate</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">)</span>

<span class="nx">Predicate</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Predicate</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
                       <span class="o">&amp;&amp;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>

<span class="c1">// The possibilities, they are endless</span>
<span class="nx">Equivalence</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="nx">Equivalence</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">)</span>

<span class="nx">Equivalence</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Equivalence</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
             <span class="o">&amp;&amp;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>How about that? We can combine various <code class="language-plaintext highlighter-rouge">Predicate</code> and <code class="language-plaintext highlighter-rouge">Equivalence</code> instances of the same type to make new instances!</p>

<blockquote>
  <p>Imagine a <strong>search</strong> tool with options for search criteria and strictness, with each one represented as an <code class="language-plaintext highlighter-rouge">Equivalence</code> structure. When the user makes a selection, we just combine the selected structures, and we have our <strong>purpose-built</strong> search utility!</p>
</blockquote>

<p>Something to explore! Next time, we&#x2019;ll talk about <code class="language-plaintext highlighter-rouge">Apply</code> (and probably <code class="language-plaintext highlighter-rouge">Applicative</code>) - my <strong>second favourite</strong> typeclass (after <code class="language-plaintext highlighter-rouge">Comonad</code> - we&#x2019;ll get to <em>that</em> one in a few more weeks!) I hope you&#x2019;re all well, and hopefully learning a thing or two along the way. See you in a week!</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 5: Monoid</h1>
  <span class="post-date">21 Mar 2017</span>
  <p>Good Tuesday, Fantasists! This week, we&#x2019;re going to take a quick(!) look at <a href="/2017/03/13/fantas-eel-and-specification-4/">the semigroup</a>&#x2019;s older sibling: the <strong>monoid</strong>. We saw last week that a <code class="language-plaintext highlighter-rouge">Semigroup</code> type is one that has some concept of <em>combining</em> values (via <code class="language-plaintext highlighter-rouge">concat</code>). <em>Well</em>, a <code class="language-plaintext highlighter-rouge">Monoid</code> type is any <code class="language-plaintext highlighter-rouge">Semigroup</code> type that happens to have a special value - we&#x2019;ll call it an <strong>identity</strong> value - stored on the type as a function called <code class="language-plaintext highlighter-rouge">empty</code>.</p>

<p>Here&#x2019;s its (in my opinion, not-too-helpful) signature:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">empty</span> <span class="o">::</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span>
</code></pre></div></div>

<p><em>Far</em> more useful, I think, are the laws for how <code class="language-plaintext highlighter-rouge">empty</code> must act for a type to be a valid <code class="language-plaintext highlighter-rouge">Monoid</code>. We call these the identity laws:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right identity</span>
<span class="nx">MyType</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">MyType</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span> <span class="o">===</span> <span class="nx">MyType</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

<span class="c1">// Guess what this one&apos;s called?</span>
<span class="nx">MyType</span><span class="p">.</span><span class="nx">empty</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">MyType</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="o">===</span> <span class="nx">MyType</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Whichever side of <code class="language-plaintext highlighter-rouge">concat</code> we put our <code class="language-plaintext highlighter-rouge">empty</code>, it <em>must</em> make <strong>no difference</strong> to the value. Let&#x2019;s look at some examples of <code class="language-plaintext highlighter-rouge">empty</code> values for our favourite semigroups. Try them on the laws above if you&#x2019;re unsure of <em>why</em> they&#x2019;re valid <code class="language-plaintext highlighter-rouge">empty</code> values:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &apos;&apos;.concat(&apos;hello&apos;)</span>
<span class="c1">//   === &apos;hello&apos;.concat(&apos;&apos;)</span>
<span class="c1">//   === &apos;hello&apos;</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">empty</span>  <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">&apos;&apos;</span>

<span class="c1">// [].concat([1, 2, 3])</span>
<span class="c1">//   === [1, 2, 3].concat([])</span>
<span class="c1">//   === [1, 2, 3]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">empty</span>   <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>

<span class="c1">// And so on...</span>
<span class="nx">Sum</span><span class="p">.</span><span class="nx">empty</span>     <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">Product</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Product</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">Max</span><span class="p">.</span><span class="nx">empty</span>     <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Max</span><span class="p">(</span><span class="o">-</span><span class="kc">Infinity</span><span class="p">)</span>
<span class="nx">Min</span><span class="p">.</span><span class="nx">empty</span>     <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Min</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span>
<span class="nx">All</span><span class="p">.</span><span class="nx">empty</span>     <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">All</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="nx">Any</span><span class="p">.</span><span class="nx">empty</span>     <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Any</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="c1">// BUT not every semigroup is a monoid...</span>
<span class="nx">First</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="c1">// ???</span>
<span class="nx">Last</span><span class="p">.</span><span class="nx">empty</span>  <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="c1">// ???</span>
</code></pre></div></div>

<p>Eek, got a bit stuck at the end&#x2026; <code class="language-plaintext highlighter-rouge">First</code> and <code class="language-plaintext highlighter-rouge">Last</code> are <em>not</em> monoids; see if you can work out why!</p>

<blockquote>
  <p>Ok, so, <code class="language-plaintext highlighter-rouge">First</code> and <code class="language-plaintext highlighter-rouge">Last</code> actually <em>are</em> monoids in Haskell. This <strong>cheat</strong> is done by sneaking in <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Monoid.html#line-189">an inner <code class="language-plaintext highlighter-rouge">Maybe</code> type</a>, where <code class="language-plaintext highlighter-rouge">Nothing</code> becomes the <code class="language-plaintext highlighter-rouge">empty</code> value. This actually works for <strong>any semigroup</strong> that you want to turn into a monoid, but <em><a href="https://youtu.be/VXl0EEd8IcU?t=11m17s">don&#x2019;t let Connor McBride catch you doing it&#x2026;</a></em></p>
</blockquote>

<p><em>This is all very interesting, but what&#x2019;s the point</em>? I&#x2019;m glad you asked, imaginary reader! With a <code class="language-plaintext highlighter-rouge">Semigroup</code> type, you can combine <strong>one or more</strong> values to make another, right? All a monoid does is let us upgrade that to <strong>zero or more</strong>. This is actually a <strong>Pretty Big Deal&#x2122;</strong>, as we can take <strong>any</strong> array (including an empty array!) of monoids and <code class="language-plaintext highlighter-rouge">reduce</code> them to one value.</p>

<p><em>&#x2026; Wait, what?</em></p>

<p>As a surprisingly good intuition, <strong>monoids encapsulate the logic of <code class="language-plaintext highlighter-rouge">Array.reduce</code></strong>. That&#x2019;s what they do. That&#x2019;s what they&#x2019;re <em>for</em>. That&#x2019;s it right there. If you know <a href="/2017/02/24/reductio-and-abstract-em/">how to reduce lists</a>, then congratulations, you&#x2019;re now a <a href="http://tardis.wikia.com/wiki/Monoid">monoid warrior</a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A friendly neighbourhood monoid fold.</span>
<span class="c1">// fold :: Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m</span>
<span class="kd">const</span> <span class="nx">fold</span> <span class="o">=</span> <span class="nx">M</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">M</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span>
  <span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

<span class="c1">// We can now use our monoids for (almost) all</span>
<span class="c1">// our array reduction needs!</span>
<span class="nx">fold</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]).</span><span class="nx">val</span> <span class="c1">// 15</span>
<span class="nx">fold</span><span class="p">(</span><span class="nx">Product</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">val</span>   <span class="c1">// 6</span>
<span class="nx">fold</span><span class="p">(</span><span class="nx">Max</span><span class="p">)([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">]).</span><span class="nx">val</span>      <span class="c1">// 11</span>
<span class="nx">fold</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)([]).</span><span class="nx">val</span>              <span class="c1">// 0 - ooer!</span>
</code></pre></div></div>

<p>We actually get a <strong>double win</strong> here. Not only do we now have a generic way to <code class="language-plaintext highlighter-rouge">fold</code> <em>any</em> <strong>reducible structure</strong> (arrays, <strong>trees</strong>, etc) in our app with <em>any</em> <code class="language-plaintext highlighter-rouge">Monoid</code> type (<code class="language-plaintext highlighter-rouge">Sum</code>, <code class="language-plaintext highlighter-rouge">Max</code>, etc), we also have an opportunity to do some <em>really</em> cool optimisations:</p>

<p>The thing that we didn&#x2019;t explicitly mention about the semigroup laws is that <em>associativity</em> gives us an opportunity to <strong>parallelise</strong>. If we split a list of semigroups into chunks, <code class="language-plaintext highlighter-rouge">concat</code> the elements of each chunk in parallel, and then <code class="language-plaintext highlighter-rouge">concat</code> the results, we&#x2019;re guaranteed to get the same result!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In practice, you&apos;d want a generator here...</span>
<span class="c1">// Non-tail-recursion is expensive in JS!</span>
<span class="kd">const</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">5000</span>
  <span class="p">?</span> <span class="p">[</span><span class="nx">xs</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>
           <span class="p">,</span> <span class="p">...</span> <span class="nx">chunk</span><span class="p">(</span><span class="nx">xs</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">5000</span><span class="p">))</span> <span class="p">]</span>

<span class="c1">// ... You get the idea.</span>
<span class="kd">const</span> <span class="nx">parallelMap</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="nx">RunThisThingOnANewThread</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>

<span class="c1">// Chunk, fold in parallel, fold the result.</span>
<span class="c1">// In practice, this would probably be async.</span>
<span class="kd">const</span> <span class="nx">foldP</span> <span class="o">=</span> <span class="nx">M</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span>
  <span class="nx">parallelMap</span><span class="p">(</span><span class="nx">fold</span><span class="p">(</span><span class="nx">M</span><span class="p">))(</span><span class="nx">chunk</span><span class="p">(</span><span class="nx">xs</span><span class="p">))</span>
  <span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">xs</span><span class="p">,</span> <span class="nx">ys</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">ys</span><span class="p">),</span>
    <span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

<span class="c1">// With all that in place...</span>

<span class="c1">// Numbers from 0 to 999,999...</span>
<span class="kd">const</span> <span class="nx">bigList</span> <span class="o">=</span> <span class="p">[...</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="nx">e6</span><span class="p">)].</span><span class="nx">map</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">i</span><span class="p">)</span>

<span class="c1">// ... Ta-da! 499999500000</span>
<span class="c1">// Parallel-ready map/reduce; isn&apos;t it *neat*?</span>
<span class="nx">foldP</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)(</span><span class="nx">bigList</span><span class="p">).</span><span class="nx">val</span>
</code></pre></div></div>

<p><strong>Thanks, associativity!</strong> By being <em>certain</em> that the <code class="language-plaintext highlighter-rouge">Semigroup</code> and <code class="language-plaintext highlighter-rouge">Monoid</code> laws hold for our type, we can write functions to <strong>optimise</strong> for different data sets, and other developers can use our API with no idea of the <strong>wizardry</strong> underneath!</p>

<hr>

<p>So, monoids let us write easily-optimised and <em>expressive</em> <code class="language-plaintext highlighter-rouge">reduce</code> operations. Pretty neat, huh? There is a tiny downside, though&#x2026;</p>

<p>The <em>fiddly</em> part about monoids in JavaScript is that we have to pass in <em>type representations</em> (what we called <code class="language-plaintext highlighter-rouge">M</code>). The <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a> puts these in signatures as <code class="language-plaintext highlighter-rouge">TypeRep</code> values, in case you&#x2019;ve wondered what they were. These have to be here because JavaScript, unlike other languages, can&#x2019;t <em>deduce</em> the type we&#x2019;re working with, so we have to give it a friendly nudge. For example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// How do we know which `empty` we want? In</span>
<span class="c1">// Haskell, the correct `empty` would be used</span>
<span class="c1">// because the type would be checked to find the</span>
<span class="c1">// right monoid instance in the context.</span>
<span class="kd">const</span> <span class="nx">concatAll</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">concat</span><span class="p">,</span> <span class="nx">empty</span><span class="p">)</span>

<span class="c1">// In JS, the TypeRep avoids this issue.</span>
<span class="kd">const</span> <span class="nx">concatAll_</span> <span class="o">=</span> <span class="nx">M</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">concat</span><span class="p">,</span> <span class="nx">M</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>
</code></pre></div></div>

<p>This becomes more apparent when we get onto <strong>composed monoids</strong>. Just as we saw with semigroups, let&#x2019;s imagine we want to make <code class="language-plaintext highlighter-rouge">Pair</code> a monoid:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="nx">Pair</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="c1">// ???</span>
</code></pre></div></div>

<p>Remember: the <code class="language-plaintext highlighter-rouge">empty</code> value must work for all cases, and a Pair could be made of <em>any</em> of our monoids. The solution? Pass in the <code class="language-plaintext highlighter-rouge">TypeRep</code>s:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We now have a kind of &quot;Pair factory&quot;!</span>
<span class="c1">// Pair_ :: (Monoid a, Monoid b) =&gt;</span>
<span class="c1">//   (TypeRep a, TypeRep b) -&gt; (a, b) -&gt; Pair a b</span>
<span class="kd">const</span> <span class="nx">Pair_</span> <span class="o">=</span> <span class="p">(</span><span class="nx">typeA</span><span class="p">,</span> <span class="nx">typeB</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">Pair</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Pair</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">a</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">b</span><span class="dl">&apos;</span><span class="p">])</span>

  <span class="nx">Pair</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">typeA</span><span class="p">.</span><span class="nx">empty</span><span class="p">(),</span>
                          <span class="nx">typeB</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span>

  <span class="c1">// You could write `concat` here and include</span>
  <span class="c1">// some type-checking in its logic!</span>

  <span class="k">return</span> <span class="nx">Pair</span>
<span class="p">}</span>

<span class="c1">// We can partially apply to get Pair</span>
<span class="c1">// constructors for specific types...</span>
<span class="kd">const</span> <span class="nx">MyPair</span> <span class="o">=</span> <span class="nx">Pair_</span><span class="p">(</span><span class="nx">Sum</span><span class="p">,</span> <span class="nx">Any</span><span class="p">)</span>

<span class="c1">// ... and these have valid empty() values!</span>
<span class="c1">// Pair(Sum(0), Any(False))</span>
<span class="nx">MyPair</span><span class="p">.</span><span class="nx">empty</span><span class="p">()</span>

<span class="c1">// We can also call it directly.</span>
<span class="c1">// Pair(All(True), Max(-Infinity))</span>
<span class="nx">Pair_</span><span class="p">(</span><span class="nx">All</span><span class="p">,</span> <span class="nx">Max</span><span class="p">).</span><span class="nx">empty</span><span class="p">()</span>
</code></pre></div></div>

<p>Some extra ugly boilerplate, but we <em>do</em> end up with the same result. We&#x2019;re going to see a lot more of these <code class="language-plaintext highlighter-rouge">TypeRep</code> values floating about, and it <em>is</em> unfortunate. Still, if you want to write type-safe JavaScript <em>without</em> all this hassle, check out <a href="http://www.purescript.org">PureScript</a>!</p>

<hr>

<p>There are loads of weird and wonderful monoids that we haven&#x2019;t covered. For example, an <code class="language-plaintext highlighter-rouge">a -&gt; b</code> function is a monoid if <code class="language-plaintext highlighter-rouge">b</code> is a monoid:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// concat :: (Semigroup b) =&gt;</span>
<span class="c1">//   (a -&gt; b) ~&gt; (a -&gt; b) -&gt; (a -&gt; b)</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">that</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Are you fed up of TypeReps yet? If you _did_</span>
<span class="c1">// want to implement this, you&apos;re probably better</span>
<span class="c1">// off setting it manually for the functions you</span>
<span class="c1">// are likely to concat... Sigh.</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="c1">// result.empty()</span>
</code></pre></div></div>

<p>Effectively, we just concatenate the results of calling <em>both</em> functions with a given argument. If this seems useless, check out Hardy Jones&#x2019; post on implementing <a href="https://joneshf.github.io/programming/2014/09/24/FizzBuzz-With-Semigroups-And-Apply.html">FizzBuzz with monoids</a>! They are <em>really</em> clever structures that, with a bit of imagination, can be spotted <strong>everywhere</strong> in the wild. We&#x2019;ll actually come back to them time and time again in the articles to come, so get used to them!</p>

<p>Again, this post only touches the <em>surface</em> of <a href="https://www.youtube.com/watch?v=moAfgDFVLUs">what monoids can do</a>, and I&#x2019;m surprised by new examples all the time. Keep researching, keep looking for examples, see whether you could replace some of your code&#x2019;s <code class="language-plaintext highlighter-rouge">Array.reduce</code> calls with monoid folds, and start to build up a library of reusable <code class="language-plaintext highlighter-rouge">Monoid</code> types to encapsulate your logic. <strong>Exciting times</strong>!</p>

<p>Next time, we&#x2019;ll look at <code class="language-plaintext highlighter-rouge">Functor</code> - our first step on the road to the magical <code class="language-plaintext highlighter-rouge">Monad</code>. Until then, Fantasists,</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 3: Setoid</h1>
  <span class="post-date">09 Mar 2017</span>
  <p><strong>Congratulations!</strong> You&#x2019;ve mastered <a href="/2017/03/03/fantas-eel-and-specification/">the fundamentals of <code class="language-plaintext highlighter-rouge">daggy</code></a>, nailed the <a href="/2017/03/08/fantas-eel-and-specification-2/">intro to type signatures</a>, and are ready to begin your journey through Fantasy Land. First stop: the <strong>setoid</strong>.</p>

<p><strong>A setoid</strong> is any type with a notion of <strong>equivalence</strong>. You already use plenty of setoids (<strong>integers</strong>, <strong>booleans</strong>, <strong>strings</strong>) almost every time you use the <code class="language-plaintext highlighter-rouge">==</code> operator, so this shouldn&#x2019;t be too tricky. You also use things that <em>aren&#x2019;t</em> setoids, like <strong>functions</strong>.</p>

<blockquote>
  <p>This may seem weird, but how could we <em>reliably</em> know whether two functions were equivalent? While our compiler will confidently tell us that <code class="language-plaintext highlighter-rouge">100 * 10</code> is equivalent to <code class="language-plaintext highlighter-rouge">1000</code>, it won&#x2019;t be brave enough to say <code class="language-plaintext highlighter-rouge">x =&gt; x * x</code> is equivalent to <code class="language-plaintext highlighter-rouge">x =&gt; Math.pow(x, 2)</code>; it&#x2019;s really not a trivial thing to work out!*</p>
</blockquote>

<p>Now, for a type to be a <em>Fantasy Land-compliant</em> setoid, it must have a prototype method called <code class="language-plaintext highlighter-rouge">equals</code> with the following signature:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equals</span> <span class="o">::</span> <span class="kt">Setoid</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Boolean</span>
</code></pre></div></div>

<p>Nothing too scary, I hope? Just a way of finding out whether one thing equals another. Let&#x2019;s write some <code class="language-plaintext highlighter-rouge">Setoid</code> instances for types from <a href="/2017/03/03/fantas-eel-and-specification/">our first article</a>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Check that each point matches</span>
<span class="c1">// equals :: Coord ~&gt; Coord -&gt; Bool</span>
<span class="nx">Coord</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">that</span><span class="p">.</span><span class="nx">x</span>
      <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="nx">that</span><span class="p">.</span><span class="nx">y</span>
      <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">===</span> <span class="nx">that</span><span class="p">.</span><span class="nx">z</span>
<span class="p">}</span>

<span class="c1">// Check each Coord with Coord.equals</span>
<span class="c1">// equals :: Line ~&gt; Line -&gt; Bool</span>
<span class="nx">Line</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="k">from</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="k">from</span><span class="p">)</span>
      <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">to</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// The this&apos; &quot;true-ness&quot; must match that&apos;s!</span>
<span class="c1">// equals :: Bool ~&gt; Bool -&gt; Bool</span>
<span class="nx">Bool</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Bool</span><span class="p">.</span><span class="nx">True</span>
    <span class="o">===</span> <span class="nx">that</span> <span class="k">instanceof</span> <span class="nx">Bool</span><span class="p">.</span><span class="nx">True</span>
<span class="p">}</span>

<span class="c1">// Check the lists&apos; heads, then their tails</span>
<span class="c1">// equals :: Setoid a =&gt; [a] ~&gt; [a] -&gt; Bool</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="c1">// Note the two different Setoid uses:</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">head</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="c1">// a</span>
        <span class="o">&amp;&amp;</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">tail</span><span class="p">),</span> <span class="c1">// [a]</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="nx">List</span><span class="p">.</span><span class="nx">Nil</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You get the idea, right? If we have multiple constructors, we check for the same <strong>constructor</strong>. If the constructor/s take/s arguments, then we probably check those as well. Of course, if we do, <strong>the arguments must be setoids</strong>; how else could we check that they&#x2019;re equivalent?</p>

<p>In fact, this requirement is exactly why we have the <strong>type constraint</strong> on <code class="language-plaintext highlighter-rouge">List</code>&#x2019;s <code class="language-plaintext highlighter-rouge">equals</code> implementation: we need to be able to compare the <em>whole</em> structure, innards and all!</p>

<p>Sadly, the ugly side-effect of using JavaScript is that we&#x2019;re going to have to mix <code class="language-plaintext highlighter-rouge">===</code> and <code class="language-plaintext highlighter-rouge">.equals</code> depending on whether we&#x2019;re working with <em>primitive</em> types or not. It&#x2019;s a shame; in other languages, we could <strong>override</strong> the behaviour of <code class="language-plaintext highlighter-rouge">===</code> for custom types, but not JavaScript. You <em>could</em> add <code class="language-plaintext highlighter-rouge">.equals</code> to the primitive values&#x2019; prototypes, but this is generally considered a bad idea. <em>Best not fiddle with standard prototypes.</em></p>

<p>Still, these <code class="language-plaintext highlighter-rouge">.equals</code> implementations are quite pretty, right?</p>

<hr>

<p>All the Fantasy Land structures come with <strong>laws</strong> that must be obeyed for the instance to be valid, and <code class="language-plaintext highlighter-rouge">Setoid</code> is no exception. In order to make sure your type behaves itself when used with other libraries and algorithms, there are just three things we have to remember. <strong>In all cases</strong>:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">a.equals(a) === true</code>, which we call <strong>reflexivity</strong>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">a.equals(b) === b.equals(a)</code>. This is <strong>symmetry</strong> or <strong>commutativity</strong> - you can give the values either way round. Remember that operations like subtraction <em>aren&#x2019;t</em> commutative, and there are other <a href="https://www.quora.com/Is-floating-point-addition-commutative-and-associative">non-commutative examples</a> that may surprise you!</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">a.equals(b)</code> and <code class="language-plaintext highlighter-rouge">b.equals(c)</code>, then it&#x2019;s always true that <code class="language-plaintext highlighter-rouge">a.equals(c)</code>: the law of <strong>transitivity</strong>.</p>
  </li>
</ul>

<p>We can see without too much trouble that all these would hold for the <code class="language-plaintext highlighter-rouge">.equals</code> implementations above, <em>as long as we respect the type signatures!</em></p>

<p>If none of these laws are particularly surprising to you, that&#x2019;s a great thing! This means that you have a good <strong>intuition</strong> for what a <code class="language-plaintext highlighter-rouge">Setoid</code> is. Later in the series, we&#x2019;ll get to more complex structures, and finding an intuition will be incredibly valuable for working out how to <em>use</em> them.</p>

<p>If you&#x2019;re now <em>desperate</em> for an exercise, why not write an <code class="language-plaintext highlighter-rouge">.equals</code> implementation for the built-in <code class="language-plaintext highlighter-rouge">Array</code> type to make it a <code class="language-plaintext highlighter-rouge">Setoid</code>? Add it to <code class="language-plaintext highlighter-rouge">Array.prototype</code> - I won&#x2019;t tell - and be sure that your implementation obeys the laws above.</p>

<p>If you wanted to, you could also <strong>derive</strong> a function called <code class="language-plaintext highlighter-rouge">notEquals</code> using <code class="language-plaintext highlighter-rouge">Setoid</code>&#x2019;s shiny new <code class="language-plaintext highlighter-rouge">.equals</code> method:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// notEquals :: Setoid a =&gt; a -&gt; a -&gt; Bool</span>
<span class="kd">const</span> <span class="nx">notEquals</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="p">...</span>
</code></pre></div></div>

<p>If you&#x2019;re <em>not</em> desperate for exercises, (<em>or you&#x2019;ve managed to sate your burning desire <strong>at long last</strong></em>), shall we move onto what the point of all this fuss is? If we have formal definitions of things like <code class="language-plaintext highlighter-rouge">Setoid</code> (however straightforward it may be), we can define <strong>sensible interfaces</strong> for working with all sorts of data. Consider this function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nub</span> <span class="o">::</span> <span class="kt">Setoid</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<p><em>I think <code class="language-plaintext highlighter-rouge">nub</code> might be my favourite name of any function</em>. In practice, <code class="language-plaintext highlighter-rouge">nub</code> returns a copy of the given array with the duplicates removed. That&#x2019;s it! You might also have heard it called <code class="language-plaintext highlighter-rouge">uniq</code>. At first glance, this is easy to write in JavaScript:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">nub</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">i</span><span class="p">)</span>
</code></pre></div></div>

<p>This is <em>okay</em>, but we run into a problem: for non-primitive structures, this only works if equivalent values always inhabit the same space in memory. This, however, is not usually the case: if we try <code class="language-plaintext highlighter-rouge">[[]].indexOf([])</code>, we get back <code class="language-plaintext highlighter-rouge">-1</code>, even though we can clearly see <code class="language-plaintext highlighter-rouge">[]</code> in that array! How could we fix this? <code class="language-plaintext highlighter-rouge">Setoid</code> to the rescue!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// indexOf :: Setoid a =&gt; [a] -&gt; a -&gt; Int</span>
<span class="kd">const</span> <span class="nx">indexOf</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">equals</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="k">return</span> <span class="nx">i</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// nub_ :: Setoid a =&gt; [a] -&gt; [a]</span>
<span class="kd">const</span> <span class="nx">nub_</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">indexOf</span><span class="p">(</span><span class="nx">xs</span><span class="p">)(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="nx">i</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Now, we have a function that will work for any array of a <code class="language-plaintext highlighter-rouge">Setoid</code> type. If we know our function will be used <em>responsibly</em> (that is, <em>only ever with arrays of a <code class="language-plaintext highlighter-rouge">Setoid</code> type</em>), we could even add an exception to make it work for primitives - exactly how <a href="https://github.com/ramda/ramda/blob/v0.23.0/src/internal/_equals.js#L22">Ramda&#x2019;s equality</a> works! Goodness, would you <em>look</em> at all this Polymorphism.</p>

<hr>

<p>I think I most often see mention of <code class="language-plaintext highlighter-rouge">Setoid</code> (and <code class="language-plaintext highlighter-rouge">Eq</code>, as they call it in the Haskell world) among <code class="language-plaintext highlighter-rouge">List</code> and <code class="language-plaintext highlighter-rouge">Array</code> functions, which give plenty of opportunities for exercises to cement your understanding:</p>

<ul>
  <li>
    <p>Write a function to determine whether a given list&#x2019;s values form a <strong>palindrome</strong> (e.g. whether a list is equivalent to itself <em>reversed</em>). We&#x2019;ll need a <code class="language-plaintext highlighter-rouge">Setoid</code> instance for the inner type to make sure it&#x2019;s nice and general. <em>As a small hint, you could write a na&#xEF;ve solution with that <code class="language-plaintext highlighter-rouge">zipWith</code> function we mentioned earlier&#x2026;</em></p>
  </li>
  <li>
    <p>Use <code class="language-plaintext highlighter-rouge">daggy</code> to build a <code class="language-plaintext highlighter-rouge">Set</code> type that stores a unique set of values; you can even reuse <code class="language-plaintext highlighter-rouge">nub_</code>! You&#x2019;ll need methods for <strong>adding</strong> and <strong>removing</strong> elements, and the former will need a check to see whether the element already exists in the internal store (probably an array).</p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Setoid</code> is, without a doubt, the <em>simplest</em> structure within the Fantasy Land spec, but that makes it a really good one to start with. For most, the intuition required to understand this one will be perfectly natural, and none of the laws should come as a shock.</p>

<p>Don&#x2019;t get too cosy, though! Next time, we&#x2019;ll move onto a far more weird and wonderful structure: the <strong>semigroup</strong>. Ooer.</p>

<p>Until then, I hope you&#x2019;ve enjoyed this post. Please <a href="https://twitter.com/am_i_tom">get in touch</a> with any feedback and suggestions - I really want to make this series as <em>useful</em> as possible! - and don&#x2019;t hesitate to ask for more examples, exercises, or explanations. Oh, and, as always:</p>

<p>Take care &#x2665;</p>

<hr>

<p><em>* The important point here is that equivalence is <strong>much deeper</strong> than pointer equality. Just try typing <code class="language-plaintext highlighter-rouge">(x =&gt; x) === (x =&gt; x)</code> into your Node REPL.</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 1: Daggy</h1>
  <span class="post-date">03 Mar 2017</span>
  <p>Hello again, the Internet! As a functional programming zealot* and JavaScript developer<sup>&#x2020;</sup>, I spend a <strong>lot</strong> of my time raving about their crossover. In this series, we&#x2019;ll look at the <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land</a> spec in its entirety, and go through examples of how we can use the typeclasses within it. However, before we go any further, we need to talk about <a href="https://github.com/fantasyland/daggy"><code class="language-plaintext highlighter-rouge">daggy</code></a>.</p>

<p>Daggy is a <em>tiny</em> library for creating <strong>sum types</strong> for functional programs. Don&#x2019;t worry about what that means too much for now, and focus on the two functions that the library exports: <code class="language-plaintext highlighter-rouge">tagged</code> and <code class="language-plaintext highlighter-rouge">taggedSum</code>.</p>

<h2 id="daggytaggedtypename-fields"><code class="language-plaintext highlighter-rouge">daggy.tagged(typeName, fields)</code></h2>

<p>This is a very simple method for creating types with one constructor. In other words, think of it as a way to store your very rigid (probably model) data:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//- A coordinate in 3D space.</span>
<span class="c1">//+ Coord :: (Int, Int, Int) -&gt; Coord</span>
<span class="kd">const</span> <span class="nx">Coord</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Coord</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">x</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">y</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">z</span><span class="dl">&apos;</span><span class="p">])</span>

<span class="c1">//- A line between two coordinates.</span>
<span class="c1">//+ Line :: (Coord, Coord) -&gt; Line</span>
<span class="kd">const</span> <span class="nx">Line</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">tagged</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Line</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">from</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">to</span><span class="dl">&apos;</span><span class="p">])</span>
</code></pre></div></div>

<p>The resulting structures are pretty intuitive:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We can add methods...</span>
<span class="nx">Coord</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">translate</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Named properties!</span>
    <span class="k">return</span> <span class="nx">Coord</span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">y</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">z</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="c1">// Auto-fills the named properties</span>
<span class="kd">const</span> <span class="nx">origin</span> <span class="o">=</span> <span class="nx">Coord</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">myLine</span> <span class="o">=</span> <span class="nx">Line</span><span class="p">(</span>
  <span class="nx">origin</span><span class="p">,</span>
  <span class="nx">origin</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This is nothing scary if you&#x2019;ve used the JavaScript object system before: all the <code class="language-plaintext highlighter-rouge">tagged</code> function really does is give us a function to fill the given named properties on an object. <strong>That&#x2019;s it</strong>. A tiny little utility for creating constructors with named properties.</p>

<h2 id="daggytaggedsumtypename-constructors"><code class="language-plaintext highlighter-rouge">daggy.taggedSum(typeName, constructors)</code></h2>

<p>Now for the interesting one. Think about the boolean type: it has two values, <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code>. In order to represent a structure like <code class="language-plaintext highlighter-rouge">Bool</code>, we need to make a type with multiple constructors (what we call a <strong>sum type</strong>):</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Bool</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">taggedSum</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Bool</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">True</span><span class="p">:</span> <span class="p">[],</span> <span class="na">False</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>We call the different forms of our type its <strong>type constructors</strong>: in this case, they&#x2019;re <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code>, and neither has any arguments. How about we take our code from the <code class="language-plaintext highlighter-rouge">tagged</code> example and build up a more complicated type?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">taggedSum</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Shape</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Square :: (Coord, Coord) -&gt; Shape</span>
  <span class="na">Square</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">topleft</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">bottomright</span><span class="dl">&apos;</span><span class="p">],</span>

  <span class="c1">// Circle :: (Coord, Number) -&gt; Shape</span>
  <span class="na">Circle</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">centre</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">radius</span><span class="dl">&apos;</span><span class="p">]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Unlike the boolean values, our constructors here have values. They take <em>different</em> values depending on which constructor we use, but we know that <code class="language-plaintext highlighter-rouge">Square</code> and <code class="language-plaintext highlighter-rouge">Circle</code> are definitely both constructors of the <code class="language-plaintext highlighter-rouge">Shape</code> type. How does this help us?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">translate</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">Square</span><span class="p">:</span> <span class="p">(</span><span class="nx">topleft</span><span class="p">,</span> <span class="nx">bottomright</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">Shape</span><span class="p">.</span><span class="nx">Square</span><span class="p">(</span>
          <span class="nx">topleft</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">),</span>
          <span class="nx">bottomright</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
        <span class="p">),</span>

      <span class="na">Circle</span><span class="p">:</span> <span class="p">(</span><span class="nx">centre</span><span class="p">,</span> <span class="nx">radius</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">Shape</span><span class="p">.</span><span class="nx">Circle</span><span class="p">(</span>
          <span class="nx">centre</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">),</span>
          <span class="nx">radius</span>
        <span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>

<span class="nx">Shape</span><span class="p">.</span><span class="nx">Square</span><span class="p">(</span><span class="nx">Coord</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">Coord</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// Square(Coord(5, 5, 3), Coord(6, 6, 3))</span>

<span class="nx">Shape</span><span class="p">.</span><span class="nx">Circle</span><span class="p">(</span><span class="nx">Coord</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// Circle(Coord(7, 7, 7), 8)</span>
</code></pre></div></div>

<p>Just as before, we are attaching methods to the <code class="language-plaintext highlighter-rouge">Shape</code> prototype. However, <code class="language-plaintext highlighter-rouge">Shape</code> isn&#x2019;t a <em>constructor</em>, it&#x2019;s a <em>type</em>: <code class="language-plaintext highlighter-rouge">Shape.Square</code> and <code class="language-plaintext highlighter-rouge">Shape.Circle</code> are the constructors.</p>

<p>This means that, when we write a method, we have to write something that will work for <em>all</em> forms of the <code class="language-plaintext highlighter-rouge">Shape</code> type, and <code class="language-plaintext highlighter-rouge">this.cata</code> is Daggy&#x2019;s killer feature. <em>By the way, <code class="language-plaintext highlighter-rouge">cata</code> is short for <a href="/2017/02/24/reductio-and-abstract-em/">catamorphism</a>!</em></p>

<p>All we do is pass a <code class="language-plaintext highlighter-rouge">{ constructor: handler }</code> object to the <code class="language-plaintext highlighter-rouge">cata</code> function, and the appropriate one will be called when the method is invoked. As we can see above, we now have a <code class="language-plaintext highlighter-rouge">translate</code> method that will work for both types of <code class="language-plaintext highlighter-rouge">Shape</code>!</p>

<p>We could even attach methods to our <code class="language-plaintext highlighter-rouge">Bool</code> type:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">True</span><span class="p">,</span> <span class="nx">False</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">Bool</span>

<span class="c1">// Flip the value of the Boolean.</span>
<span class="nx">Bool</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">invert</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">False</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">True</span><span class="p">,</span>
    <span class="na">True</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">False</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Shorthand for Bool.prototype.cata?</span>
<span class="nx">Bool</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">thenElse</span> <span class="o">=</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">then</span><span class="p">,</span> <span class="nx">or</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
      <span class="na">True</span><span class="p">:</span> <span class="nx">then</span><span class="p">,</span>
      <span class="na">False</span><span class="p">:</span> <span class="nx">or</span>
    <span class="p">})</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>As you can see, for constructors with no arguments, we use handlers with no arguments. Note, too, that different constructors of the same sum type can have <strong>completely different numbers and types of arguments</strong>. This will be <em>really</em> important when we come to examples of the Fantasy Land structures.</p>

<p>This is all there is to <code class="language-plaintext highlighter-rouge">taggedSum</code>: it lets us build <strong>types with multiple constructors</strong>, and conveniently write methods for them.</p>

<h2 id="list-but-not-least"><code class="language-plaintext highlighter-rouge">List</code> but not least&#x2026;</h2>

<p>As a final example of <code class="language-plaintext highlighter-rouge">taggedSum</code> (because I <em>hope</em> <code class="language-plaintext highlighter-rouge">tagged</code> is nice and straightforward), here&#x2019;s a linked list and a couple of useful functions:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">List</span> <span class="o">=</span> <span class="nx">daggy</span><span class="p">.</span><span class="nx">taggedSum</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">List</span><span class="dl">&apos;</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">Cons</span><span class="p">:</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">head</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">tail</span><span class="dl">&apos;</span><span class="p">],</span> <span class="na">Nil</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">})</span>

<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">List</span><span class="p">.</span><span class="nx">Cons</span><span class="p">(</span>
      <span class="nx">f</span><span class="p">(</span><span class="nx">head</span><span class="p">),</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">),</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">List</span><span class="p">.</span><span class="nx">Nil</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// A &quot;static&quot; method for convenience.</span>
<span class="nx">List</span><span class="p">.</span><span class="k">from</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">xs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">List</span><span class="p">.</span><span class="nx">Cons</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span>
    <span class="nx">List</span><span class="p">.</span><span class="nx">Nil</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// And a conversion back for convenience!</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toArray</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span>
      <span class="nx">x</span><span class="p">,</span> <span class="p">...</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">toArray</span><span class="p">()</span>
    <span class="p">],</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// [3, 4, 5]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">List</span><span class="p">.</span><span class="k">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toArray</span><span class="p">())</span>
</code></pre></div></div>

<p>Sure enough, we can build a list with two constructors, <code class="language-plaintext highlighter-rouge">Cons</code> and <code class="language-plaintext highlighter-rouge">Nil</code> (as we did with <code class="language-plaintext highlighter-rouge">[x, ... xs]</code> and <code class="language-plaintext highlighter-rouge">[]</code> in <a href="/2017/02/24/reductio-and-abstract-em/">my last post</a>), and every list object will have a corresponding array object<sup>&#x2021;</sup>. For example, <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> becomes <code class="language-plaintext highlighter-rouge">Cons(1, Cons(2, Cons(3, Nil)))</code>, so it&#x2019;s pretty obvious to see how <em>any</em> list can be translated!</p>

<hr>

<p>That&#x2019;s <em>everything</em> you need to know about <code class="language-plaintext highlighter-rouge">daggy</code> to understand Fantasy Land! If you want to cement your understanding, why not try to add a couple more array functions to the <code class="language-plaintext highlighter-rouge">List</code> type like <code class="language-plaintext highlighter-rouge">filter</code> or <code class="language-plaintext highlighter-rouge">reduce</code>?</p>

<p>Otherwise, we have one more thing to talk about before we get involved in the structures: <a href="/2017/03/08/fantas-eel-and-specification-2/">type signatures</a>!</p>

<p>Until then, take care! &#x2665;</p>

<hr>

<p><em>* My (verbatim) introduction by <a href="https://twitter.com/MrDanack">Dan</a> to members of the PHP core team.</em></p>

<p><em><sup>&#x2020;</sup> Even if only by a technicality.</em></p>

<p><em><sup>&#x2021;</sup> We call this an <strong>isomorphism</strong>!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Fantas, Eel, and Specification 2: Type Signatures</h1>
  <span class="post-date">08 Mar 2017</span>
  <p><a href="https://en.wikiquote.org/wiki/Garth_Marenghi&apos;s_Darkplace#Once_Upon_A_Beginning_.5B1.1.5D">Greetings, traveller</a>. I hope you&#x2019;ve been having a good one since I posted the <a href="/2017/03/03/fantas-eel-and-specification/">first part of this series</a>, and I&#x2019;d have a read of that before going any further. Assuming you&#x2019;re up-to-date, there&#x2019;s <em>one more little thing</em> I thought we should talk about before we go head-first into the spec: <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><strong>Damas&#x2013;Hindley&#x2013;Milner type signatures</strong></a>.</p>

<p>Don&#x2019;t panic.</p>

<h2 id="intro-java---haskell">Intro: <code class="language-plaintext highlighter-rouge">Java -&gt; Haskell</code></h2>

<p>Chances are you&#x2019;ve seen languages with explicitly-written (<strong>static</strong>) types before. Things like Java, maybe:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<p>This line tells us that a function, <code class="language-plaintext highlighter-rouge">main</code>, takes an array of <code class="language-plaintext highlighter-rouge">String</code> values, and returns <code class="language-plaintext highlighter-rouge">void</code> (nothing). That is the function&#x2019;s <strong>type signature</strong>. Damas-Hindley-Milner signatures are just a different way of writing types. Y&#x2019;know what, let&#x2019;s save characters and just call them <em>type signatures</em> from now on.</p>

<p>When we go through these examples, bear one thing in mind: <strong>all</strong> functions are curried. I&#x2019;ve written about <a href="/2016/11/12/curry-on-wayward-son/">currying in JavaScript</a> before, so take a look if you&#x2019;re unsure. <abbr title="too long; didn&apos;t read">tl;dr</abbr>, whereas we&#x2019;d write an <code class="language-plaintext highlighter-rouge">add</code> declaration in a Java-looking language like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="c1">//                     ^ arg  ^ arg</span>
<span class="c1">//             ^ return</span>
</code></pre></div></div>

<p>We&#x2019;d write its <em>curried</em> type signature like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="c1">--      ^  arg ^ arg</span>
<span class="c1">--                    ^ return</span>
</code></pre></div></div>

<p>In English, this says that <em>our <code class="language-plaintext highlighter-rouge">add</code> function takes an integer <code class="language-plaintext highlighter-rouge">x</code>, and returns a function that takes an integer <code class="language-plaintext highlighter-rouge">y</code>, which returns an integer (probably <code class="language-plaintext highlighter-rouge">x + y</code>).</em></p>

<blockquote>
  <p>Now, yes, some of you may be wondering about <strong>uncurried</strong> functions in JavaScript, such as an add function like <code class="language-plaintext highlighter-rouge">(Int, Int) -&gt; Int</code>. However, we say that this would be a <em>one</em> argument function whose single argument is a pair (a <strong>tuple</strong><sup>&#x2020;</sup>). JavaScript is a bit loose with this idea, as we&#x2019;ll see again and again.</p>
</blockquote>

<p>Let&#x2019;s look at <code class="language-plaintext highlighter-rouge">zipWith</code>, a slightly more complicated example. Here&#x2019;s a possible implementation in JavaScript:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">zipWith</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">ys</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
    <span class="nx">xs</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">ys</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">)</span>

  <span class="kd">const</span> <span class="nx">zs</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">xs</span><span class="p">[</span><span class="nx">i</span><span class="p">])(</span><span class="nx">ys</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">zs</span>
<span class="p">}</span>

<span class="c1">// Returns [ 5, 7 ]</span>
<span class="nx">zipWith</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></div></div>

<p>Our beautiful <code class="language-plaintext highlighter-rouge">zipWith</code> takes the values at each index of the two arrays (until the shortest one runs out), and applies them to <code class="language-plaintext highlighter-rouge">f</code>, returning an array of the results. <em>If it isn&#x2019;t clear how this function works, play around with some examples before continuing</em>. Let&#x2019;s think about types:</p>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">f</code> function must take two arguments of two types (we&#x2019;ll call them <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>), and these must be the respective types of <code class="language-plaintext highlighter-rouge">xs</code>&#x2019; and <code class="language-plaintext highlighter-rouge">ys</code>&#x2019; array values.</p>
  </li>
  <li>
    <p>The return type of <code class="language-plaintext highlighter-rouge">zipWith</code> is an array of the return type of <code class="language-plaintext highlighter-rouge">f</code>. So, if <code class="language-plaintext highlighter-rouge">f</code> returns some type <code class="language-plaintext highlighter-rouge">c</code>, then <code class="language-plaintext highlighter-rouge">zipWith(f)</code> must return an array of <code class="language-plaintext highlighter-rouge">c</code>.</p>
  </li>
</ul>

<p>How do we write that as a type signature? Just like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zipWith</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
</code></pre></div></div>

<p>We&#x2019;ve used <strong>type variables</strong> to represent places where we can take different types (you might know this as <strong>polymorphism</strong>). You don&#x2019;t have to call them <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code> - you could just as easily call them <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">dog</code>, and <code class="language-plaintext highlighter-rouge">jeff</code> (but don&#x2019;t). <em>The only rule here is that type <strong>variables</strong> always start with a lowercase letter, and <strong>concrete types</strong> always start with an uppercase letter.</em></p>

<p>Because we could fill the <code class="language-plaintext highlighter-rouge">a</code> variable with <em>any</em> type (as long as our <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">xs</code> agree!), we can write <em>one</em> <code class="language-plaintext highlighter-rouge">zipWith</code> signature that works for <em>any</em> type <code class="language-plaintext highlighter-rouge">a</code>. Neat, huh? In fact, <code class="language-plaintext highlighter-rouge">zipWith</code> is a great example of a tool that we see all over functional code <em>because</em> its variables make it so flexible:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a = Int</span>
<span class="c1">// b = String</span>
<span class="c1">// c = Bool</span>

<span class="c1">// Returns [ true, false ]</span>
<span class="nx">zipWith</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])([</span><span class="dl">&apos;</span><span class="s1">Good</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Bad</span><span class="dl">&apos;</span><span class="p">])</span>
</code></pre></div></div>

<p>Here, our <code class="language-plaintext highlighter-rouge">a</code> is filled in with <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">b</code> with <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">c</code> with <code class="language-plaintext highlighter-rouge">Bool</code>. However, we could just as easily make them all <code class="language-plaintext highlighter-rouge">Int</code> and zip with <code class="language-plaintext highlighter-rouge">x =&gt; y =&gt; x + y</code>! I sure hope you can handle all this excitement. Here&#x2019;s one last example of a function with a type variable:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filter an array by a predicate.</span>
<span class="c1">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
<span class="kd">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</code></pre></div></div>

<p>Our function will work for <em>any</em> <code class="language-plaintext highlighter-rouge">a</code> as long as our <code class="language-plaintext highlighter-rouge">p</code> function knows how to turn an <code class="language-plaintext highlighter-rouge">a</code> into a <code class="language-plaintext highlighter-rouge">Bool</code>. Yay!</p>

<p>Notice that both <code class="language-plaintext highlighter-rouge">filter</code> and <code class="language-plaintext highlighter-rouge">zipWith</code> have an argument that happens to be a <em>function</em>. To represent it in the signature, we &#x201C;nest&#x201D; its (bracket-wrapped) signature into our overall one.</p>

<p>Phew! That&#x2019;s basically all there is to it. We break up each type with an <code class="language-plaintext highlighter-rouge">-&gt;</code>, so the one at the end is the return value, and all the others are the arguments. In fact, this is <em>all</em> you need to read and write <a href="http://elm-lang.org/">Elm</a> type signatures - <a href="/2016/12/11/the-orrery/">go write some Elm</a>!</p>

<p>For <em>this</em> series, though, we&#x2019;re going to have to complicate matters and introduce a couple more things&#x2026;</p>

<h2 id="type-constraints">Type Constraints</h2>

<p><code class="language-plaintext highlighter-rouge">zipWith</code> and <code class="language-plaintext highlighter-rouge">filter</code> are great, because their type variables can be <em>any</em> type. Sometimes, however, we don&#x2019;t have that luxury. We might have to deal with signatures like these:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equals</span> <span class="o">::</span> <span class="kt">Setoid</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">=&gt;</code> is new notation. What this means is that the signature to its <em>right</em> is valid if all the conditions to its <em>left</em> are satisfied. In the case of <code class="language-plaintext highlighter-rouge">equals</code>, the signature <code class="language-plaintext highlighter-rouge">a -&gt; a -&gt; Bool</code> is valid if <code class="language-plaintext highlighter-rouge">a</code> is a <code class="language-plaintext highlighter-rouge">Setoid</code>. Don&#x2019;t worry about what a <code class="language-plaintext highlighter-rouge">Setoid</code> is just yet, as we&#x2019;ll be covering exactly what it means in the next article. For now, just think of a <code class="language-plaintext highlighter-rouge">Setoid</code> as <em>a type for which we can check whether two of its values are equivalent</em>.</p>

<p>Constraints are <em>very</em> important. When we have a signature that involves a type variable with <em>no</em> constraints, we know that the function <strong>can&#x2019;t manipulate it</strong> in any way. We know by looking at the signature <code class="language-plaintext highlighter-rouge">id :: a -&gt; a</code> that all it <em>could</em> ever do is return the value it has been given, because we know nothing else about <code class="language-plaintext highlighter-rouge">a</code> - it could be a number, or a function, or anything! This feeds into an idea called <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">parametricity</a> that we&#x2019;ll come back to several times in this series.</p>

<p>In languages like Haskell, the compiler will make sure that the conditions on the left are satisfied at compile-time, which catches a whole host of bugs! However, for our purposes, we&#x2019;ll see that it&#x2019;s simply some <em>really</em> handy documentation.</p>

<h2 id="oop-lease-stop">OOP-lease Stop</h2>

<p>It wouldn&#x2019;t be JavaScript without some bodging, would it? <em>Because</em> JavaScript is the way it is, we tend to build our types with methods like <code class="language-plaintext highlighter-rouge">equals</code> attached to the prototype:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Rather than this:</span>
<span class="nx">equals</span><span class="p">(</span><span class="nx">first</span><span class="p">)(</span><span class="nx">second</span><span class="p">)</span>

<span class="c1">// We do this:</span>
<span class="nx">first</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">second</span><span class="p">)</span>
</code></pre></div></div>

<p>Fair enough - it&#x2019;s certainly neater. However, it messes with our pretty signatures because <code class="language-plaintext highlighter-rouge">equals</code> now isn&#x2019;t a function of two arguments: it&#x2019;s a <em>method</em> of one argument <strong>attached to</strong> a value. Remember, though, that the argument must have the same type as the object to which <code class="language-plaintext highlighter-rouge">equals</code> is attached. In Fantasy Land, you&#x2019;ll see the following style used to express this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equals</span> <span class="o">::</span> <span class="kt">Setoid</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">~&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">~&gt;</code> is the new symbol here. What this means is that <code class="language-plaintext highlighter-rouge">equals</code> is a <em>method</em> on the thing to the left of <code class="language-plaintext highlighter-rouge">~&gt;</code>, and the thing to the right is its signature. Back in <a href="/2017/03/03/fantas-eel-and-specification/">the previous article</a>, we saw a <code class="language-plaintext highlighter-rouge">List.prototype.toArray</code> method. In the Fantasy Land style, we would write the signature for this method like so:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// toArray :: List a ~&gt; [a]</span>
<span class="nx">List</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toArray</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cata</span><span class="p">({</span>
    <span class="na">Cons</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span>
      <span class="nx">x</span><span class="p">,</span> <span class="p">...</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">toArray</span><span class="p">()</span>
    <span class="p">],</span>

    <span class="na">Nil</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[]</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We&#x2019;re saying that a <code class="language-plaintext highlighter-rouge">List</code> of values with type <code class="language-plaintext highlighter-rouge">a</code> has a method called <code class="language-plaintext highlighter-rouge">toArray</code> that returns an array of type <code class="language-plaintext highlighter-rouge">a</code>. It might not be pretty, dear reader, but it&#x2019;s JavaScript. <em>If you want a little exercise to do, write out a type signature for <code class="language-plaintext highlighter-rouge">List.prototype.map</code>, and make sure it&#x2019;s as general as possible!</em></p>

<h2 id="finish--blog--ending"><code class="language-plaintext highlighter-rouge">finish :: Blog ~&gt; Ending</code></h2>

<p>I <strong>promise</strong> you, that&#x2019;s it. That&#x2019;s everything you&#x2019;ll need to know to live out a fulfilling life as a functional programmer. Once you get used to this syntax, it&#x2019;s just like riding a bike with weird arrows and brackets everywhere. If this article felt a bit heavy, don&#x2019;t worry: just come back to it for reference if you have questions later on in the series.</p>

<p>Regardless, get ready. No more distractions. Next stop: <strong>Fantasy Land</strong>.</p>

<p>Take care &#x2665;</p>

<hr>

<p><em>* An important point here is that equivalence is <strong>much deeper</strong> than pointer equality. Just try typing <code class="language-plaintext highlighter-rouge">(x =&gt; x) === (x =&gt; x)</code> into your Node REPL; for functions to be a valid setoid, this should return <code class="language-plaintext highlighter-rouge">true</code>.</em></p>

<p><em><sup>&#x2020;</sup> Pronounced &#x201C;toople&#x201D;, regardless of which side of the pond you inhabit. Weird, right?</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Reductio and Abstract &apos;em</h1>
  <span class="post-date">24 Feb 2017</span>
  <p>Oh, hey, stranger! Long time no talk. In case you&#x2019;re interested, I&#x2019;ve moved house, job, and company since my last post, hence the hiatus. <strong>Sorry!</strong> Anyway, speaking of terrible segues, have you ever noticed that <em>you can write every list function with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">reduceRight</a></em>?</p>

<h2 id="-uh-no-you-cant"><em>&#x2026; Uh, no, you can&#x2019;t?</em></h2>

<p>Ok, bear with me: there are <strong>two caveats</strong>. For now, let&#x2019;s assume two functions we get for free:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span> <span class="nx">xs</span><span class="p">])</span> <span class="o">=&gt;</span>  <span class="nx">x</span>
<span class="kd">const</span> <span class="nx">cons</span> <span class="o">=</span> <span class="p">(</span> <span class="nx">x</span><span class="p">,</span>     <span class="nx">xs</span> <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span> <span class="nx">xs</span><span class="p">]</span>
</code></pre></div></div>

<p>Immediately, we can see that <code class="language-plaintext highlighter-rouge">cons</code> is really just a strange name for <code class="language-plaintext highlighter-rouge">prepend</code>. I&#x2019;ll explain <em>why</em> we can take these for granted later, but it&#x2019;ll make things much easier in the mean time to go with it. Until then, I promise it&#x2019;s not a cop-out!</p>

<h2 id="-right-ok-you-were-saying"><em>&#x2026; Right, OK. You were saying?</em></h2>

<p>Let&#x2019;s start with everyone&#x2019;s favourite list function: <code class="language-plaintext highlighter-rouge">map</code>. What&#x2019;s cool about this function is that its accumulator <strong>is another list</strong> - we&#x2019;re reducing one list to another!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cons</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">acc</span><span class="p">),</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="c1">// [2, 3, 4]</span>
<span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>Pretty neat, huh? With that realisation, it&#x2019;s actually quite straightforward to implement everyone&#x2019;s second favourite list function, <code class="language-plaintext highlighter-rouge">filter</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">?</span> <span class="nx">cons</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span>
                   <span class="p">:</span>         <span class="nx">acc</span><span class="p">,</span>
  <span class="p">[]</span>
<span class="p">)</span>

<span class="c1">// [1, 2]</span>
<span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p><strong>Bam!</strong> If the condition be met, we <code class="language-plaintext highlighter-rouge">cons</code> the element. Otherwise, we just carry the accumulator through untouched. What about everyone&#x2019;s <em>third</em> favourite list function: <code class="language-plaintext highlighter-rouge">reduce</code>? &#x2026; Well, that&#x2019;s a bit of a complicated one, so let&#x2019;s build up to it.</p>

<h2 id="fine-but-what-about-____"><em>Fine&#x2026; but what about ____?</em></h2>

<p>Name it and we&#x2019;ll write it! Shall we start with <code class="language-plaintext highlighter-rouge">append</code>?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">append</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cons</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span> <span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1">// [1, 2, 3, 4]</span>
<span class="nx">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>This <code class="language-plaintext highlighter-rouge">reduceRight</code> operation actually does <em>nothing</em>, but starts with a non-empty accumulator, which therefore just gets appended! With the same technique, we can write <code class="language-plaintext highlighter-rouge">concat</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">concat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">xs</span><span class="p">,</span> <span class="nx">ys</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cons</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span> <span class="nx">ys</span>
  <span class="p">)</span>

<span class="c1">// [1, 2, 3, 4]</span>
<span class="nx">concat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p>Anyway, now we have <code class="language-plaintext highlighter-rouge">append</code>, we can write <code class="language-plaintext highlighter-rouge">reverse</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="c1">// [3, 2, 1]</span>
<span class="nx">reverse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>This just takes each element from the end of the list and and sticks it to the end of the accumulator. Easy! Moving on, <code class="language-plaintext highlighter-rouge">length</code> is even simpler:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">)</span>

<span class="c1">// 4</span>
<span class="nx">length</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p>This is all fun, but these aren&#x2019;t <em>mind-bending</em>; chances are that you&#x2019;ve already seen <code class="language-plaintext highlighter-rouge">length</code> written as a reduction at some point. Why don&#x2019;t we try something harder? Let&#x2019;s write <code class="language-plaintext highlighter-rouge">elemAt</code>, a function that returns the element at a given index. For example, <code class="language-plaintext highlighter-rouge">elemAt(2, xs)</code> is exactly the same as <code class="language-plaintext highlighter-rouge">xs[2]</code>. Oh yeah, that&#x2019;s right: <strong>array access is a reduction</strong>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">elemAt</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">head</span><span class="p">(</span><span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
  <span class="p">([</span><span class="nx">e</span><span class="p">,</span> <span class="nx">n</span><span class="p">],</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">n</span><span class="p">]</span>
<span class="p">))</span>

<span class="c1">// 3</span>
<span class="nx">elemAt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>So, it&#x2019;s a sneaky one: we count down the index until we hit <code class="language-plaintext highlighter-rouge">0</code>, then &#x201C;save&#x201D; the value at that position. But <strong>wait!</strong> We used <code class="language-plaintext highlighter-rouge">reduce</code>, not <code class="language-plaintext highlighter-rouge">reduceRight</code>!</p>

<p>Well, ok, you <em>could</em> write this function with <code class="language-plaintext highlighter-rouge">reduceRight</code>, and I&#x2019;ll leave that as a (<a href="http://stackoverflow.com/questions/14526254/find-the-kth-element-of-a-list-using-foldr-and-function-application-explana">quite tricky</a>) exercise to the reader. However, it&#x2019;s <em>much</em> easier to understand with <code class="language-plaintext highlighter-rouge">reduce</code>. Besides, if we can prove that <code class="language-plaintext highlighter-rouge">reduce</code> can be written with <code class="language-plaintext highlighter-rouge">reduceRight</code>, this isn&#x2019;t cheating, is it?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">reduce</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">accF</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">accF</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">x</span><span class="p">)),</span>
    <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>
  <span class="p">)(</span><span class="nx">acc</span><span class="p">)</span>
</code></pre></div></div>

<p>Serves you right for asking! The principle is that <strong>we reduce the list to a function</strong> to compute <code class="language-plaintext highlighter-rouge">reduce</code>. We start with <code class="language-plaintext highlighter-rouge">x =&gt; x</code>, which does nothing, and then tack on a new function for each element in the list. Let&#x2019;s work it through with a simple(ish) example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

  <span class="c1">// Expand `reduce` to `reduceRight`</span>
  <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span>
         <span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span><span class="p">)(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
       <span class="p">),</span>

       <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Simplify the reducer</span>
  <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">x</span><span class="p">),</span>
       <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Consume the first element</span>
  <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">x</span><span class="p">),</span>
       <span class="nx">z</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">)((</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)(</span><span class="nx">z</span><span class="p">))</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Simplify the ugly accumulator</span>
  <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">x</span><span class="p">),</span>
       <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Consume the next element</span>
  <span class="o">==</span> <span class="p">[].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">x</span><span class="p">),</span>
       <span class="nx">z</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)((</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)(</span><span class="nx">z</span><span class="p">))</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Simplify the ugly accumulator</span>
  <span class="o">==</span> <span class="p">[].</span><span class="nx">reduceRight</span><span class="p">(</span>
       <span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">x</span><span class="p">),</span>
       <span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">-</span> <span class="mi">3</span>
     <span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// `reduceRight` on [] == acc</span>
  <span class="o">==</span> <span class="p">(</span><span class="nx">z</span> <span class="o">=&gt;</span> <span class="nx">z</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1">// Evaluate</span>
  <span class="o">==</span> <span class="mi">7</span>
</code></pre></div></div>

<p>We survived! That might take a couple of read-throughs, but the basic point is that our accumulator builds up a function that does each action in reverse. Of course, <code class="language-plaintext highlighter-rouge">reduce</code> and <code class="language-plaintext highlighter-rouge">reduceRight</code> calculate the same value for <code class="language-plaintext highlighter-rouge">(x, y) =&gt; x - y</code>, so try something like <code class="language-plaintext highlighter-rouge">(x, y) =&gt; [x, y]</code> to appreciate the difference.</p>

<p>Are you convinced yet? We can carry on with more examples if you- no? Well, ok. Let&#x2019;s move onto <em>why</em> every list function is a form of <code class="language-plaintext highlighter-rouge">reduceRight</code>.</p>

<h2 id="a-strangely-familiar-list">A (<a href="/2016/10/29/peano-forte/">Strangely Familiar</a>) List</h2>

<p>A list can either be expressed as <code class="language-plaintext highlighter-rouge">[]</code> (<strong>empty</strong>) or <code class="language-plaintext highlighter-rouge">[x, ... xs]</code>, a <strong>non-empty</strong> list - an item <em>followed by another list</em>*. This is exactly a <a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>!</p>

<p>At this point, we can explain why we got <code class="language-plaintext highlighter-rouge">cons</code> and <code class="language-plaintext highlighter-rouge">head</code> for free earlier: all they do is <strong>construct</strong> and <strong>destruct</strong> lists in this form. They&#x2019;re just ways to describe the <em>structure</em> of our list.</p>

<h2 id="int-reduce-ing-our-hero">Int-<code class="language-plaintext highlighter-rouge">reduce</code>-ing Our Hero</h2>

<p>Let&#x2019;s write down two equations that define exactly how <code class="language-plaintext highlighter-rouge">reduceRight</code> works:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[].</span><span class="nx">reduceRight</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="o">=</span> <span class="nx">acc</span>

<span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span> <span class="nx">xs</span><span class="p">].</span><span class="nx">reduceRight</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="o">=</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">xs</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">acc</span><span class="p">),</span> <span class="nx">x</span><span class="p">)</span>
</code></pre></div></div>

<p>That&#x2019;s all there is to <code class="language-plaintext highlighter-rouge">reduceRight</code>. An empty list reduces to its accumulator, a non-empty list reduces to <code class="language-plaintext highlighter-rouge">f</code> of the tail&#x2019;s reduction and the head&#x2026; The code is probably clearer than that sentence.</p>

<p>Now, because <strong>reduceRight lets us set empty and non-empty behaviour</strong>, and <strong>has an accumulator</strong>, we are free to change the shape of the list <em>entirely</em>. Note that we couldn&#x2019;t write <code class="language-plaintext highlighter-rouge">length</code> in terms of <code class="language-plaintext highlighter-rouge">map</code>, because <code class="language-plaintext highlighter-rouge">map</code> doesn&#x2019;t let us change the shape (length!) of a list. Similarly, we couldn&#x2019;t write <code class="language-plaintext highlighter-rouge">length</code> in terms of <code class="language-plaintext highlighter-rouge">filter</code>, because <code class="language-plaintext highlighter-rouge">filter</code> doesn&#x2019;t have an accumulator!</p>

<p>What <code class="language-plaintext highlighter-rouge">reduceRight</code> actually is, formally, is a <strong>catamorphism</strong>: a way of folding a type (in this case, a <strong>list</strong>) up into a value.  The theory here is simple: if you have access to all possible configurations of your structure, you can do anything you like. If you don&#x2019;t, you can&#x2019;t!</p>

<h2 id="reduce-vs-reduceright"><code class="language-plaintext highlighter-rouge">reduce</code> vs <code class="language-plaintext highlighter-rouge">reduceRight</code>?</h2>

<p>Given that you can indeed express <code class="language-plaintext highlighter-rouge">reduceRight</code> in terms of <code class="language-plaintext highlighter-rouge">reduce</code>, it might seem odd to pick the less common one as a base operation. The answer lies in <a href="https://wiki.haskell.org/Foldl_as_foldr">lazy languages and infinities</a>, and there are already plenty of <a href="https://www.quora.com/Haskell-programming-language-Isnt-foldr-just-foldl-applied-on-a-reversed-list">lazy <code class="language-plaintext highlighter-rouge">reduceRight</code> explanations</a> online - you don&#x2019;t need <em>my</em> poor attempt!</p>

<h2 id="so-reduceright-can-do-anything-with-lists"><em>So&#x2026;</em> <code class="language-plaintext highlighter-rouge">reduceRight</code> <em>can do</em> anything <em>with lists?</em></h2>

<p>Yes! For some further reading, catamorphisms are also called <strong>folds</strong>, which does imply an <em>unfold</em> (an <strong>anamorphism</strong> - more wonderful names!), and <a href="http://ramdajs.com/docs/#unfold">Ramda&#x2019;s unfold function</a> can show you exactly what that does. Think about a function that produces a <em>range</em> - that&#x2019;s unfolding a starting number into a list from 0 to the number! Still, we can think of that as not being a <em>list function</em> because it&#x2019;s not a function on a list - it&#x2019;s just a function that <em>returns</em> a list**.</p>

<p><strong>tl;dr?</strong> When The Beatles said that all we need is <em>love</em>, they probably meant to say <code class="language-plaintext highlighter-rouge">reduceRight</code>.</p>

<hr>

<p>That&#x2019;s all from me! I should hopefully be more regular with my updates now I&#x2019;m settled. See you next time!</p>

<p>Take care &#x2665;</p>

<p><em>* Just as <a href="/2016/10/29/peano-forte/">Peano numbers</a> were either zero (<code class="language-plaintext highlighter-rouge">Z</code>) or one greater than some other Peano number (<code class="language-plaintext highlighter-rouge">S Peano</code>).</em></p>

<p><em>** If you&#x2019;re a wincing mathematician, I&#x2019;m sorry - this is a beginner&#x2019;s guide!</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Yippee Ki-Yay, All the Functors!</h1>
  <span class="post-date">31 Dec 2016</span>
  <p><em>More information on functors than you probably ever wanted, with all sorts of weird and wonderful examples.</em></p>

<p>Hullo! I hope you&#x2019;ve all been finding a pleasant way to see out 2016. To add just a touch more to the merriment, let&#x2019;s talk about <strong>functors</strong>!</p>

<h2 id="what-the-functor">What the Functor?</h2>

<p>Let&#x2019;s go over the <code class="language-plaintext highlighter-rouge">map</code> method for arrays, starting with a little curried function to help us out (<em>I&#x2019;ve written <a href="http://www.tomharding.me/2016/11/12/curry-on-wayward-son/">a blog post about currying</a> if you&#x2019;re unsure about it</em>):</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// map :: (a -&gt; b) -&gt; Array a -&gt; Array b</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">U</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div></div>

<p>So, we pass in a function (from some type <code class="language-plaintext highlighter-rouge">a</code> to some type <code class="language-plaintext highlighter-rouge">b</code>) and an array of type <code class="language-plaintext highlighter-rouge">a</code>, and get back an array of type <code class="language-plaintext highlighter-rouge">b</code>. Nothing scary, and we might notice:</p>

<ul>
  <li>
    <p>The identity function, <code class="language-plaintext highlighter-rouge">id = x =&gt; x</code>, has <em>no effect</em> when we <code class="language-plaintext highlighter-rouge">map</code> over an array. In other words, <code class="language-plaintext highlighter-rouge">map(id)</code> is exactly equal to <code class="language-plaintext highlighter-rouge">id</code>!</p>
  </li>
  <li>
    <p>If we define <code class="language-plaintext highlighter-rouge">compose = (f, g) =&gt; x =&gt; f(g(x))</code>, we can say that <code class="language-plaintext highlighter-rouge">compose(map(f), map(g))</code> is no different to <code class="language-plaintext highlighter-rouge">map(compose(f, g))</code>.</p>
  </li>
</ul>

<p><em><code class="language-plaintext highlighter-rouge">compose(f, g)(x)</code> basically means, &#x201C;run <code class="language-plaintext highlighter-rouge">g</code> on <code class="language-plaintext highlighter-rouge">x</code>, then run <code class="language-plaintext highlighter-rouge">f</code> on the result&#x201D;, so we can build up pipelines. Think of the shell pipe,</em> <code class="language-plaintext highlighter-rouge">|</code><em>!</em></p>

<p>In formal language, we call these properties <strong>identity</strong> and <strong>composition</strong>, respectively. Take some time to convince yourself that these laws make sense for arrays - particularly the second one:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">i</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">am</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">tom</span><span class="dl">&apos;</span><span class="p">]</span>

<span class="c1">// Try them out - both should equal [2, 4, 6]!</span>
<span class="nx">compose</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">))(</span><span class="nx">data</span><span class="p">)</span>
<span class="nx">map</span><span class="p">(</span><span class="nx">compose</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>      <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">))(</span><span class="nx">data</span><span class="p">)</span>
</code></pre></div></div>

<p><em>This actually gives us a cool property called <strong>loop fusion</strong>: any two neighbouring <code class="language-plaintext highlighter-rouge">map</code> calls can be combined into one, meaning we don&#x2019;t have to loop over the data structure twice! In plain English (sort of),</em> <code class="language-plaintext highlighter-rouge">map f THEN map g</code> <em>is the same as</em> <code class="language-plaintext highlighter-rouge">map (f THEN g)</code> <em>.</em></p>

<p>By this point, we should be confident that arrays are <strong>structures with a <code class="language-plaintext highlighter-rouge">map</code> method that respect the identity and composition properties</strong>. Well, are there any <em>other</em> structures that do this? No prizes for guessing what we call them&#x2026; Let&#x2019;s update that type signature for <code class="language-plaintext highlighter-rouge">map</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">U</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</code></pre></div></div>

<p>Instead of saying <code class="language-plaintext highlighter-rouge">Array</code> explicitly, we now just use any functor <code class="language-plaintext highlighter-rouge">f</code>. So, to prove that <code class="language-plaintext highlighter-rouge">Array</code> isn&#x2019;t the only functor, let&#x2019;s take a look at some favourites!</p>

<h2 id="identity">Identity</h2>

<p>This is probably the easiest functor of them all.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Identity</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="c1">// Transform the inner value</span>
  <span class="c1">// map :: Identity a ~&gt; (a -&gt; b) -&gt; Identity b</span>
  <span class="na">map</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span>

  <span class="c1">// Get the inner value</span>
  <span class="c1">// fold :: Identity a ~&gt; (a -&gt; b) -&gt; b</span>
  <span class="na">fold</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p><em>The value on the left of the squiggly arrow is how we&#x2019;ll refer to the object with the method we&#x2019;re using. Ignore the <code class="language-plaintext highlighter-rouge">fold</code> - it&#x2019;s just there to give us a way to get the value out!</em></p>

<p>Does this satisfy <strong>identity</strong>? Let&#x2019;s see:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Identity</span><span class="p">(</span><span class="nx">X</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>

  <span class="c1">// By definition of `map`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">id</span><span class="p">(</span><span class="nx">X</span><span class="p">))</span>

  <span class="c1">// By definition of `id`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span>
</code></pre></div></div>

<p>Yep! For any <code class="language-plaintext highlighter-rouge">X</code>, given that <code class="language-plaintext highlighter-rouge">id</code> just returns what it is given, we can see that <code class="language-plaintext highlighter-rouge">Identity</code> satisfies <strong>identity</strong>. Probably how it got its name, really. How about composition?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Identity</span><span class="p">(</span><span class="nx">X</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

  <span class="c1">// By definition of `map`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">X</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

  <span class="c1">// By definition of `map`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">X</span><span class="p">)))</span>

  <span class="c1">// By definition of `compose`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">compose</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)(</span><span class="nx">X</span><span class="p">))</span>

  <span class="c1">// By definition of `map`</span>
  <span class="o">===</span> <span class="nx">Identity</span><span class="p">(</span><span class="nx">X</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">compose</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">))</span>
</code></pre></div></div>

<p>We can see, just by swapping around sides of our definitions, that the two sides of <strong>composition</strong> are equivalent. Yay! So, we have <code class="language-plaintext highlighter-rouge">map</code>, identity, and composition, but it&#x2019;s not really&#x2026; useful, is it? Let&#x2019;s look at something with more obvious utility:</p>

<h2 id="maybe">Maybe</h2>

<p>There are two constructors for <code class="language-plaintext highlighter-rouge">Maybe</code>: <code class="language-plaintext highlighter-rouge">Just</code> and <code class="language-plaintext highlighter-rouge">Nothing</code>. If you&#x2019;re unfamiliar with type constructors: <code class="language-plaintext highlighter-rouge">Bool</code> has constructors <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code>, <code class="language-plaintext highlighter-rouge">String</code> has constructors&#x2026; well, <em>every possible string</em>! The point is that, for a given type, all its constructors have the <strong>same interface</strong>, albeit with <strong>different behaviours</strong>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Just</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="c1">// Transform the inner value</span>
  <span class="c1">// map :: Maybe a ~&gt; (a -&gt; b) -&gt; Maybe b</span>
  <span class="na">map</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span>

  <span class="c1">// Get the inner value</span>
  <span class="c1">// fold :: Maybe a ~&gt; (b, a -&gt; b) -&gt; b</span>
  <span class="na">fold</span><span class="p">:</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">Nothing</span> <span class="o">=</span> <span class="p">({</span>
  <span class="c1">// Do nothing</span>
  <span class="c1">// map :: Maybe a ~&gt; (a -&gt; b) -&gt; Maybe b</span>
  <span class="na">map</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">Nothing</span><span class="p">,</span>

  <span class="c1">// Return the default value</span>
  <span class="c1">// fold :: Maybe a ~&gt; (b, a -&gt; b) -&gt; b</span>
  <span class="na">fold</span><span class="p">:</span> <span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">d</span>
<span class="p">})</span>
</code></pre></div></div>

<p>We can see that, apart from an ignored value in <code class="language-plaintext highlighter-rouge">fold</code>, <code class="language-plaintext highlighter-rouge">Just</code> is the <code class="language-plaintext highlighter-rouge">Identity</code> functor with a different name!</p>

<p><code class="language-plaintext highlighter-rouge">Nothing</code>, however, is a bit more interesting. If we <code class="language-plaintext highlighter-rouge">map</code> over it, <strong>nothing happens</strong>. If we <code class="language-plaintext highlighter-rouge">fold</code> a <code class="language-plaintext highlighter-rouge">Nothing</code>, we get the value that <code class="language-plaintext highlighter-rouge">Just</code> ignores (<code class="language-plaintext highlighter-rouge">d</code> is short for default; can you see why?)</p>

<p><em>Why</em> would we ever want this? Well, let&#x2019;s say you have the following:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getLight</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="dl">&apos;</span><span class="s1">Red</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Amber</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Green</span><span class="dl">&apos;</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">choice</span> <span class="o">=</span> <span class="nx">getLight</span><span class="p">(</span><span class="nx">someUserInput</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">choice</span> <span class="o">==</span> <span class="kc">undefined</span>
    <span class="p">?</span> <span class="dl">&apos;</span><span class="s1">Invalid choice!</span><span class="dl">&apos;</span>
    <span class="p">:</span> <span class="dl">&apos;</span><span class="s1">The light is </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">choice</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This is a fairly simple program, but there is already some mess here. Because <code class="language-plaintext highlighter-rouge">getLight</code> might return <code class="language-plaintext highlighter-rouge">undefined</code>, we have to check for this before we do anything. That means we have to store it in some variable, and our program flow isn&#x2019;t just <strong>top-to-bottom</strong>. Can <code class="language-plaintext highlighter-rouge">Maybe</code> help us out?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A little helper method that we&apos;ll see a lot...</span>
<span class="c1">// fromNullable :: ?a -&gt; Maybe a</span>
<span class="kd">const</span> <span class="nx">fromNullable</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span>
  <span class="nx">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="p">?</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">:</span> <span class="nx">Nothing</span>

<span class="c1">// This now returns a Maybe</span>
<span class="c1">// getLight :: Int -&gt; Maybe String</span>
<span class="kd">const</span> <span class="nx">getLight</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=&gt;</span> <span class="nx">fromNullable</span><span class="p">(</span>
  <span class="p">[</span><span class="dl">&apos;</span><span class="s1">Red</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Amber</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Green</span><span class="dl">&apos;</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span>
<span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">getLight</span><span class="p">(</span><span class="nx">someUserInputFromSomewhere</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">The light is </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">fold</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Invalid choice!</span><span class="dl">&apos;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p><em>I&#x2019;ll use the ?a style to mean &#x201C;possibly null&#x201D;.</em></p>

<p>What have we gained here? Well, for a start, we&#x2019;ve used <code class="language-plaintext highlighter-rouge">map</code> to describe our algorithm step-by-step, which tidies up the logic. Secondly, we don&#x2019;t have to save the <code class="language-plaintext highlighter-rouge">getLight</code> call result because we&#x2019;re only using it once. Thirdly, and most importantly, <strong>we explicitly deal with the null</strong> - we can&#x2019;t forget about it!</p>

<p>This means that we write our program <strong>as if it works</strong>, and then deal with possible failure at the end. Our program isn&#x2019;t littered with <code class="language-plaintext highlighter-rouge">if</code> checks for <code class="language-plaintext highlighter-rouge">undefined</code>; just one branch at the <code class="language-plaintext highlighter-rouge">fold</code> step. If we want to add more logic, we simply add more <code class="language-plaintext highlighter-rouge">map</code> steps!</p>

<p>How about those <strong>laws</strong>? Well, we know <code class="language-plaintext highlighter-rouge">Just</code> satisfies them, because it&#x2019;s pretty much the same as <code class="language-plaintext highlighter-rouge">Identity</code>! But how about <code class="language-plaintext highlighter-rouge">Nothing</code>? If we <code class="language-plaintext highlighter-rouge">map</code> over <code class="language-plaintext highlighter-rouge">Nothing</code>, nothing happens. That means mapping with <code class="language-plaintext highlighter-rouge">id</code> does nothing (which means <strong>identity</strong> holds), and mapping twice over nothing still does nothing, which means <strong>composition</strong> holds!</p>

<h2 id="either">Either</h2>

<p>We&#x2019;ll fly through this one! An <code class="language-plaintext highlighter-rouge">Either</code> is a <code class="language-plaintext highlighter-rouge">Left</code> or a <code class="language-plaintext highlighter-rouge">Right</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Right</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="c1">// Transform the inner value</span>
  <span class="c1">// map :: Either a b ~&gt; (b -&gt; c) -&gt; Either a c</span>
  <span class="na">map</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span>

  <span class="c1">// Get the value with the right-hand function</span>
  <span class="c1">// fold :: Either a b ~&gt; (a -&gt; c, b -&gt; c) -&gt; c</span>
  <span class="na">fold</span><span class="p">:</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">Left</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="c1">// Do nothing</span>
  <span class="c1">// map :: Either a b ~&gt; (b -&gt; c) -&gt; Either a c</span>
  <span class="na">map</span><span class="p">:</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span>

  <span class="c1">// Get the value with the left-hand function</span>
  <span class="c1">// fold :: Either a b ~&gt; (a -&gt; c, b -&gt; c) -&gt; c</span>
  <span class="na">fold</span><span class="p">:</span> <span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">l</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Note that we talked about <code class="language-plaintext highlighter-rouge">Array a</code>, <code class="language-plaintext highlighter-rouge">Identity a</code>, and <code class="language-plaintext highlighter-rouge">Maybe a</code>, but we&#x2019;re now talking about <code class="language-plaintext highlighter-rouge">Either a b</code>. That&#x2019;s because, whereas the others could (<em>should</em>) only hold one type, Either can hold <strong>two</strong>: the <code class="language-plaintext highlighter-rouge">Left</code> and <code class="language-plaintext highlighter-rouge">Right</code> branches can have different types!</p>

<p>We can immediately see that our <code class="language-plaintext highlighter-rouge">Right</code> looks almost identical to <code class="language-plaintext highlighter-rouge">Just</code>! The <code class="language-plaintext highlighter-rouge">Left</code>, however, is slightly different to <code class="language-plaintext highlighter-rouge">Nothing</code>. Whereas <code class="language-plaintext highlighter-rouge">Nothing</code> held no value, <code class="language-plaintext highlighter-rouge">Left</code> actually holds something. Still, when we <code class="language-plaintext highlighter-rouge">map</code> over a <code class="language-plaintext highlighter-rouge">Left</code>, the value is unchanged. Let&#x2019;s modify our traffic light example to use <code class="language-plaintext highlighter-rouge">Either</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Now, we provide a &quot;default&quot; for null values</span>
<span class="c1">// fromNullable :: (a, ?b) -&gt; Either a b</span>
<span class="kd">const</span> <span class="nx">fromNullable</span> <span class="o">=</span> <span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">x</span> <span class="o">!=</span> <span class="kc">null</span> <span class="p">?</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">:</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>

<span class="c1">// getLight :: Int -&gt; Either String String</span>
<span class="kd">const</span> <span class="nx">getLight</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=&gt;</span> <span class="nx">fromNullable</span><span class="p">(</span>
  <span class="nx">i</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1"> is not a valid choice!</span><span class="dl">&apos;</span><span class="p">,</span>
  <span class="p">[</span><span class="dl">&apos;</span><span class="s1">Red</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Amber</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">Green</span><span class="dl">&apos;</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span>
<span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">getLight</span><span class="p">(</span><span class="nx">someUserInput</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">The light is </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">fold</span><span class="p">(</span>
      <span class="nx">e</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">ERROR: </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">,</span>
      <span class="nx">s</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">SUCCESS: </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">s</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>See how our <code class="language-plaintext highlighter-rouge">fold</code> step takes a function for each of the possible constructors to handle their individual values, so we can handle them separately. The <code class="language-plaintext highlighter-rouge">map</code> functions don&#x2019;t touch the <code class="language-plaintext highlighter-rouge">Left</code> value at all, though.</p>

<p>See how the signature for the <code class="language-plaintext highlighter-rouge">map</code> implementations take <code class="language-plaintext highlighter-rouge">Either a b</code> to <code class="language-plaintext highlighter-rouge">Either a c</code>? If a <code class="language-plaintext highlighter-rouge">map</code> takes <code class="language-plaintext highlighter-rouge">f b</code> to <code class="language-plaintext highlighter-rouge">f c</code>, that means our <em>functor</em> must be <code class="language-plaintext highlighter-rouge">Either a</code>!</p>

<p>If <code class="language-plaintext highlighter-rouge">Maybe</code> helps us deal with <code class="language-plaintext highlighter-rouge">null</code> safely, what does <code class="language-plaintext highlighter-rouge">Either</code> deal with? Perhaps this function will help us see:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// tryCatch :: (* -&gt; a) -&gt; Either Error a</span>
<span class="kd">const</span> <span class="nx">tryCatch</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Either</code> models <strong>type-safe exceptions</strong>! At the <code class="language-plaintext highlighter-rouge">fold</code> step, we&#x2019;re <em>forced</em> to deal with the &#x201C;exception&#x201D; by supplying a function for the <code class="language-plaintext highlighter-rouge">Left</code> value. If the original function <em>does</em> return a <code class="language-plaintext highlighter-rouge">Left</code>, that value can leap-frog over the rest of the <code class="language-plaintext highlighter-rouge">map</code> calls!</p>

<p>We&#x2019;ll see how <code class="language-plaintext highlighter-rouge">Either</code> is actually <strong>more powerful</strong> than exceptions when we come to <strong>bifunctors</strong> and other concepts. For now, though, this is a pretty neat start.</p>

<p><em>Are the laws satisfied? I&#x2019;ll leave that as an exercise!</em></p>

<h2 id="function">Function</h2>

<p>There are plenty of other examples, why don&#x2019;t we end mind-bender? <strong>Functions are functors</strong>. Let&#x2019;s look again at that type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>Now, bear with me. Our <code class="language-plaintext highlighter-rouge">Either a</code> type was a functor because we could <code class="language-plaintext highlighter-rouge">map</code> over <code class="language-plaintext highlighter-rouge">b</code> (to get <code class="language-plaintext highlighter-rouge">Either a b</code> to <code class="language-plaintext highlighter-rouge">Either a c</code>). Our functions are <code class="language-plaintext highlighter-rouge">a -&gt; b</code>; can we <code class="language-plaintext highlighter-rouge">map</code> over <code class="language-plaintext highlighter-rouge">b</code> to get <code class="language-plaintext highlighter-rouge">a -&gt; c</code>?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (a -&gt; b) ~&gt; (b -&gt; c) -&gt; a -&gt; c</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">that</span><span class="p">(</span><span class="k">this</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Yes</strong>, omgwtf, we can write a <code class="language-plaintext highlighter-rouge">map</code> implementation. Does it satisfy <strong>identity</strong>?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">f</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>

  <span class="c1">// By definition function&apos;s `map`</span>
  <span class="o">===</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">id</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

  <span class="c1">// By definition of `id`</span>
  <span class="o">===</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

  <span class="c1">// We&apos;re there!</span>
  <span class="o">===</span> <span class="nx">f</span>
</code></pre></div></div>

<p><strong>Yes</strong>. OMGwtf. What about <strong>composition</strong>? Brace yourself:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compose</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">))(</span><span class="nx">f</span><span class="p">)</span>

  <span class="c1">// By composition&apos;s definition</span>
  <span class="o">===</span> <span class="nx">map</span><span class="p">(</span><span class="nx">h</span><span class="p">)(</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">)(</span><span class="nx">f</span><span class="p">))</span>

  <span class="c1">// By map&apos;s definition</span>
  <span class="o">===</span> <span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">)(</span><span class="nx">f</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>

  <span class="c1">// ... and again...</span>
  <span class="o">===</span> <span class="nx">f</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">g</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>

  <span class="c1">// By function&apos;s map definition</span>
  <span class="o">===</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))).</span><span class="nx">map</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>

  <span class="c1">// ... and again... eep...</span>
  <span class="o">===</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">h</span><span class="p">((</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)))(</span><span class="nx">y</span><span class="p">))</span>

  <span class="c1">// Applying y to (x =&gt; g(f(x)))...</span>
  <span class="o">===</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">h</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">)))</span>

  <span class="c1">// By composition&apos;s definition...</span>
  <span class="o">===</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">g</span><span class="p">)(</span><span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>

  <span class="c1">// By function&apos;s map definition...</span>
  <span class="o">===</span> <span class="p">(</span><span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">compose</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">g</span><span class="p">))</span>

  <span class="c1">// YAY!</span>
  <span class="o">===</span> <span class="nx">f</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">compose</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">g</span><span class="p">))</span>
</code></pre></div></div>

<p>It&#x2019;s a pretty big and ugly proof, but we can indeed see that <strong>composition holds</strong>. The question remains, though: why would we <em>ever</em> want this? Well, why would we ever want <code class="language-plaintext highlighter-rouge">map</code>? To build up processing pipelines!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">toUpper</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">exclaim</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">&apos;</span><span class="s1">!</span><span class="dl">&apos;</span>
<span class="kd">const</span> <span class="nx">greet</span>   <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">Hello, </span><span class="dl">&apos;</span> <span class="o">+</span> <span class="nx">x</span>
<span class="kd">const</span> <span class="nx">log</span>     <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">)</span>

<span class="c1">// Ok, cheating a little bit...</span>
<span class="kd">const</span> <span class="nx">getUserInput</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">&apos;</span><span class="s1">Tom</span><span class="dl">&apos;</span>

<span class="kd">const</span> <span class="nx">myProgram</span> <span class="o">=</span>
  <span class="nx">getUserInput</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">greet</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">exclaim</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">toUpper</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">log</span><span class="p">)</span>

<span class="nx">myProgram</span><span class="p">()</span> <span class="c1">// logs &quot;HELLO, TOM!&quot;</span>
</code></pre></div></div>

<p>Mapping over functions lets us <strong>compose</strong> big processes from <strong>small building blocks</strong>. This gives us some wonderful opportunities for code reuse and simplified testing: many functions can be simplified to this style, and then we can reuse the code they have in common without duplication.</p>

<p><strong>Less duplication</strong> obviously means <strong>less code</strong> means <strong>less to test</strong>! Everyone wins :)</p>

<hr>

<p>Well, sorry if that&#x2019;s an awful lot to take in! In summary, functors are probably one of the most simple types of structure (we call these types <strong>typeclasses</strong>) that you&#x2019;ll see regularly in FP, but you can hopefully already see their power. Imagine what we could do with a bit more freedom? We&#x2019;ll find out when we talk about <strong>applicatives</strong>.</p>

<p>Until then, have a wonderful new year!</p>

<p>Enjoy yourself, and take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Snail Shells</h1>
  <span class="post-date">24 Dec 2016</span>
  <p>Hello, reader mine! Today, I&#x2019;m on a train back to the north to see my family for the holidays, which gives me the perfect opportunity to write about a conversation I had yesterday: <strong>why are terminals so damn unusable?</strong></p>

<p>Now, understand what I mean here. Maybe we know our <code class="language-plaintext highlighter-rouge">ls</code> from our <code class="language-plaintext highlighter-rouge">ps</code>, and we know that we can <em>usually</em> rely on <code class="language-plaintext highlighter-rouge">tar xvfz</code> (or some variation thereupon) to unzip our archives:  it&#x2019;s not <em>impossible</em> to use a terminal, but it is a lot less straightforward than it should be. In this post, I&#x2019;m going to moan about a few things, and hopefully suggest ways to improve them. So, let&#x2019;s get cracking:</p>

<h2 id="down-with-flags">Down with Flags</h2>

<p>First of all, I&#x2019;d like to have a good moan <em>about</em> <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">ps</code>, <code class="language-plaintext highlighter-rouge">tar</code>, and all these commands that we use every day. I understand that these aren&#x2019;t <em>inherently</em> part of the shell, but they certainly make up a sizeable chunk of our command-line interactions. Within these interactions, flags are, without a doubt, the worst part of it.</p>

<p>Why? Because <strong>flags fundamentally change the behaviour of the programs</strong>. If you&#x2019;re the sort of person who needs buzzwords assigned to arguments, put this under the <strong>single responsibility principle</strong>. Let&#x2019;s take a look at a pretty <em>good</em> example of a small utility program: <code class="language-plaintext highlighter-rouge">wc</code>.</p>

<p><code class="language-plaintext highlighter-rouge">wc</code> is short for <code class="language-plaintext highlighter-rouge">word count</code>. Pretty straightforward, apart from the fact that <strong>it doesn&#x2019;t count words</strong>. With no flags, it prints four values, <em>one of which</em> is the number of words in the input. To get it to do exactly the thing its name would suggest, you want <code class="language-plaintext highlighter-rouge">wc -w</code>: <em>you need a flag to get the program to do what it is intuitively supposed to do</em>. However, it doesn&#x2019;t stop there:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-c</code> will count the number of <strong>bytes</strong> (<em>not</em> characters, despite the letter used).</li>
  <li><code class="language-plaintext highlighter-rouge">-m</code> will count the number of <strong>characters</strong> (why <code class="language-plaintext highlighter-rouge">m</code>?).</li>
  <li><code class="language-plaintext highlighter-rouge">-l</code> will count the number of <strong>lines</strong>.</li>
</ul>

<p>Set aside the poor choice of letters for a moment, and look at the third flag: in almost all my uses of <code class="language-plaintext highlighter-rouge">wc</code>, I have used the <code class="language-plaintext highlighter-rouge">-l</code> flag. The incredibly common task of counting lines of input is achieved through <code class="language-plaintext highlighter-rouge">wc -l</code>, a program with a flag that entirely changes its functionality.</p>

<p>Another issue with flags is that they inevitably give rise to several ways of achieving <strong>the same thing</strong>. For example, if we actually wanted to count the number of bytes within a file, it&#x2019;s probably <em>as</em> common to use <code class="language-plaintext highlighter-rouge">ls -l</code> and parse the output with something like <code class="language-plaintext highlighter-rouge">awk</code>. Think about this: to get the size of a particular file, we can either use a program to count the words within a file, or a program to list the files within a directory. <strong>Neither of these things do what we want</strong>. This makes it really difficult for newcomers to build up an intuition about how to use the terminal: there is a <em>massive</em> amount of cognitive load involved with even the simplest actions performed within the terminal.</p>

<h3 id="alternative-separated-and-well-named-functions">Alternative: Separated and Well-Named Functions</h3>

<p>If you&#x2019;ve been writing code for some amount of time, you&#x2019;ve probably come across the issues around <a href="http://degoes.net/articles/destroy-all-ifs">overly complex <code class="language-plaintext highlighter-rouge">if</code> branching</a>: it makes our functions difficult to test, and it makes them much less intuitive. So, instead of a function with a <strong>mysterious boolean</strong> flag, we tend to write two functions with better names to describe the options separately. Let&#x2019;s apply that thinking to the terminal.</p>

<p>Instead of <code class="language-plaintext highlighter-rouge">wc -cmlw</code>, let&#x2019;s introduce four command-line utilities: <code class="language-plaintext highlighter-rouge">wordcount</code>, <code class="language-plaintext highlighter-rouge">linecount</code>, <code class="language-plaintext highlighter-rouge">charcount</code> (maybe even <code class="language-plaintext highlighter-rouge">charactercount</code>!), and <code class="language-plaintext highlighter-rouge">filesize</code>. These programs <em>exactly</em> describe their behaviour, and need no flags at all. Not only does that mean much less configuration for the user to remember, but it means that we can simplify <em>other</em> commands like <code class="language-plaintext highlighter-rouge">ls</code>: we have no need of the <em>option</em> to display file sizes if we can do it simply with our <code class="language-plaintext highlighter-rouge">filesize</code> program!</p>

<p>Of course, what we&#x2019;d quickly find is that a program with <code class="language-plaintext highlighter-rouge">n</code> mutually-exclusive flags becomes <code class="language-plaintext highlighter-rouge">2 ^ n</code> programs, which would certainly result in a <em>massive</em> number of programs to encompass the behaviours of things like <code class="language-plaintext highlighter-rouge">tar</code>, but we&#x2019;ll see later how we could actually use a special <em>type</em> of command-line utility to <em>compose</em> smaller tools to make general-purpose behaviour.</p>

<p>Anyway, for now, we can dream of a day when we can find the longest line in a file (for, say, a code linter) with&#x2026;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat myfile | maximumWith lineLength
</code></pre></div></div>

<p>&#x2026; rather than &#x2026;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat myFile |
  awk &apos;{ print length, $0 }&apos; |
  sort -nr | head -1 |
  awk &apos;{ for (i=2; i&lt;= NF; i++) print $i }&apos;
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">maximumWith</code> looks a bit odd, we&#x2019;ll talk about what it would mean in a little while. As for the comparison, I&#x2019;m obliged to say you can actually use <code class="language-plaintext highlighter-rouge">wc -L myfile</code> on certain GNU/Linux distros.</p>

<p>&#x2026; <strong>Exactly</strong>.</p>

<h2 id="pruning-branches">Pruning Branches</h2>

<p>Let&#x2019;s take a relatively simple problem: finding the average length of the lines in an input. We can write a &#x201C;relatively simple&#x201D; <code class="language-plaintext highlighter-rouge">awk</code> command to do this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awk &apos;{ len = length($0); total += len} END { print total / len }&apos;
</code></pre></div></div>

<p>This is <em>fine</em>, and it&#x2019;s efficient, and whatever, but&#x2026; it&#x2019;s relying on a command that is <strong>Turing complete</strong>. We want our pipelines to be like Lego - just a collection of little building blocks that we stick together to form the functionality we need, rather than an <em>entire</em> programming language.</p>

<p>Fact is, we usually find our one-liner gets to a point of complexity (pretty quickly) that becomes more effort than just writing a script in something like Python or Perl. In which case, what does <code class="language-plaintext highlighter-rouge">awk</code> - <em>another scripting language</em> - really give us except a slightly more obfuscated Perl? (Ok, that might be a bit too harsh&#x2026;)</p>

<h3 id="alternative-higher-order-commands">Alternative: Higher-Order commands</h3>

<p>Wouldn&#x2019;t we rather write things like this?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>combineWith divide [ linelength | sumtotal ] [ linecount ]
</code></pre></div></div>

<p>This would introduce a couple of unseen features to the terminal: firstly, the <code class="language-plaintext highlighter-rouge">*With</code> functions. We have <code class="language-plaintext highlighter-rouge">combineWith</code> and <code class="language-plaintext highlighter-rouge">forEach</code>, and we had <code class="language-plaintext highlighter-rouge">maximumWith</code> earlier on. These are what we may already know as <strong>higher-order</strong> commands: commands that take other commands as parameters.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">combineWith</code> takes <strong>three</strong> commands, <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">g</code>, and <code class="language-plaintext highlighter-rouge">h</code>, applies <code class="language-plaintext highlighter-rouge">g</code> and <code class="language-plaintext highlighter-rouge">h</code> (independently) to the input, then passes those two results to <code class="language-plaintext highlighter-rouge">f</code>. In this instance, we simultaneously <code class="language-plaintext highlighter-rouge">sum</code> the <code class="language-plaintext highlighter-rouge">lineLength</code> of each line <strong>and</strong> <code class="language-plaintext highlighter-rouge">linecount</code> the input, then <code class="language-plaintext highlighter-rouge">divide</code> the sum by the count to get the average!</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">maximumWith</code> takes a command, <code class="language-plaintext highlighter-rouge">f</code>, and then returns the line that is <code class="language-plaintext highlighter-rouge">greatest</code> when passed as the argument to <code class="language-plaintext highlighter-rouge">f</code>. In our earlier example, that meant returning the line that had the &#x201C;greatest&#x201D; <code class="language-plaintext highlighter-rouge">lineLength</code>.</p>
  </li>
</ul>

<p>We call these <strong>higher-order commands</strong> because they&#x2019;re pretty much a direct port from <strong>higher-order functions</strong> in programming: commands that accept commands as input. This adds a whole new level to command composition!</p>

<p>With this, we <strong>remove</strong> the need for probably-Turing-complete commands like <code class="language-plaintext highlighter-rouge">awk</code> and <code class="language-plaintext highlighter-rouge">sed</code>, because we have enough expression within our higher-order commands to group together much simpler tasks like <code class="language-plaintext highlighter-rouge">replace</code>, <code class="language-plaintext highlighter-rouge">sort</code>, and <code class="language-plaintext highlighter-rouge">substr</code>. We also remove the need for a <em>lot</em> of the flags within our most common utility programs, because flags tend to allow us access to all kinds of data is so that we can <strong>&#x201C;jump&#x201D; values over</strong> certain steps in the pipeline.</p>

<p>If you don&#x2019;t believe me, write a program to print a list of files and their sizes <em>without</em> using <code class="language-plaintext highlighter-rouge">ls</code> - in fact, say you can <em>only</em> use <code class="language-plaintext highlighter-rouge">wc -c</code>. The problem is that <code class="language-plaintext highlighter-rouge">wc</code> doesn&#x2019;t output the file name, and you then need it to print alongside the filesize.</p>

<p>So, we currently use <code class="language-plaintext highlighter-rouge">ls -l</code> and pull the relevant data from the table. If we had these higher-order commands, there would be no need for most of the functionality within <code class="language-plaintext highlighter-rouge">ls</code>, as it could be brought in from other functions (e.g. <code class="language-plaintext highlighter-rouge">ls | combineWith echo [ cat ] [wc -c ]</code>).</p>

<p>I&#x2019;ve introduced some new syntax, but it should be fairly straightforward: <em>to any shell purists, pls no h8</em>.</p>

<p><strong>Higher-order command composition reduces complexity</strong>. This is how we get around the <code class="language-plaintext highlighter-rouge">2 ^ n</code> command problem: most of a program&#x2019;s flags are to retain information that would be lost in the pipeline. If we can create these parallel branches, we remove the <em>need</em> for this retention. If you don&#x2019;t like the idea of a program called <code class="language-plaintext highlighter-rouge">combineWith</code>, might I suggest syntactical operators? I&#x2019;m partial to <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>, myself. <em>*cough*</em></p>

<h2 id="it-takes-21-to-tango">It Takes <code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code> to Tango</h2>

<p>Streams are <em>really</em> cool. The first time you use <code class="language-plaintext highlighter-rouge">stderr</code>/<code class="language-plaintext highlighter-rouge">stdout</code> independently, it feels a little magical. Of course, this is also one of the few places where you can <em>actually</em> do branching well (although convergence is not so simple&#x2026;)</p>

<p>In what is probably the most controversial proposal of this post, I would like to suggest something radical: <strong>unlimited streams</strong>. Right now, we have two for writing and one for reading; why couldn&#x2019;t we add more?</p>

<p>Sometimes, I have two types of output, neither of which are errors. To give a recent example, perhaps I have a command to check that a list of <strong>calendar dates</strong> for those over two weeks old. I might want to output those that <em>are</em> to one stream, those that <em>aren&#x2019;t</em> to another, and formatting errors to <code class="language-plaintext highlighter-rouge">stderr</code>. Right now, I&#x2019;m rather stuck&#x2026; I&#x2019;ll probably end up writing a little script that does the split and the subsequent logic <em>for</em> me, but that&#x2019;s inelegant, and another loss for the shell. Couldn&#x2019;t we do better?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat dates | splitDates 2&gt; ./errors 3&gt; ./wins 4&gt; ./losses
</code></pre></div></div>

<p>There are many use cases for this: we could establish <strong>multiple error streams</strong> to handle different levels of error (from <code class="language-plaintext highlighter-rouge">debug</code> to <code class="language-plaintext highlighter-rouge">fatal</code>), <strong>multiple input streams</strong> to handle different sources (we could <code class="language-plaintext highlighter-rouge">diff</code> two streams!), and all sorts of other goodies.</p>

<p>The point is that, when we need to do something more complicated than the three-stream system allows, we reach for a scripting language. This is a feature that our shell could support (albeit with <em>massive</em> historical upset, of course&#x2026;)</p>

<h2 id="closing">Closing</h2>

<p>I can never remember whether I want <code class="language-plaintext highlighter-rouge">df</code>, <code class="language-plaintext highlighter-rouge">du</code>, or <code class="language-plaintext highlighter-rouge">dd</code>. When do I <code class="language-plaintext highlighter-rouge">dd</code> <em>vs</em> <code class="language-plaintext highlighter-rouge">scp</code> <em>vs</em> <code class="language-plaintext highlighter-rouge">rsync</code> <em>vs</em> <code class="language-plaintext highlighter-rouge">cp</code>? What&#x2019;s that <code class="language-plaintext highlighter-rouge">rsync</code> flag that prints the shiny progress bar? There are a lot of barriers to entry for the terminal that accompany its legacy.</p>

<p>Let&#x2019;s not worsen the situation with cryptic flags, mysterious syntaxes, and outdated restrictions. Why should we <em>emulate</em> a terminal when we could produce something so much easier to use, while simultaneously much more capable? These features would bring a much-needed <strong>usability boost</strong> to the terminal, and maybe save a dev or two from an afternoon of <strong>hacking in Perl</strong>.</p>

<p>For me, that would be its own reward.</p>

<hr>

<p>Thanks for reading! Feel absolutely free to comment, tweet, or <em>whatever</em> me if you disagree with anything - or, even better, if you actually know how to accomplish these things currently! - and we&#x2019;ll talk it out. I&#x2019;d love to hear your opinions.</p>

<p><em>With that, I should probably apologise to <a href="https://twitter.com/justnine">m&#x2019;colleague</a> who probably wasn&#x2019;t expecting Perl-bashing when he agreed to read this. (Sorry!)</em></p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">The Orrery</h1>
  <span class="post-date">11 Dec 2016</span>
  <p>Hello! Sorry for taking so long to write another post. I&#x2019;ve been really quite busy looking for a new place to live and a new office to work in, you see. Anyway, instead of adding <em>another</em> post in my introductory theme, I thought I&#x2019;d show you how this <strong>Orrery</strong> works! It&#x2019;s written in Elm, which isn&#x2019;t supported by GitHub&#x2019;s highlighter <em>yet</em>, so I&#x2019;ve modified it a little (<em>my excuse for why the code blocks look a bit naff</em>).</p>

<div id="orrery"></div>
<script>
  Elm.Main.embed(
    document
      .getElementById(
        'orrery'
      )
  )
</script>

<p>Anyway, I hope it&#x2019;s useful to someone - we&#x2019;ll talk about Elm&#x2019;s successes and my failings, and everything should hopefully be clear enough. If anything doesn&#x2019;t make sense, though, feel free to <a href="http://www.twitter.com/am_i_tom">send me a Tweet</a> and I&#x2019;ll do my best to clarify!</p>

<h2 id="preamble">Preamble</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Main</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">AnimationFrame</span>
<span class="kr">import</span> <span class="nn">Html</span>
<span class="kr">import</span> <span class="nn">Http</span>
<span class="kr">import</span> <span class="nn">Json.Decode</span> <span class="k">as</span> <span class="n">Decode</span>
<span class="kr">import</span> <span class="nn">Svg</span>
<span class="kr">import</span> <span class="nn">Svg.Attributes</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Time</span> <span class="n">exposing</span> <span class="p">(</span><span class="n">inMinutes</span><span class="p">,</span> <span class="kt">Time</span><span class="p">)</span>
</code></pre></div></div>

<p>This project uses a few dependencies. To anyone who&#x2019;s written any amount of Elm before, the only stranger is <code class="language-plaintext highlighter-rouge">AnimationFrame</code>, from the <code class="language-plaintext highlighter-rouge">elm-lang/animation-frame</code> package. This lets us subscribe to the browser&#x2019;s RAF API. Everything else should be fairly obvious: <code class="language-plaintext highlighter-rouge">Html</code> / <code class="language-plaintext highlighter-rouge">Svg</code> for our view, <code class="language-plaintext highlighter-rouge">Http</code> / <code class="language-plaintext highlighter-rouge">Json.Decode</code> for the AJAX request, and <code class="language-plaintext highlighter-rouge">Time</code> for our orbit.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span>
    <span class="kt">Html</span><span class="o">.</span><span class="n">program</span>
        <span class="p">{</span> <span class="n">init</span>          <span class="o">=</span> <span class="n">init</span>
        <span class="p">,</span> <span class="n">subscriptions</span> <span class="o">=</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">AnimationFrame</span><span class="o">.</span><span class="n">times</span> <span class="kt">Tick</span>
        <span class="p">,</span> <span class="n">update</span>        <span class="o">=</span> <span class="n">update</span>
        <span class="p">,</span> <span class="n">view</span>          <span class="o">=</span> <span class="n">view</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>We can&#x2019;t use the <code class="language-plaintext highlighter-rouge">beginnerProgram</code> because of the need for both subscriptions <em>and</em> commands, so we opt for the next easiest thing. <em>Perhaps</em> against convention, I tend to put one-line declarations (e.g. <code class="language-plaintext highlighter-rouge">subscriptions</code>) directly in the <code class="language-plaintext highlighter-rouge">Html.program</code> call - it looks prettier to me&#x2026; <em>Sorry, Evan!</em></p>

<h2 id="the-model">The Model</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="n">alias</span> <span class="kt">System</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">colour</span> <span class="o">:</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">orbit</span>  <span class="o">:</span> <span class="kt">Float</span>
    <span class="p">,</span> <span class="n">radius</span> <span class="o">:</span> <span class="kt">Float</span>
    <span class="p">,</span> <span class="n">speed</span>  <span class="o">:</span> <span class="kt">Float</span>
    <span class="p">,</span> <span class="n">moons</span>  <span class="o">:</span> <span class="kt">Moons</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>The model for this visualisation is <strong>recursive</strong>: a system is a body and its <em>moons</em>, all of which are systems themselves. However, this means we have an <strong>infinitely-nesting</strong> type, so we have to use sidestep this with a new <code class="language-plaintext highlighter-rouge">type Moons</code> to get a solid alias.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Moons</span>
    <span class="o">=</span> <span class="kt">Moons</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">System</span><span class="p">)</span>
</code></pre></div></div>

<p>Of course, aside from a little extra destructuring, this doesn&#x2019;t change the capability of the type <em>at all</em>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">time</span>   <span class="o">:</span> <span class="kt">Time</span>
    <span class="p">,</span> <span class="n">system</span> <span class="o">:</span> <span class="kt">Maybe</span> <span class="kt">System</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>The model is then just the current <code class="language-plaintext highlighter-rouge">Time</code> (from our subscription) and <em>maybe</em> a <code class="language-plaintext highlighter-rouge">System</code>. If the AJAX response hasn&#x2019;t come back yet, or an error occurred during the lifecycle, our <code class="language-plaintext highlighter-rouge">System</code> is <code class="language-plaintext highlighter-rouge">Nothing</code>, and we can show something other than an empty sky.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">init</span> <span class="o">=</span>
    <span class="p">(</span> <span class="p">{</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">system</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="p">}</span>
    <span class="p">,</span> <span class="kt">Http</span><span class="o">.</span><span class="n">send</span> <span class="kt">Register</span>
        <span class="o">&lt;&lt;</span> <span class="kt">Http</span><span class="o">.</span><span class="n">get</span> <span class="s">&quot;./test.json&quot;</span>
        <span class="o">&lt;|</span> <span class="n">planetify</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>The initial command is the AJAX request: when this completes, the model will hold the returned JSON <strong>or lack thereof</strong>. I think this whole <code class="language-plaintext highlighter-rouge">Cmd</code> approach is really neat: our IO actions end up handled in <em>exactly</em> the same way as our user interactions.</p>

<h2 id="json">JSON</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">planetify</span> <span class="o">:</span> <span class="kt">Decode</span><span class="o">.</span><span class="kt">Decoder</span> <span class="kt">System</span>
<span class="n">planetify</span> <span class="o">=</span>
    <span class="kt">Decode</span><span class="o">.</span><span class="n">map5</span> <span class="kt">System</span>
        <span class="p">(</span><span class="kt">Decode</span><span class="o">.</span><span class="n">field</span> <span class="s">&quot;colour&quot;</span> <span class="kt">Decode</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Decode</span><span class="o">.</span><span class="n">field</span> <span class="s">&quot;orbit&quot;</span>  <span class="kt">Decode</span><span class="o">.</span><span class="n">float</span> <span class="p">)</span>
        <span class="p">(</span><span class="kt">Decode</span><span class="o">.</span><span class="n">field</span> <span class="s">&quot;radius&quot;</span> <span class="kt">Decode</span><span class="o">.</span><span class="n">float</span> <span class="p">)</span>
        <span class="p">(</span><span class="kt">Decode</span><span class="o">.</span><span class="n">field</span> <span class="s">&quot;speed&quot;</span>  <span class="kt">Decode</span><span class="o">.</span><span class="n">float</span> <span class="p">)</span>
        <span class="p">(</span><span class="kt">Decode</span><span class="o">.</span><span class="n">field</span> <span class="s">&quot;moons&quot;</span> <span class="o">&lt;&lt;</span> <span class="kt">Decode</span><span class="o">.</span><span class="n">map</span> <span class="kt">Moons</span>
                              <span class="o">&lt;&lt;</span> <span class="kt">Decode</span><span class="o">.</span><span class="n">lazy</span>
                              <span class="o">&lt;|</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Decode</span><span class="o">.</span><span class="n">list</span> <span class="n">planetify</span><span class="p">)</span>
</code></pre></div></div>

<p>When we get the AJAX response, we need to map it into a <strong>data type</strong>: in our case, the <code class="language-plaintext highlighter-rouge">System</code> type. In Elm, we do this with a <code class="language-plaintext highlighter-rouge">Json.Decoder</code>. Here, we use a decoder that can recursively deconstruct the JSON to match our type. It also validates our JSON response at the same time!</p>

<p>We need to use the <code class="language-plaintext highlighter-rouge">Decode.map</code> and <code class="language-plaintext highlighter-rouge">Decode.lazy</code> functions to avoid that pesky infinite type: the <code class="language-plaintext highlighter-rouge">Moons</code> type will be populated by a second map that occurs <em>lazily</em>.</p>

<h2 id="update">Update</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Msg</span>
    <span class="o">=</span> <span class="kt">Tick</span> <span class="kt">Time</span>
    <span class="o">|</span> <span class="kt">Register</span> <span class="p">(</span><span class="kt">Result</span> <span class="kt">Http</span><span class="o">.</span><span class="kt">Error</span> <span class="kt">System</span><span class="p">)</span>
</code></pre></div></div>

<p>There are really only two things that happen in this visualisation: the <code class="language-plaintext highlighter-rouge">Time</code> updates (for the next animation frame), and the AJAX response <em>correctly or otherwise</em>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">Tick</span> <span class="n">time</span> <span class="o">-&gt;</span>
            <span class="p">(</span> <span class="p">{</span> <span class="n">model</span> <span class="o">|</span> <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="p">},</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span> <span class="p">)</span>

        <span class="kt">Register</span> <span class="n">result</span> <span class="o">-&gt;</span>
            <span class="p">(</span> <span class="p">{</span> <span class="n">model</span> <span class="o">|</span> <span class="n">system</span> <span class="o">=</span> <span class="kt">Result</span><span class="o">.</span><span class="n">toMaybe</span> <span class="n">result</span> <span class="p">}</span>
            <span class="p">,</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span>
            <span class="p">)</span>
</code></pre></div></div>

<p>Consequently, the handlers for these two cases are <em>very</em> simple. Any <code class="language-plaintext highlighter-rouge">Time</code> update simply updates the model, and any server <code class="language-plaintext highlighter-rouge">Result</code> is recorded. As mentioned before, I have converted the <code class="language-plaintext highlighter-rouge">Result</code> to <code class="language-plaintext highlighter-rouge">Maybe</code> so I can encode <em>the response has not yet been received</em> in the same way as <em>the request failed</em> and <em>the response is invalid</em>. Don&#x2019;t be fooled: this is pure laziness on my part.</p>

<h2 id="view-ordering">View Ordering</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Coordinate</span> <span class="o">=</span>
    <span class="p">(</span> <span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span> <span class="p">)</span>
</code></pre></div></div>

<p>A coordinate is represented as <code class="language-plaintext highlighter-rouge">( x, y )</code>. If I weren&#x2019;t going for brevity, some operations would be helpful (e.g. <code class="language-plaintext highlighter-rouge">add</code>).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Renderable</span>
    <span class="o">=</span> <span class="kt">Orbit</span>
        <span class="p">{</span> <span class="n">x</span>      <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">,</span> <span class="n">y</span>      <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">,</span> <span class="n">radius</span> <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">}</span>

    <span class="o">|</span> <span class="kt">Planet</span>
        <span class="p">{</span> <span class="n">x</span>      <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">,</span> <span class="n">y</span>      <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">,</span> <span class="n">radius</span> <span class="o">:</span> <span class="kt">Float</span>
        <span class="p">,</span> <span class="n">colour</span> <span class="o">:</span> <span class="kt">String</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>In the first iteration of this code, there was no ordering on the <code class="language-plaintext highlighter-rouge">Svg</code> elements. This looked odd when satellites didn&#x2019;t go <em>behind</em> a parent body (e.g. when the moon&#x2019;s orbit is at the &#x201C;back&#x201D; of the diagram), so I picked a configuration where this didn&#x2019;t happen. A few weeks later, however, I felt ashamed of myself, and fixed it.</p>

<p>So, now, we generate inspectable (thus easily orderable) records, and convert them to <code class="language-plaintext highlighter-rouge">SVG</code> later on. I think this turns out quite neatly, though it&#x2019;s perhaps the result of staring for too long at <code class="language-plaintext highlighter-rouge">Free</code> structures and interpreters.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ordering</span> <span class="o">:</span> <span class="kt">Renderable</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">ordering</span> <span class="n">object</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">object</span> <span class="kr">of</span>
        <span class="kt">Planet</span> <span class="p">{</span> <span class="n">y</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">y</span>
        <span class="kr">_</span>            <span class="o">-&gt;</span> <span class="n">negate</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>
</code></pre></div></div>

<p>For now, we just put <code class="language-plaintext highlighter-rouge">Orbit</code> rings right at the back. This looks a bit odd at times, and I think a better solution would be to split up the <code class="language-plaintext highlighter-rouge">ellipse</code> into several arcs, (to order around other <code class="language-plaintext highlighter-rouge">Svg</code>s), but that&#x2019;s one for another time.</p>

<hr>

<p>Converting a <code class="language-plaintext highlighter-rouge">Renderable</code> to an <code class="language-plaintext highlighter-rouge">Svg</code> is very straightforward, as all the required information is stored within the <code class="language-plaintext highlighter-rouge">Renderable</code> type already. An easy modification to this app would be to allow user-defined <em>camera tilt</em> (i.e. configurable <code class="language-plaintext highlighter-rouge">skew</code>), and it could simply be passed in as a parameter here.</p>

<p>It&#x2019;s perhaps worth pointing out that my <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> and <code class="language-plaintext highlighter-rouge">&lt;|</code> usage is a direct mapping from Haskell&#x2019;s <code class="language-plaintext highlighter-rouge">.</code> and <code class="language-plaintext highlighter-rouge">$</code>. The <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> could quite easily be replaced with another <code class="language-plaintext highlighter-rouge">&lt;|</code> of course, but it&#x2019;s just not the way I&#x2019;m used to doing things! <em>Old dogs, new tricks&#x2026;</em></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">renderables</span> <span class="o">:</span> <span class="kt">Coordinate</span> <span class="o">-&gt;</span> <span class="kt">Time</span> <span class="o">-&gt;</span> <span class="kt">System</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="kt">Renderable</span>
<span class="n">renderables</span> <span class="p">(</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="p">)</span> <span class="n">time</span> <span class="p">{</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">moons</span> <span class="p">}</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="p">(</span> <span class="n">cx_</span><span class="p">,</span> <span class="n">cy_</span> <span class="p">)</span> <span class="o">=</span>
            <span class="n">fromPolar</span> <span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">speed</span> <span class="o">*</span> <span class="n">inMinutes</span> <span class="n">time</span><span class="p">)</span>
                <span class="o">|&gt;</span> <span class="nf">\</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="n">cx</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">y</span> <span class="p">)</span>

        <span class="n">ring</span> <span class="o">=</span>
            <span class="kt">Orbit</span> <span class="p">{</span> <span class="n">x</span>      <span class="o">=</span> <span class="n">cx</span>
                  <span class="p">,</span> <span class="n">y</span>      <span class="o">=</span> <span class="n">cy</span>
                  <span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">orbit</span>
                  <span class="p">}</span>

        <span class="n">planet</span> <span class="o">=</span>
            <span class="kt">Planet</span> <span class="p">{</span> <span class="n">x</span>      <span class="o">=</span> <span class="n">cx_</span>
                   <span class="p">,</span> <span class="n">y</span>      <span class="o">=</span> <span class="n">cy_</span>
                   <span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
                   <span class="p">,</span> <span class="n">colour</span> <span class="o">=</span> <span class="n">colour</span>
                   <span class="p">}</span>

        <span class="n">subrenderer</span> <span class="o">=</span>
            <span class="n">renderables</span> <span class="p">(</span> <span class="n">cx_</span><span class="p">,</span> <span class="n">cy_</span> <span class="p">)</span> <span class="n">time</span>

        <span class="n">children</span> <span class="o">=</span>
            <span class="kr">case</span> <span class="n">moons</span> <span class="kr">of</span>
                <span class="kt">Moons</span> <span class="n">ms</span> <span class="o">-&gt;</span>
                    <span class="kt">List</span><span class="o">.</span><span class="n">concatMap</span> <span class="n">subrenderer</span> <span class="n">ms</span>
    <span class="kr">in</span>
        <span class="n">ring</span> <span class="o">::</span> <span class="n">planet</span> <span class="o">::</span> <span class="n">children</span>
</code></pre></div></div>

<h2 id="view-construction">View Construction</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toSvg</span> <span class="o">:</span> <span class="kt">Renderable</span> <span class="o">-&gt;</span> <span class="kt">Svg</span><span class="o">.</span><span class="kt">Svg</span> <span class="kt">Msg</span>
<span class="n">toSvg</span> <span class="n">renderable</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">renderable</span> <span class="kr">of</span>
        <span class="kt">Orbit</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">radius</span> <span class="p">}</span> <span class="o">-&gt;</span>
            <span class="kt">Svg</span><span class="o">.</span><span class="n">ellipse</span> <span class="p">[</span> <span class="n">cx</span> <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">x</span>
                        <span class="p">,</span> <span class="n">cy</span> <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">y</span>
                        <span class="p">,</span> <span class="n">rx</span> <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">radius</span>
                        <span class="p">,</span> <span class="n">ry</span> <span class="o">&lt;&lt;</span> <span class="n">toString</span> <span class="o">&lt;|</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">radius</span>
                        <span class="p">]</span> <span class="kt">[]</span>

        <span class="kt">Planet</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">colour</span> <span class="p">}</span> <span class="o">-&gt;</span>
            <span class="kt">Svg</span><span class="o">.</span><span class="n">circle</span> <span class="p">[</span> <span class="n">cx</span>    <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">x</span>
                       <span class="p">,</span> <span class="n">cy</span>    <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">y</span>
                       <span class="p">,</span> <span class="n">r</span>     <span class="o">&lt;|</span> <span class="n">toString</span> <span class="n">radius</span>
                       <span class="p">,</span> <span class="n">style</span> <span class="o">&lt;|</span> <span class="s">&quot;fill:&quot;</span> <span class="o">++</span> <span class="n">colour</span>
                       <span class="p">]</span> <span class="kt">[]</span>
</code></pre></div></div>

<p>See where those <code class="language-plaintext highlighter-rouge">Coordinate</code> functions would be useful?</p>

<p>I&#x2019;ll say now that <strong>I don&#x2019;t like this function</strong>: there&#x2019;s a pretty obvious optimisation to be made here. What I would <em>really</em> like is a type of <code class="language-plaintext highlighter-rouge">Coordinate -&gt; System -&gt; List (Time -&gt; Renderable)</code>, or even a result like <code class="language-plaintext highlighter-rouge">Time -&gt; List Renderable</code>: in other words, we&#x2019;d end up with a list of bodies positioned with respect to each <em>recursive</em> orbit via <em>composed</em> functions.</p>

<p>I haven&#x2019;t looked enough into Elm&#x2019;s compiler to know for certain, but I would imagine that this could be compiled efficiently if we ended up with <code class="language-plaintext highlighter-rouge">let .. in \time -&gt;</code> as our general form. As <code class="language-plaintext highlighter-rouge">time</code> is the only important variable here, we could pre-build all this at the time of JSON receipt, and cut down on the calculations needed at run-time. It&#x2019;s just a thought, really.</p>

<p>For small-ish <code class="language-plaintext highlighter-rouge">System</code> cases, this works fine, but I&#x2019;m not really a huge fan of the <em>good enough</em> mentality, and I&#x2019;m <strong>certain</strong> this function has room for improvement. It certainly shouldn&#x2019;t need to know the <code class="language-plaintext highlighter-rouge">skew</code> value to build view-independent coordinates.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span><span class="o">.</span><span class="kt">Html</span> <span class="kt">Msg</span>
<span class="n">view</span> <span class="p">{</span> <span class="n">time</span><span class="p">,</span> <span class="n">system</span> <span class="p">}</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="n">container</span> <span class="o">=</span>
            <span class="kt">Svg</span><span class="o">.</span><span class="n">svg</span> <span class="p">[</span> <span class="n">viewBox</span> <span class="s">&quot;0 0 600 240&quot;</span>
                    <span class="p">,</span> <span class="n">width</span> <span class="s">&quot;600px&quot;</span>
                    <span class="p">]</span>
    <span class="kr">in</span>
        <span class="kr">case</span> <span class="n">system</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="o">-&gt;</span>
                <span class="kt">Html</span><span class="o">.</span><span class="n">div</span> <span class="kt">[]</span> <span class="p">[</span> <span class="kt">Html</span><span class="o">.</span><span class="n">text</span> <span class="s">&quot;What a quiet night...&quot;</span> <span class="p">]</span>

            <span class="kt">Just</span> <span class="kr">data</span> <span class="o">-&gt;</span>
                <span class="n">container</span> <span class="o">&lt;&lt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="n">toSvg</span>
                          <span class="o">&lt;&lt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">sortBy</span> <span class="n">ordering</span>
                          <span class="o">&lt;&lt;</span> <span class="n">renderables</span> <span class="p">(</span> <span class="mf">300.0</span><span class="p">,</span> <span class="mf">120.0</span> <span class="p">)</span> <span class="n">time</span>
                          <span class="o">&lt;|</span> <span class="kr">data</span>
</code></pre></div></div>

<p>Finally, we have the <strong>view</strong> function: the entry point for all the rendering process. This is nice and easy to understand, I hope: we can display some cursory error to the user for when AJAX fails, and otherwise kick off the animation.</p>

<p>Of course, I&#x2019;d love to get <code class="language-plaintext highlighter-rouge">skew</code> into the <code class="language-plaintext highlighter-rouge">Model</code> so that it can be configured (and then passed to the rest of the view logic at render-time). Ooer.</p>

<p>That gets us to the end of the file! <strong>All</strong> the code for the top visualisation (that isn&#x2019;t just imported library code) is here: it really is that simple. If you want to see it more clearly, there is <a href="https://gist.github.com/i-am-tom/229afcf287bf870ac76b5a909cdcfb81">a Gist of all the code</a> to be found here.</p>

<p><em>Elm is wonderful. Try it.</em></p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Curry On Wayward Son</h1>
  <span class="post-date">12 Nov 2016</span>
  <p>Currying is <strong>so hot</strong> right now in the functional-ish JavaScript community. If you&#x2019;ve used libraries like <a href="http://ramdajs.com/">Ramda</a>, chances are you&#x2019;ve had some exposure. Either way, let&#x2019;s spell it out to be safe:</p>

<p>Functions in languages like <a href="https://www.haskell.org/">Haskell</a> or <a href="http://elm-lang.org/">Elm</a> <strong>take one input and return one output</strong>, whether you like it or not. If we want two arguments, we write a function that <em>returns</em> a function (because functions are also values!) and nest them:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="c1">// a la ES6</span>
</code></pre></div></div>

<p>So, to add <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code>, we write <code class="language-plaintext highlighter-rouge">add(2)(3)</code>. <em>Currying</em> a function means converting it from the usual style (<code class="language-plaintext highlighter-rouge">(x, y) =&gt; x + y</code>) to this style. With that said, we&#x2019;ll see later that most of our favourite implementations of <code class="language-plaintext highlighter-rouge">curry</code> functions are more like <code class="language-plaintext highlighter-rouge">curryish</code>&#x2026;</p>

<h2 id="is-there-a-point-to-this">Is there a point to this?</h2>

<p>Yes! Obviously, writing <code class="language-plaintext highlighter-rouge">add(2)(3)</code> is ugly - and we&#x2019;ll fix that later - but the power of this comes from the instances where you <em>don&#x2019;t</em> supply all the arguments up front.</p>

<p>Think about it: <code class="language-plaintext highlighter-rouge">add(2)</code> returns a function that takes a value and adds <code class="language-plaintext highlighter-rouge">2</code> to it. Why do we have to give it that second number immediately? We could do all sorts of things:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1, 2, 3, 4, 5 - Oooooo</span>
<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>When we play with functions that don&#x2019;t have all their arguments yet, we call it <strong>partial application</strong>. In practice, what we&#x2019;re doing is taking a very general function (<code class="language-plaintext highlighter-rouge">add</code>) and <em>specialising</em> it with some of its arguments.</p>

<p>Here&#x2019;s a slightly more useful (although still majorly contrived) example of how we can wrap <code class="language-plaintext highlighter-rouge">String.replace</code> to be more flexible:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">replace</span> <span class="o">=</span> <span class="k">from</span> <span class="o">=&gt;</span> <span class="nx">to</span> <span class="o">=&gt;</span> <span class="nx">str</span> <span class="o">=&gt;</span>
        <span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">withName</span>  <span class="o">=</span> <span class="nx">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\{</span><span class="sr">NAME</span><span class="se">\}</span><span class="sr">/</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">withTom</span>   <span class="o">=</span> <span class="nx">withName</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Tom</span><span class="dl">&apos;</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">withTrump</span> <span class="o">=</span> <span class="nx">withName</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">tiny hands</span><span class="dl">&apos;</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">stripVowels</span> <span class="o">=</span> <span class="nx">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">aeiou</span><span class="se">]</span><span class="sr">/g</span><span class="p">)(</span><span class="dl">&apos;&apos;</span><span class="p">)</span>

<span class="nx">withTom</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello, {NAME}!</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// Hello, Tom!</span>
<span class="nx">withTrump</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">Hello, {NAME}!</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// Hello, tiny hands!</span>

<span class="nx">stripVowels</span><span class="p">(</span><span class="dl">&apos;</span><span class="s1">hello</span><span class="dl">&apos;</span><span class="p">)</span> <span class="c1">// hll</span>

<span class="c1">// [&apos;hll&apos;, &apos;wmbldn&apos;]</span>
<span class="p">[</span><span class="dl">&apos;</span><span class="s1">hello</span><span class="dl">&apos;</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">wimbledon</span><span class="dl">&apos;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">stripVowels</span><span class="p">)</span>
</code></pre></div></div>

<p>I don&#x2019;t know about you, but I think this is <em>really</em> exciting: we&#x2019;ve taken a single function and used partial application to specialise it in several exciting ways. Instead of writing a whole new replace for each function, we just partially apply some number of its arguments! <strong>So</strong> hot right now.</p>

<p>This is the inherent power of partial application: we can write very general functions, and specialise them for different purposes. This massively reduces boilerplate code, and looks super pretty.</p>

<h2 id="but-its-hideous">But it&#x2019;s <em>hideous</em></h2>

<p>Yeah, it&#x2019;s kinda ugly when you see a call like <code class="language-plaintext highlighter-rouge">replace(/a/)(&apos;e&apos;)(str)</code> (all those brackets touching!) rather than <code class="language-plaintext highlighter-rouge">replace(/a/, &apos;e&apos;, str)</code>, <em>but</em> we don&#x2019;t want to be forced to supply all the arguments at once.</p>

<p>What we&#x2019;d <em>really</em> like is to be able to write these arguments in any flexible grouping we need:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">replace</span><span class="p">(</span><span class="sr">/a/</span><span class="p">)(</span><span class="dl">&apos;</span><span class="s1">e</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">str</span><span class="p">)</span>
  <span class="o">==</span> <span class="nx">replace</span><span class="p">(</span><span class="sr">/a/</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">e</span><span class="dl">&apos;</span><span class="p">)(</span><span class="nx">str</span><span class="p">)</span>
  <span class="o">==</span> <span class="nx">replace</span><span class="p">(</span><span class="sr">/a/</span><span class="p">)(</span><span class="dl">&apos;</span><span class="s1">e</span><span class="dl">&apos;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
  <span class="o">==</span> <span class="nx">replace</span><span class="p">(</span><span class="sr">/a/</span><span class="p">,</span> <span class="dl">&apos;</span><span class="s1">e</span><span class="dl">&apos;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
</code></pre></div></div>

<p>So, notice we haven&#x2019;t <strong>uncurried</strong> the function - we&#x2019;re just saying that, if we pass in more than one argument, we&#x2019;d like them to be applied one at a time. To be technical, we&#x2019;ve <strong>sort of uncurried it a little bit</strong>. This means we can hence write an appropriately-named function:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">uncurryish</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">f</span> <span class="o">!==</span> <span class="dl">&apos;</span><span class="s1">function</span><span class="dl">&apos;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">f</span> <span class="c1">// Needn&apos;t curry!</span>

  <span class="k">return</span> <span class="p">(...</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">uncurryish</span><span class="p">(</span>
    <span class="nx">xs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">f</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span> <span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">f</span><span class="p">)</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Maybe a bit ugly, but the gist of it is:</p>

<ul>
  <li>Any non-function gets returned unharmed.</li>
  <li>Functions get wrapped in a function that takes one or more arguments, applies them one by one, then returns <code class="language-plaintext highlighter-rouge">uncurryish</code> of the result.</li>
</ul>

<p>It&#x2019;s that pesky <strong>recursion</strong> again! If you define the <code class="language-plaintext highlighter-rouge">replace</code> and <code class="language-plaintext highlighter-rouge">uncurryish</code> functions as above, you&#x2019;ll see it all working. Yay!</p>

<h2 id="wait-uncurry-i-wanted-curry">Wait, <code class="language-plaintext highlighter-rouge">uncurry</code>? I wanted <code class="language-plaintext highlighter-rouge">curry</code>!</h2>

<p>Well, no, this isn&#x2019;t <code class="language-plaintext highlighter-rouge">uncurry</code> - it just looks a bit like it - but I see your point. When you use something like <a href="http://ramdajs.com/docs/#curry">Ramda&#x2019;s <code class="language-plaintext highlighter-rouge">curry</code></a>, they mean <code class="language-plaintext highlighter-rouge">curryish</code>. The only real difference between <code class="language-plaintext highlighter-rouge">curryish</code> and <code class="language-plaintext highlighter-rouge">uncurryish</code> is that <code class="language-plaintext highlighter-rouge">curryish</code> starts from a &#x201C;normal&#x201D; function (e.g. <code class="language-plaintext highlighter-rouge">(x, y) =&gt; x + y</code>), and <code class="language-plaintext highlighter-rouge">uncurryish</code> starts from a function in this article&#x2019;s style. The end result is the same, although <code class="language-plaintext highlighter-rouge">uncurryish</code> has a <a href="https://github.com/ramda/ramda/blob/v0.22.1/src/internal/_curryN.js"><strong>much</strong> simpler implementation</a>*&#x2026; Whether you use one or the other is totally up to you!</p>

<hr>

<p>Anyway, I hope this has shed some light. I thought it might be easier to start with <code class="language-plaintext highlighter-rouge">uncurry</code> and then bastardise it until it matched the <code class="language-plaintext highlighter-rouge">curry</code> we&#x2019;re used to. All you need to know is that <code class="language-plaintext highlighter-rouge">curry</code> and <code class="language-plaintext highlighter-rouge">uncurryish</code> achieve the same result: they collect up a function&#x2019;s arguments until they have enough to run the function, and then they return the function&#x2019;s results.</p>

<p>It&#x2019;s a really nifty little trick, and you can do some <strong>incredible</strong> refactoring with it. Of course, if anything doesn&#x2019;t make sense, drop me a <a href="https://twitter.com/am_i_tom">tweet</a> or something, and I&#x2019;ll try to clear it up!</p>

<p>Thanks so much for reading!</p>

<p>Take care &#x2665;</p>

<p><em>* Not entirely fair - Ramda does some other stuff like placeholders - but it&#x2019;s definitely more complex because of having to track the argument &#x201C;state&#x201D; explicitly.</em></p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Monoid Est Ton Oid</h1>
  <span class="post-date">03 Nov 2016</span>
  <p><em>A post in English and JavaScript.</em></p>

<p>A while back, I read Hardy Jones&#x2019; <a href="https://joneshf.github.io/programming/2015/12/31/Comonads-Monoids-and-Trees.html">Comonads, Monoids and Trees</a> (it&#x2019;s <em>great</em>, if you haven&#x2019;t read it), and one passage particularly stuck with me:</p>

<blockquote>
  <p>I have been noticing that whenever there is a <code class="language-plaintext highlighter-rouge">reduce</code> around, it is indicative of an abstraction somewhere. Many people call this a code smell.</p>
</blockquote>

<p>I&#x2019;ve been trying to keep this in mind when using <code class="language-plaintext highlighter-rouge">reduce</code>, and trying to capture the logic in a <strong>monoid</strong>. What are monoids, you ask? <em>Well</em>, reader mine, let&#x2019;s build one and find out&#x2026;</p>

<h2 id="motivation">Motivation</h2>

<p>Take this <strong>fold</strong> (basically just a <code class="language-plaintext highlighter-rouge">reduce</code> operation), for example, to find the <strong>sum</strong> of a list:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="c1">// This will produce 45.</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>So, there&#x2019;s nothing <em>wrong</em> with this code, but what if we need to sum other lists? There are two things that we can reuse:</p>

<ul>
  <li>The <strong>reduction function</strong>, <code class="language-plaintext highlighter-rouge">(acc, x) =&gt; acc + x</code></li>
  <li>The <strong>starting value</strong>, <code class="language-plaintext highlighter-rouge">0</code></li>
</ul>

<p>We&#x2019;d have a different pair for the <strong>product</strong> <code class="language-plaintext highlighter-rouge">((acc, x) =&gt; acc * x, 1)</code>, or for finding the <strong>maximum</strong> value <code class="language-plaintext highlighter-rouge">(Math.max, -Infinity)</code>, or anything else. What&#x2019;s important is that the starting value doesn&#x2019;t affect the values in the list: for any <code class="language-plaintext highlighter-rouge">x</code>, we know it&#x2019;s always true that <code class="language-plaintext highlighter-rouge">0 + x = x</code>, <code class="language-plaintext highlighter-rouge">1 * x = x</code>, and <code class="language-plaintext highlighter-rouge">max(x, -Infinity) = x</code>. We&#x2019;ll call each of these values the <strong>identity</strong> for its operation.</p>

<p>Let&#x2019;s neaten up this concept using a data structure:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Sum</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">append</span><span class="p">:</span> <span class="nx">y</span> <span class="o">=&gt;</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">.</span><span class="nx">val</span><span class="p">),</span>
  <span class="na">val</span><span class="p">:</span> <span class="nx">x</span>
<span class="p">})</span>

<span class="nx">Sum</span><span class="p">.</span><span class="nx">identity</span> <span class="o">=</span> <span class="nx">Sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>This structure forms the <code class="language-plaintext highlighter-rouge">Sum</code> <strong>monoid</strong>. We&#x2019;re there. Bam.</p>

<h2 id="is-that-it">Is That It?</h2>

<p>Yep, that&#x2019;s it. We&#x2019;re done. There&#x2019;s honestly no magic to see here. A monoid is a structure that can be <strong>append</strong>ed to other instances of the same structure, and has an <strong>identity</strong> instance. The only other thing we <em>must</em> do is make sure that the <code class="language-plaintext highlighter-rouge">append</code> method is <strong>associative</strong>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For any x, y, and z of the same monoid...</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">y</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="o">===</span> <span class="nx">x</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">z</span><span class="p">))</span>
</code></pre></div></div>

<p>Just use the intuition that, <em>&#x201C;as long as the variables are still in the same left-to-right order, the grouping doesn&#x2019;t matter&#x201D;</em>. This property is really useful when you come to processing <em>lots</em> of data and you want to split the job up between several threads or nodes: split the data up into chunks, combine (<code class="language-plaintext highlighter-rouge">append</code>) all the elements in each chunk, and then combine the chunks. As long as chunk <code class="language-plaintext highlighter-rouge">n</code> is appended to the left of chunk <code class="language-plaintext highlighter-rouge">n + 1</code>, then everything will Just Work&#x2122;!</p>

<p>Given this structure, we can now write a tiny function for dealing with it, which we&#x2019;ll call <code class="language-plaintext highlighter-rouge">fold</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fold</span> <span class="o">=</span> <span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">xs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">M</span><span class="p">(</span><span class="nx">x</span><span class="p">)).</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span>
    <span class="nx">M</span><span class="p">.</span><span class="nx">identity</span>
  <span class="p">)</span>

<span class="c1">// Surprise: it&apos;s 45!</span>
<span class="nx">fold</span><span class="p">(</span><span class="nx">Sum</span><span class="p">,</span> <span class="nx">numbers</span><span class="p">).</span><span class="nx">val</span>
</code></pre></div></div>

<p>We take all the numbers, wrap them in <code class="language-plaintext highlighter-rouge">Sum</code>, and then <code class="language-plaintext highlighter-rouge">append</code> the <code class="language-plaintext highlighter-rouge">Sum</code> instances together to make one overall <code class="language-plaintext highlighter-rouge">Sum</code>! Notice that the <code class="language-plaintext highlighter-rouge">fold</code> function will also work for other monoids, such as <code class="language-plaintext highlighter-rouge">Product</code> and <code class="language-plaintext highlighter-rouge">Max</code>. Implement them if you don&#x2019;t believe me, or you can cheat and jump straight to the JSBin link below!</p>

<p>So, we now only need the <code class="language-plaintext highlighter-rouge">fold</code> method for each of our collection structures, and we can reuse these monoids wherever we want. Instead of each structure needing methods for <code class="language-plaintext highlighter-rouge">max</code>, <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">average</code>, etc, they now only need a <code class="language-plaintext highlighter-rouge">fold</code> method, and we can simply pass in the monoid that captures the operation we want to perform. Simpler code, more declarative logic, and more code reuse. <em>Voila</em>.</p>

<hr>

<p>So, not the longest post, but that&#x2019;s all from me for today. A lot of functional concepts are much simpler than people would have you believe. If you want to have a play, here are the <a href="https://jsbin.com/diwaxefenu/edit?js,console">examples in JSBin</a>. There are many more examples of useful monoids: feel free to research, or try building some of your own.</p>

<p>This post is actually here to provide some background reading for a <a href="https://github.com/i-am-tom/php-folding-talk">PHP talk</a> I&#x2019;m doing next week on monoids and folds. The majority of the talk is around the folding, rather than the monoids, but check out the README for a bigger example of how this all works together.</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Peano&apos;s Forte</h1>
  <span class="post-date">29 Oct 2016</span>
  <p>A hundred-ish years ago, long before Pok&#xE9;mon and the <a href="https://www.youtube.com/watch?v=rUbWjIKxrrs">Slap Chop</a>, there lived a clever one named <a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a>, who came up with a neat way to describe the natural numbers (<code class="language-plaintext highlighter-rouge">0, 1, 2, 3, ...</code>):</p>

<ul>
  <li>
    <p>The first one is <code class="language-plaintext highlighter-rouge">0</code>, which we&#x2019;ll write as <code class="language-plaintext highlighter-rouge">Z</code>.</p>
  </li>
  <li>
    <p>The number after any <code class="language-plaintext highlighter-rouge">x</code> is its <strong>successor</strong>, <code class="language-plaintext highlighter-rouge">S x</code>.</p>
  </li>
</ul>

<p>Using these two rules, we can write every number in the series:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Friendly</th>
      <th style="text-align: left">Peano</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">0</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Z</code></td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">S Z</code></td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">2</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">S (S Z)</code></td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">3</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">S (S (S Z))</code></td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">. . .</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">. . .</code></td>
    </tr>
  </tbody>
</table>

<p>Maybe it&#x2019;s not the prettiest, but I think it&#x2019;s pretty cool. A number is either <code class="language-plaintext highlighter-rouge">Z</code> or the <code class="language-plaintext highlighter-rouge">S</code> of another number, which is either <code class="language-plaintext highlighter-rouge">Z</code> or the <code class="language-plaintext highlighter-rouge">S</code> of another number, which is&#x2026; well, you get the picture! We call this a <strong>recursive definition</strong>.</p>

<p>Because of this, we can define functions on the Peano numbers using recursion, too! Here&#x2019;s a function for testing equivalence:</p>

<table>
  <thead>
    <tr>
      <th>A</th>
      <th>B</th>
      <th>A == B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">S x</code></td>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">S y</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">S x</code></td>
      <td><code class="language-plaintext highlighter-rouge">S y</code></td>
      <td><code class="language-plaintext highlighter-rouge">x == y</code></td>
    </tr>
  </tbody>
</table>

<p>Rule <strong>3</strong> might seem like a duplicate of <strong>2</strong>, but we have to define both in case the order of arguments matters (e.g. with subtraction, <code class="language-plaintext highlighter-rouge">2 - 3</code> is not the same as <code class="language-plaintext highlighter-rouge">3 - 2</code>).</p>

<p>Rule <strong>4</strong> is the magical recursive bit: if <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are still successors, we run rule <strong>4</strong> again, and we keep doing that until one of the other three conditions is met. We can write out the process for determining <code class="language-plaintext highlighter-rouge">2 == 3</code> with our Peano numbers:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))</span>
  <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span> <span class="c1">-- By rule 4</span>
  <span class="o">=&gt;</span> <span class="kt">Z</span> <span class="o">==</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>         <span class="c1">-- By rule 4</span>
  <span class="o">=&gt;</span> <span class="n">false</span>              <span class="c1">-- By rule 2</span>
</code></pre></div></div>

<p>Loads of brackets, but it&#x2019;s hopefully clear enough to see what&#x2019;s going on: for as long as both of the arguments are successors, we remove one <code class="language-plaintext highlighter-rouge">S</code> at each step until one <code class="language-plaintext highlighter-rouge">Z</code>. If the other reaches <code class="language-plaintext highlighter-rouge">Z</code> at the same time, then the two numbers are equal! Ooer.</p>

<p>Defining addition is also fairly straightforward:</p>

<table>
  <thead>
    <tr>
      <th>A</th>
      <th>B</th>
      <th>A + B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">S x</code></td>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">S x</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td><code class="language-plaintext highlighter-rouge">S y</code></td>
      <td><code class="language-plaintext highlighter-rouge">S y</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">S x</code></td>
      <td><code class="language-plaintext highlighter-rouge">S y</code></td>
      <td><code class="language-plaintext highlighter-rouge">S (S (x + y))</code></td>
    </tr>
  </tbody>
</table>

<p>Rules <strong>1</strong>, <strong>2</strong>, and <strong>3</strong> define our <em>base cases</em>: adding <code class="language-plaintext highlighter-rouge">Z</code> to any value produces that same value. Rule <strong>4</strong>, of course, is where we define our recursion. Let&#x2019;s look at an example with <code class="language-plaintext highlighter-rouge">3 + 2</code>. We&#x2019;ll use square brackets to make things clearer, but just think of them as regular brackets:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))</span> <span class="o">+</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span>
  <span class="o">=&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">[(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)])</span> <span class="c1">-- By rule 3</span>
  <span class="o">=&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">[(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="o">+</span> <span class="kt">Z</span><span class="p">])))</span> <span class="c1">-- By rule 3</span>
  <span class="o">=&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))))</span>       <span class="c1">-- By rule 1</span>
</code></pre></div></div>

<p>And there you have it! One more example that&#x2019;s worth mentioning before we go is how to convert our Peano numbers back into the integers that we know and love:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">A</th>
      <th style="text-align: left">toInt A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">Z</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">S x</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">1 + toInt x</code></td>
    </tr>
  </tbody>
</table>

<p>We only need one argument for this, so the function is super straightforward. Yay! Here&#x2019;s the function working with <code class="language-plaintext highlighter-rouge">3</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toInt</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))</span>
  <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">toInt</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span> <span class="c1">-- By rule 2</span>
  <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">toInt</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="c1">-- By rule 2</span>
  <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">toInt</span> <span class="kt">Z</span> <span class="c1">-- By rule 2</span>
  <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span>       <span class="c1">-- By rule 1</span>
  <span class="o">=&gt;</span> <span class="mi">3</span>                   <span class="c1">-- By addition</span>
</code></pre></div></div>

<hr>

<p>Ok, so this maybe isn&#x2019;t the sexiest concept, but we&#x2019;ve covered some important stuff:</p>

<ul>
  <li>
    <p>We can use <strong>recursion</strong> to write simple definitions of functions that can just call themselves to deal with each &#x201C;step&#x201D; of the problem.</p>
  </li>
  <li>
    <p>We can use <strong>induction</strong> to show that, if a function works for <code class="language-plaintext highlighter-rouge">Z</code> (or some other base case) and <code class="language-plaintext highlighter-rouge">S x</code>, it can work for <em>any</em> Peano number!</p>
  </li>
  <li>
    <p>Running a function is just substituting one thing for another! Functions shouldn&#x2019;t <em>do</em> anything - they should just swap an input for an output.</p>
  </li>
</ul>

<p>That&#x2019;s all from me today! If you want to play around with the concepts, you can use this <a href="http://try.purescript.org/?gist=d2be4384a7b4cc6283be5097df12c63c">try.purescript.org gist</a> to play with the code. Otherwise, I hope this was at least a little interesting, and I&#x2019;ll talk to you soon!</p>

<p>Take care &#x2665;</p>

<hr/><a name="[object Object]"></a>
  <h1 class="post-title">Hello, The Internet</h1>
  <span class="post-date">27 Oct 2016</span>
  <p>I&#x2019;m Tom. I write code, which <em>hopefully</em> turns out better than my introductions. Fingers crossed.</p>

<p>This blog is going to be a collection of things, the majority probably being articles and tutorials around functional wizardry (I tend to go on about this).</p>

<p>I&#x2019;d like to say that this pretty website is my doing, but it&#x2019;s actually just a stripped down version of <a href="http://lanyon.getpoole.com">Lanyon</a>, which is a magical little Jekyll theme.</p>

<p>Now that this post is out the way, we can get to more interesting things, and I hope we&#x2019;ll talk more soon. I&#x2019;ll try to keep things interesting.</p>

<p>Take care &#x2665;</p>

    </div>
  </div>
</div>
</body></html>